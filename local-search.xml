<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LOAM论文与代码阅读（二）建图</title>
    <link href="/2023/09/23/LOAM%E8%AE%BA%E6%96%87%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB2/"/>
    <url>/2023/09/23/LOAM%E8%AE%BA%E6%96%87%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB2/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>上一篇学习了LOAM的里程计。里程计输入原始点云，得到了去畸变的点云和帧间位姿。但帧间位姿不断递推会导致误差不断积累，因此我们需要将帧（单帧或多帧）与地图进行匹配来优化位姿，同时建立全局地图。本篇就来学习LOAM中后端优化建图的过程。</p>          </div><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p>建图的整体流程如下：</p><p>建图的算法对每个sweep运行一次。</p><p>输入：在第k+1个sweep结束时，我们得到了去畸变的点云 $\overline{P}<em>{k+1}$, 和这一帧相对于上一帧的变换 $T^L</em>{k+1}$。同时我们有一个地图$Q_k$，是由前k帧建立的全局地图点云，和上一帧建图时估计的位姿$T_k^W$，即$t_k$时刻lidar相对于世界坐标系的位姿。（世界坐标系即为$Q_k$建立的坐标系，常使用第一帧的坐标系作为世界坐标系）</p><p>输出：$T_{k+1}^W$</p><p>方法：根据$T_k^W$和$T^L_{k+1}$，我们可以得到$T_{k+1}^W$的一个估计值。用这个值我们将$\overline{P}<em>{k+1}$投影到世界坐标系，用$\overline{Q}</em>{k+1}$表示。把$\overline{Q}<em>{k+1}$与地图$Q_k$匹配，就可以优化位姿$T</em>{k+1}^W$了。</p><h3 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h3><ol><li>提取特征点的方式与里程计相同，但是提取更多的特征点（10倍）。</li></ol><div class="note note-success">            <p>由于地图更稠密，而且建图运行频率低，所以可以提取更多特征点？而且建图需要得到一个更准确的位姿估计。</p>          </div><ol start="2"><li><p>对于地图中大量的点云如果全部存储成kd-tree，树的深度很大，不易存储。地图首先被划分成10m的体素格，再将与当前$\overline{Q}_{k+1}$有重叠区域的体素格中的点存成kd-tree.</p></li><li><p>对于$\overline{Q}_{k+1}$中的一个特征点i，我们先找在$Q_k$中在i附近一定区域内的点，设这些点构成集合S’。如果i是边缘点，我们只保留S’中的边缘点。如果i是平面点，我们只保留S中的平面点。</p></li><li><p>然后我们计算S’的协方差矩阵为M。计算M的特征值和特征向量得到V和E。如果i是边缘点，S’应对应一条边缘线，它的特征值应该有1个显著大于另外两个，对应的特征向量代表了这条边缘线的方向。如果i是平面点，S’应对应一个平面，它的特征值应该有2个显著大于另外1个，对应的两个特征向量代表了这个平面的方向。</p></li><li><p>然后我们取边缘线上的两个点，平面上的三个点，用和里程计里同样的方式计算距离。得到有关外参$T^W_{k+1}$的损失函数。同样用鲁棒拟合（bisquare weight）和LM方法来优化。</p></li><li><p>优化完成后，我们把第k+1帧点云加入地图。为了使得地图上的点均匀分布，对地图做5cm的体素降采样。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>SLAM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pyside6应用过程中的问题记录</title>
    <link href="/2023/09/19/pyside6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/09/19/pyside6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>近期在做的任务要把交通路网结构用PySide6可视化，并添加一些选择车道，拖拽车辆之类的交互操作。以下是在应用过程中出现的一些问题和解决方案。</p><h3 id="问题1：qgraphicsview画polyline"><a href="#问题1：qgraphicsview画polyline" class="headerlink" title="问题1：qgraphicsview画polyline"></a>问题1：qgraphicsview画polyline</h3><p>由于希望界面上的部件都可以交互（点击，拖拽），因此我尝试在<code>QGrahicsView</code>类里画，但发现<code>QGraphicsScene</code>没有可直接调用的画polyline的函数，可行的方法是先画出QPainterPath，再用QGraphicsPath。如下面的程序，drawPolyline函数可输入2D points, color, width，画出这些点的折线段。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainWidget</span>(QtWidgets.QGraphicsView)<br>&#123;<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.initUI()<br>        self.scaleFactor = <span class="hljs-number">1</span><br>        self.resize(<span class="hljs-number">800</span>, <span class="hljs-number">800</span>) <br><br>        self.scene_map = QtWidgets.QGraphicsScene()<br>        self.scene_map.setSceneRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">700</span>, <span class="hljs-number">700</span>)<br>        self.scene_map.setBackgroundBrush(Qt.white)<br>        self.setScene(self.scene_map)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">drawPolyline</span>(<span class="hljs-params">self, points:<span class="hljs-built_in">list</span>[<span class="hljs-built_in">tuple</span>], color:QtGui.QColor, width:<span class="hljs-built_in">int</span> = <span class="hljs-number">1.0</span></span>):<br>        points = [QPointF(x,y) <span class="hljs-keyword">for</span> x,y <span class="hljs-keyword">in</span> points]<br>        path = QtGui.QPainterPath()<br>        polygon = QtGui.QPolygonF(points)<br>        path.addPolygon(polygon)<br>        <br>        pen = QtGui.QPen(color)<br>        pen.setWidth(width)<br>        new_item = QtWidgets.QGraphicsPathItem(path, <span class="hljs-literal">None</span>)<br>        new_item.setPath(path)<br>        new_item.setPen(pen)<br>        self.scene_map.addItem(new_item)<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="问题2：画出来的polyline不够平滑，有锯齿"><a href="#问题2：画出来的polyline不够平滑，有锯齿" class="headerlink" title="问题2：画出来的polyline不够平滑，有锯齿"></a>问题2：画出来的polyline不够平滑，有锯齿</h3><p>用上述方式画出的图如下图左图所示：斜线会有锯齿，只有完全水平或竖直或45度的线才是粗细均匀的。</p><img src="/2023/09/19/pyside6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/1.png" class="" title="fig:1"><p>为了平滑线段，可以给<code>QGraphicsview</code>设置渲染的参数<code>setRenderHint</code>为antialiasing（抗锯齿）。在<code>__init__</code>函数里加入下面一行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.setRenderHint(QtGui.QPainter.Antialiasing, <span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>得到的结果如上面右图所示，可以看到没有锯齿了。</p><h3 id="问题3：拖拽时view无法超过scene的大小"><a href="#问题3：拖拽时view无法超过scene的大小" class="headerlink" title="问题3：拖拽时view无法超过scene的大小"></a>问题3：拖拽时view无法超过scene的大小</h3><p>设置滚轮放大缩小功能需要重写wheelEvent函数，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">wheelEvent</span>(<span class="hljs-params">self, event: QtGui.QWheelEvent</span>) -&amp;gt; <span class="hljs-literal">None</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.scene().items()) == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span><br><br>    curPoint = event.position()<br>    scenePos = self.mapToScene(QPoint(curPoint.x(), curPoint.y()))<br><br>    viewWidth = self.viewport().width()<br>    viewHeight = self.viewport().height()<br><br>    hScale = curPoint.x() / viewWidth<br>    vScale = curPoint.y() / viewHeight<br><br>    wheelDeltaValue = event.angleDelta().y()<br>    self.scaleFactor = self.transform().m11()<br>    <span class="hljs-keyword">if</span> (self.scaleFactor &amp;lt; <span class="hljs-number">0.05</span> <span class="hljs-keyword">and</span> wheelDeltaValue&amp;lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">or</span> (self.scaleFactor&amp;gt;<span class="hljs-number">50</span> <span class="hljs-keyword">and</span> wheelDeltaValue&amp;gt;<span class="hljs-number">0</span>):<br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">if</span> wheelDeltaValue &amp;gt; <span class="hljs-number">0</span>:<br>        self.scale(<span class="hljs-number">1.1</span>, <span class="hljs-number">1.1</span>)<br>    <span class="hljs-keyword">else</span>:<br>        self.scale(<span class="hljs-number">1.0</span>/<span class="hljs-number">1.1</span>, <span class="hljs-number">1.0</span>/<span class="hljs-number">1.1</span>)<br>    <br>    viewPoint = self.transform().<span class="hljs-built_in">map</span>(scenePos)<br>    self.horizontalScrollBar().setValue(<span class="hljs-built_in">int</span>(viewPoint.x() - viewWidth * hScale ))<br>    self.verticalScrollBar().setValue(<span class="hljs-built_in">int</span>(viewPoint.y() - viewHeight * vScale ))<br><br>    self.update()<br></code></pre></td></tr></table></figure><p>设置鼠标拖拽功能只需要给QGraphicsView设置setDragMode，在window类初始化时加入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)<br></code></pre></td></tr></table></figure><p>但在显示底图时由于图比较大，我并不想一开始显示全部，而只是显示一部分，如下图（1）。此时我的拖拽功能只在相比原始scene放大时才有用（在图（2）时可以拖拽）。当地图缩小后尽管还未显示地图全貌，但无法拖动（图（3）无法拖动）。</p><img src="/2023/09/19/pyside6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/2.png" class="" title="fig:2"><p>参考这个回答：<a href="https://stackoverflow.com/questions/55007339/allow-qgraphicsview-to-move-outside-scene">https://stackoverflow.com/questions/55007339/allow-qgraphicsview-to-move-outside-scene</a></p><p>一个简单粗暴的解决方法是给scene设置足够大的初始大小。在我的例子中我将大小改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.scene_map.setSceneRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">2000</span>)<br></code></pre></td></tr></table></figure><p>这样就可以在上图（3）仍然可以拖动。不过修改scene_map的大小后要注意原本点的位置的按照scene_map的大小改变。由于<code>QGraphicsScene</code>默认是中心和<code>QGraphicsView</code>对齐的，如scene_map大小设为(2000,2000)，那么此时scene中心点的坐标(1000,1000)会显示在view的中心。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LOAM论文与代码阅读（一）激光里程计</title>
    <link href="/2023/09/19/LOAM%E8%AE%BA%E6%96%87%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB1/"/>
    <url>/2023/09/19/LOAM%E8%AE%BA%E6%96%87%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB1/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>LOAM 是LiDAR SLAM早期的奠基之作，后续的LeGO-LOAM, lio-sam，ALOAM等方法都以这种高频里程计，低频建图为基础框架。我在最初接触SLAM时学习过这一系列算法，但理解的不深，后来因为没有做lidar SLAM相关，很久不接触已经生疏了。近期考虑到面试需求和未来的职业方向，计划重新学一遍，同时把重点记录下来，以便后续回顾。</p>          </div><p>LOAM的基本流程如下：</p><img src="/2023/09/19/LOAM%E8%AE%BA%E6%96%87%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB1/1.png" class="" title="fig:1"><p>每一帧lidar通过特征提取，运动补偿，特征匹配得到帧与帧之间的位姿（高频）。将几帧拼在一起与地图进行匹配，优化这几帧相对于地图的位姿（低频）。</p><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><p>这里发现之前忽略的一个点。LOAM中使用的激光雷达与现在的多线机械式激光雷达（如velodyne-32）不同。作者是用一个单线激光雷达加上垂直旋转的电机实现3维的扫描。</p><center><img src="2.png" width="60%" height="60%" /></center><p>论文中的介绍如上图所示，我的理解是：</p><p>单线激光雷达自身水平旋转，水平视场角为180度，分辨率为0.25度。每次旋转180得到的数据称为一个scan，需要25ms。同时电机使得激光雷达整体在垂直方向上旋转，从-90到90，水平为0（因此垂直视场角是180）。这样垂直转180度需要1s，1s内得到的数据是一个sweep。这一秒内会扫描40个scan。相当于在垂直方向上是40线,角分辨率是4.5度。</p><p>这也解释了这里scan的指代和其他论文不对应的问题。当前较多使用的多线激光雷达，可近似认为垂直方向的多条laser是同时发射的（实际上不同时，但相隔时间非常接近），因此把多线在水平方向一个周期内的扫描称为一个scan，用于特征提取。</p><h3 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h3><p>如上所述，由于垂直角分辨率是4.5度，角度较大，因此提取特征是对每个scan进行单独操作。希望提取的特征点是边缘（edge）和平面（planar surface）上的点。</p><p><font color=gray>边缘和平面特征显著，容易提取，反应了环境的结构，在帧与帧之间保持不变，更有利于匹配。</font></p><p>为了提取边缘点和平面点，我们首先要计算每个点的曲率。一个scan是单线激光按顺时针或逆时针扫描得到的点，如下图所示，为计算点i的曲率，我们取它前后N个点，组成集合S。</p><img src="/2023/09/19/LOAM%E8%AE%BA%E6%96%87%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB1/3.png" class="" title="fig:3"><p>则曲率c为：</p><p>$$c&#x3D;  \frac{1}{|S| \cdot |X_ {(k,i)|}  |}|<br>\sum_{j \in S,j \neq i} ( X_ {(k,i)}^ {L}  -  X_{(k,j)}^ {L} ) |<br>$$</p><p>$X_{(k,i)}^L$是第k个sweep中第i个点在LiDAR坐标系下的坐标。对集合中的每个点计算其与相邻点的距离，用来近似这个点所在位置的曲率。可以想象在平面处相邻点的距离比较接近，曲率会较小，而边缘处点的距离会较远，曲率较大。</p><p>对应ALOAM中的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 取每个点前后5个点，算x,y,z方向的差</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">5</span>; i &lt; cloudSize - <span class="hljs-number">5</span>; i++)<br>&#123; <br>    <span class="hljs-type">float</span> diffX = laserCloud-&gt;points[i - <span class="hljs-number">5</span>].x + laserCloud-&gt;points[i - <span class="hljs-number">4</span>].x + laserCloud-&gt;points[i - <span class="hljs-number">3</span>].x + laserCloud-&gt;points[i - <span class="hljs-number">2</span>].x + laserCloud-&gt;points[i - <span class="hljs-number">1</span>].x - <span class="hljs-number">10</span> * laserCloud-&gt;points[i].x + laserCloud-&gt;points[i + <span class="hljs-number">1</span>].x + laserCloud-&gt;points[i + <span class="hljs-number">2</span>].x + laserCloud-&gt;points[i + <span class="hljs-number">3</span>].x + laserCloud-&gt;points[i + <span class="hljs-number">4</span>].x + laserCloud-&gt;points[i + <span class="hljs-number">5</span>].x;<br>    <span class="hljs-type">float</span> diffY = laserCloud-&gt;points[i - <span class="hljs-number">5</span>].y + laserCloud-&gt;points[i - <span class="hljs-number">4</span>].y + laserCloud-&gt;points[i - <span class="hljs-number">3</span>].y + laserCloud-&gt;points[i - <span class="hljs-number">2</span>].y + laserCloud-&gt;points[i - <span class="hljs-number">1</span>].y - <span class="hljs-number">10</span> * laserCloud-&gt;points[i].y + laserCloud-&gt;points[i + <span class="hljs-number">1</span>].y + laserCloud-&gt;points[i + <span class="hljs-number">2</span>].y + laserCloud-&gt;points[i + <span class="hljs-number">3</span>].y + laserCloud-&gt;points[i + <span class="hljs-number">4</span>].y + laserCloud-&gt;points[i + <span class="hljs-number">5</span>].y;<br>    <span class="hljs-type">float</span> diffZ = laserCloud-&gt;points[i - <span class="hljs-number">5</span>].z + laserCloud-&gt;points[i - <span class="hljs-number">4</span>].z + laserCloud-&gt;points[i - <span class="hljs-number">3</span>].z + laserCloud-&gt;points[i - <span class="hljs-number">2</span>].z + laserCloud-&gt;points[i - <span class="hljs-number">1</span>].z - <span class="hljs-number">10</span> * laserCloud-&gt;points[i].z + laserCloud-&gt;points[i + <span class="hljs-number">1</span>].z + laserCloud-&gt;points[i + <span class="hljs-number">2</span>].z + laserCloud-&gt;points[i + <span class="hljs-number">3</span>].z + laserCloud-&gt;points[i + <span class="hljs-number">4</span>].z + laserCloud-&gt;points[i + <span class="hljs-number">5</span>].z;<br><br>    cloudCurvature[i] = diffX * diffX + diffY * diffY + diffZ * diffZ;<br>    cloudSortInd[i] = i;<br>    cloudNeighborPicked[i] = <span class="hljs-number">0</span>;<br>    cloudLabel[i] = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对一个scan的曲率按照c值排序，其中最大的n个点选择为edge点，最小的m个点为平面点。为了使得特征点分布更均匀，论文把一个scan平分为4个子区域，每个子区域最多选2个边缘点，4个平面点，边缘和平面有设定一个阈值（只有超过阈值才可能选为边缘点）。</p><p>此外，还要去掉一些不可信赖的点：</p><ul><li>附近已经有点选中了（避免特征点太集中）</li><li>局部平面和laser光束平行，如下图（a）</li><li>在被遮挡的区域边缘的点，如下图（b）</li></ul><img src="/2023/09/19/LOAM%E8%AE%BA%E6%96%87%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB1/4.png" class="" title="fig:4"><p>这些点的删除方式是：当根据曲率得到特征点后，重新去看这些点用于计算曲率的点集S，需要保证S中的点没有被选中为特征点，点集构成的平面不与激光线平行，且点集中相邻点没有在激光方向上的出现距离的不连续。</p><h3 id="特征匹配"><a href="#特征匹配" class="headerlink" title="特征匹配"></a>特征匹配</h3><h4 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h4><p>第k个sweep的原始点云表示为$P_k$，$P_k$开始的时间为$t_k$。经过运动补偿（统一到这一帧结束时刻）的点云为$\overline{P}_k$。</p><h4 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h4><p>为了对流程有整体的认知，明白每一步的原因，我们先看大致的lidar odometry的流程，细节留到后面分析：</p><center><img src="5.png" width="70%" height="70%" /></center><ul><li><p>输入：前一帧去畸变的点云$\overline{P}_k$，当前帧不断增加的点云$P_k$（由于程序是实时运行的），</p></li><li><p>输出：$T^L_{k+1}$,是lidar在$(t_{k+1}$，$t_{k+2})$之间的变换，即点云$\overline{P}<em>{k+1}$相对于$\overline{P}</em>{k}$变换</p></li></ul><p>$T^L_{k+1}$是通过不断迭代获得的。在k+1帧起始时刻$t_{k+1}$，$T^L_{k+1}$为单位矩阵。我们现在假设上一次迭代得到的位姿为$T^{L}_{k+1}$，来推导一次迭代过程：</p><ol><li>特征提取：首先从$P_{k+1}$中提取edge和plane特征点，用$\varepsilon_{k+1}, H_{k+1}$表示。</li><li>运动补偿：为了和上一帧做匹配，我们可以用$T^L_{k+1}$和匀速运动模型将$\varepsilon_{k+1}, H_{k+1}$投影到这一帧开始时刻，表示为$\widetilde{\varepsilon}<em>{k+1}, \widetilde{H}</em>{k+1}$<font color=red>（细节1）</font>。</li><li>特征匹配：将$\widetilde{\varepsilon}<em>{k+1}, \widetilde{H}</em>{k+1}$与上一帧$\overline{P}_k$匹配。对边缘点，我们找到上一帧对应的线，计算点到线的距离。对平面点，我们找到上一帧对应的平面，计算点到平面的距离。<font color=red>（细节2）</font>。</li><li>位姿优化：这些距离是$T^L_{k+1}$的一个非线性函数，每个距离根据特征点会分配一个权重。构成了对T一个非线性优化问题，应用LM优化求解。将上一次的$T^L_{k+1}$作为初值，当迭代一定次数或者函数收敛后，返回新的$T^L_{k+1}$。<font color=red>（细节3）</font>。</li></ol><p>这个迭代在sweep内不停地进行，直到sweep结束，并把$P_{k+1}$所有点用$T^L_{k+1}$投影到这一帧结束（运动补偿），得到$\overline{P}_{k+1}$作为下一帧的输入。</p><p>接下来我们看这里面每一步的细节：</p><h4 id="细节1：运动补偿"><a href="#细节1：运动补偿" class="headerlink" title="细节1：运动补偿"></a>细节1：运动补偿</h4><p>由于机械式lidar所有点获得的时间戳不同，在lidar运动时，每个点的lidar坐标系实际位置不同。我们要对一个sweep的lidar做运动补偿，把所有(x,y,z)的坐标系统一到一个时刻，作为一帧点云。原始的LOAM没有用IMU，而是假设在一个sweep内角速度和线速度是恒定的。整个过程中涉及运动补偿的流程有两个，一是为了与上一帧进行特征匹配，把所有点投影到这一帧开始时刻，二是在迭代结束之后，把所有点投影到这一帧结束时刻作为下一帧输入。</p><p><strong>把$P_{k+1}$的点投影到开始时刻：</strong><br>为了把各个时刻的点投影到这一帧开始，我们需要知道每个点相对于这一帧初始时刻的位姿，这个位姿可以通过对$T^L_{k+1}$插值得到。$T^L_{k+1}$是当前时刻t下，我们估计的$(t_{k+1}, t)$变化的位姿。</p><p>对于i时刻的点，我们求得的位姿变换如下：</p><p>$$  T_{(k+1,i)}^{L}  &#x3D;  \frac{t_{i}-t_{k+1}}{t-t_{k+1}}  T_{k+1}^ {L} $$</p><p>从$T_{(k+1,i)}^{L}$中拆解出R,t，可以得到补偿后的特征点坐标$\widetilde {X}_ {(k+1,i)}^L$</p><p> $$ X_{(k+1,i)}^L<br>&#x3D;R  \widetilde {X}_ {(k+1,i)}^L  +  t $$</p><p><strong>把$P_{k+1}$的点投影到结束时刻：</strong></p><p>在这一帧结束后，我们得到了$(t_{k+1}$，$t_{k+2})$之间的位姿变换$T_{k+1}^{L}$。我们先把所有点按照上述方法投影到这一帧的开始时刻，然后用$T_{k+1}^{L}$反变换，将所有点投影到这一帧结束时刻。</p><p><strong>对应ALOAM的代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//（TransformToStart：将当前帧Lidar坐标系下的点云变换到这一帧开始</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TransformToStart</span><span class="hljs-params">(PointType <span class="hljs-type">const</span> *<span class="hljs-type">const</span> pi, PointType *<span class="hljs-type">const</span> po)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//interpolation ratio</span><br>    <span class="hljs-type">double</span> s;            <span class="hljs-comment">//插值比，根据时间，在这一帧里占的比率</span><br>    <span class="hljs-keyword">if</span> (DISTORTION)      <span class="hljs-comment">//是否需要去畸变</span><br>    <span class="hljs-comment">// intensity 实数部分存的是scan上点的id，小数部分存的这一点相对这一帧起始点的时间差</span><br>    <span class="hljs-comment">// intensity的整体减去整数部分,就是时间差,除以周期,就是时间占比了</span><br>        s = (pi-&gt;intensity - <span class="hljs-built_in">int</span>(pi-&gt;intensity)) / SCAN_PERIOD;<br>    <span class="hljs-keyword">else</span><br>        s = <span class="hljs-number">1.0</span>;<br><br>    <span class="hljs-comment">// 所有点的操作方式都是一致的，相当于从结束时刻补偿到起始时刻，相当于是一个匀速模型的假设</span><br><br>    Eigen::Quaterniond q_point_last = Eigen::Quaterniond::<span class="hljs-built_in">Identity</span>().<span class="hljs-built_in">slerp</span>(s, q_last_curr); <span class="hljs-comment">//slerp函数(球面线性插值)</span><br>    Eigen::Vector3d t_point_last = s * t_last_curr;<br>    <span class="hljs-function">Eigen::Vector3d <span class="hljs-title">point</span><span class="hljs-params">(pi-&gt;x, pi-&gt;y, pi-&gt;z)</span></span>;         <span class="hljs-comment">//把当前点的坐标取出</span><br>    Eigen::Vector3d un_point = q_point_last * point + t_point_last; <span class="hljs-comment">//通过旋转和平移将 当前点转到帧起始时刻坐标系下的坐标</span><br><br>    <span class="hljs-comment">//将求得的转换后的坐标赋值给输出点</span><br>    po-&gt;x = un_point.<span class="hljs-built_in">x</span>();<br>    po-&gt;y = un_point.<span class="hljs-built_in">y</span>();<br>    po-&gt;z = un_point.<span class="hljs-built_in">z</span>();<br>    po-&gt;intensity = pi-&gt;intensity;<br>&#125;<br><br><br><span class="hljs-comment">// 首先把点统一到起始时刻坐标系下,再通过反变换,得到结束时刻坐标系下的点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TransformToEnd</span><span class="hljs-params">(PointType <span class="hljs-type">const</span> *<span class="hljs-type">const</span> pi, PointType *<span class="hljs-type">const</span> po)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// undistort point first</span><br>    pcl::PointXYZI un_point_tmp;<br>    <span class="hljs-built_in">TransformToStart</span>(pi, &amp;un_point_tmp);        <span class="hljs-comment">//转到帧起始时刻坐标系下的点</span><br><br>    <span class="hljs-function">Eigen::Vector3d <span class="hljs-title">un_point</span><span class="hljs-params">(un_point_tmp.x, un_point_tmp.y, un_point_tmp.z)</span></span>;       <span class="hljs-comment">//取出起始时刻坐标系下的点的x,y,z</span><br>    Eigen::Vector3d point_end = q_last_curr.<span class="hljs-built_in">inverse</span>() * (un_point - t_last_curr);   <span class="hljs-comment">//通过反变换,求得转到 结束时刻坐标系下 的点坐标</span><br><br>    <span class="hljs-comment">//将求得的转换后的坐标赋值给输出点</span><br>    po-&gt;x = point_end.<span class="hljs-built_in">x</span>();<br>    po-&gt;y = point_end.<span class="hljs-built_in">y</span>();<br>    po-&gt;z = point_end.<span class="hljs-built_in">z</span>();<br><br>    <span class="hljs-comment">//Remove distortion time info  去完畸变可以删除每个点的时间信息</span><br>    po-&gt;intensity = <span class="hljs-built_in">int</span>(pi-&gt;intensity);<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="细节2：特征匹配"><a href="#细节2：特征匹配" class="headerlink" title="细节2：特征匹配"></a>细节2：特征匹配</h4><p>用$\widetilde{\varepsilon}<em>{k+1}, \widetilde{H}</em>{k+1}$表示投影到开始时刻的特征点。特征匹配的方式如下：</p><center><img src="6.png" width="50%" height="50%" /></center><p><strong>边缘点（图a)：</strong></p><p>对于$\widetilde{\varepsilon}_{k+1}$中的点i，我们要找到它在k帧中对应的边缘线，为了确定这条线，我们需要找到两个点。一个点j为离i距离最近的点。一个点l是在点j所在scan（橙线）的相邻两个scan（蓝线）中找到离i最近的点。为了确认j,l是边缘点，会确认它们的曲率c（根据特征提取时的公式）。</p><div class="note note-info">            <p>原因：因为一条边缘线不可能包含一个scan内的多个点。如果这条边缘线由一个scan内的两个点组成，那么这个边缘线与scan所在平面平行，此时这条边缘线在这个scan中的点是一条直线，不会计算出高的曲率，因此不可能被提取为特征点。</p>          </div><p>得到j,l后，我们计算点到直线的距离来衡量匹配的程度：</p><p>$$ d_\varepsilon &#x3D;  \frac{|(\widetilde{X}^L_{(k+1,i)}-\overline{X}^L_{(k,j)})\times (\widetilde{X}^L_{(k+1,i)}-\overline {X}^L_{(k,l)})|}{|\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,l)}|} $$</p><p><strong>平面点（图b):</strong></p><p>对于$\overline{H}_{k+1}$中的点 $i$，我们要找到它在k帧中对应的平面，为了确定这个平面，我们需要找到三个点。同样，一个点j为离i距离最近的点。然后我们找到另外两个距离i最近的点$l,m$。其中$l$需要与点$j$在同一个scan（橙线），点$m$在相邻两个scan（蓝线）。为了确认j,l是平面点，会确认它们的曲率c</p><div class="note note-info">            <p>原因：为了防止三点共线？</p>          </div><p>得到j,l,m后，我们计算点到平面的距离来衡量匹配的程度：</p><p>$$ d_H &#x3D;  \frac{\left| \begin{matrix} (\widetilde{X}^L_{(k+1,i)}-\overline{X}^L_{(k,j)}) \ ((\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,l)})\times (\overline{X}^L_{(k,l)}-\overline {X}^L_{(k,m)})) \end{matrix} \right| }{|(\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,l)})\times (\overline{X}^L_{(k,l)}-\overline {X}^L_{(k,m)})|} $$</p><p><font color=gray>为了更快找最近邻，$\overline{P}_k$是以3D kd-tree存储的</font></p><h4 id="位姿优化"><a href="#位姿优化" class="headerlink" title="位姿优化"></a>位姿优化</h4><p>对于边缘点，我们可以得到损失函数：</p><p>$$ f <em>\varepsilon  (  X</em> {(k+1,i)}^ {L}  ,  T_ {k+1}^ {L} )&#x3D;d_\varepsilon ,i \in \varepsilon_ {k+1} $$</p><p>对于平面点，我们可以得到损失函数：</p><p>$$ f_H  (  X_{(k+1,i)}^ {L}  ,  T_ {k+1}^ {L} )&#x3D;d_H ,i \in H_ {k+1} $$</p><p>把这些损失放在一起，可以得到：</p><p>$$ \bold{f}(T_{k+1}^L) &#x3D; \bold{d} $$</p><p>其中 $\bold{d}$ 的每一行都是一个特征点的损失。我们可以计算f相对于T的雅可比矩阵J，然后用LM算法来优化。在优化时每行损失分配了不同的权重，匹配距离大的点权重更小，匹配距离大于一定值的点权重为0（被认为是误匹配）。也就是Bisquare weights, 根据每一项损失当前的大小分配权重，优先去降低小的损失项，减轻大的损失项的影响。这种方式更加鲁棒。这部分在代码中是用ceres来实现的。</p>]]></content>
    
    
    <categories>
      
      <category>SLAM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PCL对大规模点云进行体素降采样</title>
    <link href="/2023/09/14/pcl%E5%A4%A7%E8%A7%84%E6%A8%A1%E7%82%B9%E4%BA%91%E9%99%8D%E9%87%87%E6%A0%B7/"/>
    <url>/2023/09/14/pcl%E5%A4%A7%E8%A7%84%E6%A8%A1%E7%82%B9%E4%BA%91%E9%99%8D%E9%87%87%E6%A0%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="普通体素降采样"><a href="#普通体素降采样" class="headerlink" title="普通体素降采样"></a>普通体素降采样</h3><p>直接调用voxel_grid库，参考<a href="https://pcl.readthedocs.io/projects/tutorials/en/latest/voxel_grid.html">官方教程</a>，只需要设置体素的大小<code>setLeafSize(x, y, z)</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pcl/io/pcd_io.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pcl/point_types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pcl/filters/voxel_grid.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    pcl::<span class="hljs-function">PCLPointCloud2::Ptr <span class="hljs-title">cloud</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> pcl::PCLPointCloud2 ())</span></span>;<br>    pcl::<span class="hljs-function">PCLPointCloud2::Ptr <span class="hljs-title">cloud_filtered</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> pcl::PCLPointCloud2 ())</span></span>;<br><br>    <span class="hljs-comment">// 读入点云</span><br>    pcl::PCDReader reader;<br>    reader.<span class="hljs-built_in">read</span> (<span class="hljs-string">&quot;table_scene_lms400.pcd&quot;</span>, *cloud); <br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;PointCloud before filtering: &quot;</span> &lt;&lt; cloud-&gt;width * cloud-&gt;height  &lt;&lt; <span class="hljs-string">&quot; data points (&quot;</span> &lt;&lt; pcl::<span class="hljs-built_in">getFieldsList</span> (*cloud) &lt;&lt; <span class="hljs-string">&quot;).&quot;</span> &lt;&lt; std::endl;<br>    <br>    <span class="hljs-comment">// 过滤</span><br>    pcl::VoxelGrid&lt;pcl::PCLPointCloud2&gt; sor;<br>    sor.<span class="hljs-built_in">setInputCloud</span> (cloud); <span class="hljs-comment">// 输入点云</span><br>    sor.<span class="hljs-built_in">setLeafSize</span> (<span class="hljs-number">0.01f</span>, <span class="hljs-number">0.01f</span>, <span class="hljs-number">0.01f</span>); <span class="hljs-comment">// 设置体素大小</span><br>    sor.<span class="hljs-built_in">filter</span> (*cloud_filtered);<br><br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;PointCloud after filtering: &quot;</span> &lt;&lt; cloud_filtered-&gt;width * cloud_filtered-&gt;height &lt;&lt; <span class="hljs-string">&quot; data points (&quot;</span> &lt;&lt; pcl::<span class="hljs-built_in">getFieldsList</span> (*cloud_filtered) &lt;&lt; <span class="hljs-string">&quot;).&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>然而，对于大规模的点云（如点个数超过100000），就会导致格点数超过整型最大值，报错：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Leaf size <span class="hljs-keyword">is</span> too small <span class="hljs-keyword">for</span> the <span class="hljs-keyword">input</span> dataset. <span class="hljs-type">Integer</span> indices would overflow.<br></code></pre></td></tr></table></figure><p>此时可以采用八叉树结构，将整个点云分成有大小限制的若干个叶节点，对每个叶节点分别做体素过滤，再合起来</p><h3 id="octree体素过滤"><a href="#octree体素过滤" class="headerlink" title="octree体素过滤"></a>octree体素过滤</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 原大规模点云</span><br>pcl::PointCloud&lt;pcl::PointXYZI&gt;::<span class="hljs-function">Ptr <span class="hljs-title">cloud_in</span><span class="hljs-params">(<span class="hljs-keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZI&gt;())</span></span>;<br><br><span class="hljs-comment">// 输出的降采样点云</span><br>pcl::PointCloud&lt;pcl::PointXYZI&gt;::<span class="hljs-function">Ptr <span class="hljs-title">cloud_out</span><span class="hljs-params">(<span class="hljs-keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZI&gt;())</span></span>;<br><br>pcl::PointCloud&lt;pcl::PointXYZI&gt;::<span class="hljs-function">Ptr <span class="hljs-title">cloud_tmp</span><span class="hljs-params">(<span class="hljs-keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZI&gt;())</span></span>;<br>pcl::PointCloud&lt;pcl::PointXYZI&gt;::<span class="hljs-function">Ptr <span class="hljs-title">cloud_tmp_ds</span><span class="hljs-params">(<span class="hljs-keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZI&gt;())</span></span>;<br><br><span class="hljs-comment">// 同样的体素过滤器VoxelGrid</span><br><span class="hljs-type">static</span> <span class="hljs-type">float</span> kLeafSize = <span class="hljs-number">0.2</span>;<br>pcl::VoxelGrid&lt;pcl::PointXYZI&gt; filter_map;<br>filter_map.<span class="hljs-built_in">setLeafSize</span>(kLeafSize, kLeafSize, kLeafSize);<br><br><span class="hljs-comment">// 将点云存入octree,设置子区域大小为1250*leaf_size（1250^3&lt;2^31，这样点数不会超过整型范围）</span><br><br>cloud_out-&gt;<span class="hljs-built_in">clear</span>();<br>pcl::octree::OctreePointCloud&lt;pcl::PointXYZI&gt; octree&#123;<span class="hljs-number">1250</span> * kLeafSize&#125;;<br>octree.<span class="hljs-built_in">setInputCloud</span>(cloud_map);<br>octree.<span class="hljs-built_in">addPointsFromInputCloud</span>();<br><br><span class="hljs-comment">// 遍历每个区域降采样</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = octree.<span class="hljs-built_in">leaf_depth_begin</span>(); it != octree.<span class="hljs-built_in">leaf_depth_end</span>(); ++it) &#123;<br>  <span class="hljs-keyword">auto</span> ids = it.<span class="hljs-built_in">getLeafContainer</span>().<span class="hljs-built_in">getPointIndicesVector</span>();<br>  cloud_tmp-&gt;<span class="hljs-built_in">clear</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> id : ids) &#123;<br>    cloud_tmp-&gt;<span class="hljs-built_in">push_back</span>(octree.<span class="hljs-built_in">getInputCloud</span>()-&gt;points[id]);<br>  &#125;<br>  filter_map.<span class="hljs-built_in">setInputCloud</span>(cloud_tmp);<br>  filter_map.<span class="hljs-built_in">filter</span>(*cloud_tmp_ds);<br>  *cloud_out += *cloud_tmp_ds;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SLAM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2024秋招华为机试题目记录(2023.8.30)</title>
    <link href="/2023/08/31/2024%E7%A7%8B%E6%8B%9B%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/08/31/2024%E7%A7%8B%E6%8B%9B%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="第一题（100分）"><a href="#第一题（100分）" class="headerlink" title="第一题（100分）"></a>第一题（100分）</h3><p>设计一个自动计算打卡时间的程序。输入：员工一天多次进出公司的时间点。输出：总有效工作时间。</p><ul><li>如果离开公司在15分钟以内，不从总时长中扣除</li><li>12:00-14:00,18:00-19:30是午休和晚餐时间，不算工作时间</li></ul><p><strong>输入描述：</strong></p><p>第一行:员工当天进门禁的次数n。</p><p>第二行:员工当天进门禁的所有时间，以空格分隔。（24小时制，格式为xx:xx）</p><p>第三行:员工当天出门禁的次数m。</p><p>第四行:员工当天出门禁的所有时间，以空格分隔。</p><p>注: 0 &lt; n,m &lt; 100，不存在相同的出入门禁时间，也不存在连续的出门禁或入门禁的情况。</p><p><strong>输出描述：</strong><br>当日的工作时长。</p><p><strong>样例输入</strong>：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">5</span><br><span class="hljs-attribute">07</span>:<span class="hljs-number">50</span> <span class="hljs-number">08</span>:<span class="hljs-number">50</span> <span class="hljs-number">12</span>:<span class="hljs-number">30</span> <span class="hljs-number">13</span>:<span class="hljs-number">40</span> <span class="hljs-number">19</span>:<span class="hljs-number">50</span><br><span class="hljs-attribute">5</span><br><span class="hljs-attribute">08</span>:<span class="hljs-number">45</span> <span class="hljs-number">12</span>:<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">20</span> <span class="hljs-number">18</span>:<span class="hljs-number">30</span> <span class="hljs-number">20</span>:<span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">530<br></code></pre></td></tr></table></figure><p><strong>My answer:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> in,out;<br>    cin &gt;&gt; in;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">in_time</span><span class="hljs-params">(in)</span></span>;<br>    string str;<br>    <span class="hljs-type">int</span> time;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; in; i++)<br>    &#123;<br>        cin &gt;&gt; str;<br>        time = <span class="hljs-built_in">stoi</span>(str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)) * <span class="hljs-number">60</span> + <span class="hljs-built_in">stoi</span>(str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">3</span>));<br>        <span class="hljs-keyword">if</span>(time&gt;<span class="hljs-number">12</span>*<span class="hljs-number">60</span> &amp;&amp; time&lt;=<span class="hljs-number">14</span>*<span class="hljs-number">60</span>)time=<span class="hljs-number">14</span>*<span class="hljs-number">60</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(time&gt;<span class="hljs-number">18</span>*<span class="hljs-number">60</span> &amp;&amp; time&lt;=<span class="hljs-number">195</span>*<span class="hljs-number">6</span>)time=<span class="hljs-number">195</span>*<span class="hljs-number">6</span>;<br>        in_time[i] = time;<br>    &#125;<br>    cin &gt;&gt; out;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">out_time</span><span class="hljs-params">(out)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; out; i++)<br>    &#123;<br>        cin &gt;&gt; str;<br>        time = <span class="hljs-built_in">stoi</span>(str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)) * <span class="hljs-number">60</span> + <span class="hljs-built_in">stoi</span>(str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">3</span>));<br>        <span class="hljs-keyword">if</span>(time&gt;=<span class="hljs-number">12</span>*<span class="hljs-number">60</span> &amp;&amp; time&lt;<span class="hljs-number">14</span>*<span class="hljs-number">60</span>)time=<span class="hljs-number">12</span>*<span class="hljs-number">60</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(time&gt;=<span class="hljs-number">18</span>*<span class="hljs-number">60</span> &amp;&amp; time&lt;<span class="hljs-number">195</span>*<span class="hljs-number">6</span>)time=<span class="hljs-number">18</span>*<span class="hljs-number">60</span>;<br>        out_time[i] = time;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> time_sum = out_time[out<span class="hljs-number">-1</span>] - in_time[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span>(out_time[out<span class="hljs-number">-1</span>]&gt;=<span class="hljs-number">195</span>*<span class="hljs-number">6</span> &amp;&amp; in_time[<span class="hljs-number">0</span>]&lt;=<span class="hljs-number">18</span>*<span class="hljs-number">60</span>)time_sum -= <span class="hljs-number">90</span>;<br>    <span class="hljs-keyword">if</span>(out_time[out<span class="hljs-number">-1</span>]&gt;=<span class="hljs-number">14</span>*<span class="hljs-number">60</span> &amp;&amp; in_time[<span class="hljs-number">0</span>]&lt;=<span class="hljs-number">12</span>*<span class="hljs-number">60</span>)time_sum -= <span class="hljs-number">120</span>;<br>        <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; in; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> back = in_time[i];<br>        <span class="hljs-type">int</span> leave = out_time[i<span class="hljs-number">-1</span>];<br>        <span class="hljs-type">int</span> leave_time = back - leave;<br>        <span class="hljs-keyword">if</span>(leave_time &lt;= <span class="hljs-number">15</span>)<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(back&gt;=<span class="hljs-number">195</span>*<span class="hljs-number">6</span> &amp;&amp; leave&lt;=<span class="hljs-number">18</span>*<span class="hljs-number">60</span>)leave_time -= <span class="hljs-number">90</span>;<br>        <span class="hljs-keyword">if</span>(back&gt;=<span class="hljs-number">14</span>*<span class="hljs-number">60</span> &amp;&amp; leave&lt;=<span class="hljs-number">12</span>*<span class="hljs-number">60</span>)leave_time -= <span class="hljs-number">120</span>;<br>        <span class="hljs-keyword">if</span>(leave_time &gt; <span class="hljs-number">0</span>)<br>            time_sum -= leave_time;      <br>    &#125;<br>    <span class="hljs-keyword">if</span>(time_sum &lt;<span class="hljs-number">0</span>)<br>        time_sum = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; time_sum &lt;&lt;endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p><strong>思路：</strong><br>(1) 读入时间的时候，进入的时间如果在休息时间内，就设成休息时间的结束。如果离开时间在休息时间内，就设成休息时间的开始。<br>(2) 总时间首先是最后离开的时间减去一开始进入的时间。再根据起止时间的范围，判断是否减去午休和晚餐的时间。<br>(3) 再考虑中间每次离开，如果大于15分钟，就从总时长中减去</p><h3 id="第二题（200分）"><a href="#第二题（200分）" class="headerlink" title="第二题（200分）"></a>第二题（200分）</h3><p>已知一棵完全二叉树，满足每个结点的值是它的叶结点频率的最大值加最小值除以2减去它的父节点的值之和。给定叶节点的个数和频率，求这个完全二叉树。</p><p>如：</p><img src="/2023/08/31/2024%E7%A7%8B%E6%8B%9B%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/1.png" class="" title="fig:1"><p>输入节点数4，输入四个节点的频率。根节点的叶节点为4个节点，四个节点的最大值加最小值除以2，再减去其根节点（没有根节点），得到13。其他节点同理，可以看到计算完成后，每一个根节点到叶节点的值之和是该叶节点的频率。</p><p><strong>输入描述：</strong></p><p>第一行：叶节点个数。一定是2的n次。</p><p>第二行：每个叶节点的频率，0 &lt; x &lt; 1000000</p><p><strong>输出描述：</strong></p><p>二叉树的层序遍历，注意最后不能有空格</p><p><strong>样例输入：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">18 </span><span class="hljs-number">24</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">13 </span><span class="hljs-number">8</span> -<span class="hljs-number">10</span> -<span class="hljs-number">3</span> <span class="hljs-number">3</span> -<span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>My answer:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_max_min</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; leaf, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> num, <span class="hljs-type">int</span>&amp; max, <span class="hljs-type">int</span> &amp;min)</span></span><br><span class="hljs-function"></span>&#123;<br>    min = leaf[left];<br>    max = leaf[left];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = left+<span class="hljs-number">1</span>; i &lt; left+num; i++)<br>    &#123;<br>        min = min &lt; leaf[i] ? min : leaf[i];<br>        max = max &gt; leaf[i] ? max : leaf[i];<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leaf</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>, min = <span class="hljs-number">1000000</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin &gt;&gt; leaf[i];<br>    &#125;<br>    <span class="hljs-type">int</span> layers = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">log</span>(n)/<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>)) + <span class="hljs-number">1</span>;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; fathers, fathers_tmp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; layers; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> num = n / <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,i);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,i);j++)<br>        &#123;<br>            <span class="hljs-type">int</span> value;<br>            <span class="hljs-keyword">if</span>(i != layers - <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-type">int</span> min,max;<br>                <span class="hljs-built_in">get_max_min</span>(leaf, num*(j), num, max, min);<br>                value  = (max+min)/<span class="hljs-number">2</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                value = leaf[j];<br>            fathers_tmp.<span class="hljs-built_in">push_back</span>(value);<br>            <span class="hljs-keyword">if</span>(fathers.<span class="hljs-built_in">size</span>()!=<span class="hljs-number">0</span>) value -= fathers[j/<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span>(j==n<span class="hljs-number">-1</span>)cout &lt;&lt; value &lt;&lt; endl;<br>            <span class="hljs-keyword">else</span><br>                cout &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        fathers.<span class="hljs-built_in">assign</span>(fathers_tmp.<span class="hljs-built_in">begin</span>(),fathers_tmp.<span class="hljs-built_in">end</span>());<br>        fathers_tmp.<span class="hljs-built_in">clear</span>();<br>    &#125;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路：</strong><br>从根节点开始按层计算。对每个节点，确定节点对应的叶节点，找到最大值最小值。同时保存上一层所有节点的父节点值加上本节点的值之和。</p><h3 id="第三题（300分）"><a href="#第三题（300分）" class="headerlink" title="第三题（300分）"></a>第三题（300分）</h3><p>有n个任务，任务之间有依赖关系（只有做完任务A，才能做任务B），每个任务需要不同内存，在尽快完成所有任务的情况下需要的最小内存是多少</p><p><strong>输入描述：</strong></p><p>第一行：任务个数</p><p>第二行：每个任务占用内存量</p><p>第3~3+n行：任务之间的依赖关系</p><p><strong>输出描述：</strong></p><p>需要的最小内存</p><p><em>这题没做完，案例也没有记录下来。拓扑排序相关之前做的比较少，如果有时间需要刷一刷这类题。</em></p>]]></content>
    
    
    <categories>
      
      <category>2024秋招记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>c++多线程学习笔记-2</title>
    <link href="/2023/08/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/"/>
    <url>/2023/08/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/</url>
    
    <content type="html"><![CDATA[<p>单纯的mutex需要手动进行加锁和解锁，如果加锁解锁不匹配，程序就会出现bug无法运行。此外，因为抛出异常或return等操作可能导致没有解锁就退出的问题。更好的办法是采用”资源分配时初始化”(RAII)方法来加锁、解锁。此时主要会用到lock_guard和unique_lock两个类。</p><h3 id="std-lock-guard"><a href="#std-lock-guard" class="headerlink" title="std::lock_guard"></a>std::lock_guard</h3><ul><li>当构造函数被调用时，该互斥量会被自动锁定</li><li>当析构函数被调用时，该互斥量会自动解锁</li><li>lock_guard对象不能复制或移动，因此只能在局部作用域中使用</li></ul><p>例子如下，两个线程都对一个全局变量进行累加，如果不加锁线程就可能同时对a进行操作，产生矛盾。使用lock_guard，我们不需要手动解锁，在lock_guard被析构时自动解锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>std::mutex mtx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br>    &#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(mtx)</span></span>;<br>        a++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; a &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">20000</span><br></code></pre></td></tr></table></figure><p>从lock_guard的源码分析（除了构造函数和析构函数以外，没有其他函数）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Mutex</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">lock_guard</span><br>&#123;<span class="hljs-comment">// class with destructor that unlocks a mutex</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">using</span> mutex_type = _Mutex;<br><br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">lock_guard</span><span class="hljs-params">(_Mutex&amp; _Mtx)</span></span><br><span class="hljs-function">: _MyMutex(_Mtx)</span><br><span class="hljs-function">&#123;</span><span class="hljs-comment">// 构造函数中对mtx加锁</span><br>_MyMutex.<span class="hljs-built_in">lock</span>();<br>&#125;<br><br><span class="hljs-built_in">lock_guard</span>(_Mutex&amp; _Mtx, <span class="hljs-type">adopt_lock_t</span>)<br>: _MyMutex(_Mtx)<br>&#123;<span class="hljs-comment">// 当前mtx已获得变量所有权时，调用lock_guard需要加一个常数，此时不用再次加锁</span><br>&#125;<br><br>~<span class="hljs-built_in">lock_guard</span>() <span class="hljs-keyword">noexcept</span><br>&#123;<span class="hljs-comment">// 在析构函数中对mtx解锁</span><br>_MyMutex.<span class="hljs-built_in">unlock</span>();<br>&#125;<br><br>    <span class="hljs-comment">// 禁用拷贝构造和等于（不能复制和移动）</span><br><span class="hljs-built_in">lock_guard</span>(<span class="hljs-type">const</span> lock_guard&amp;) = <span class="hljs-keyword">delete</span>;<br>lock_guard&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> lock_guard&amp;) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-keyword">private</span>:<br>_Mutex&amp; _MyMutex;<br>&#125;;<br><br></code></pre></td></tr></table></figure><div class="note note-success">            <p>explicit: 构造类时不支持隐式转换。也就是必须是一个已被定义为_Mutex类的变量才能用于构造lock_guard</p>          </div><h3 id="std-unique-lock"><a href="#std-unique-lock" class="headerlink" title="std::unique_lock"></a>std::unique_lock</h3><p>相比lock_guard，unique_lock可以对互斥量做更丰富的操作，因此使用更加广泛，但同时占用的资源也会更多。</p><h4 id="操作一：自动加锁解锁"><a href="#操作一：自动加锁解锁" class="headerlink" title="操作一：自动加锁解锁"></a>操作一：自动加锁解锁</h4><p>用上述例子，将lock_guard换成unique_lock可以实现同样功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>std::mutex mtx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br>    &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(mtx)</span></span>;<br>        a++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; a &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="操作二：延迟锁定"><a href="#操作二：延迟锁定" class="headerlink" title="操作二：延迟锁定"></a>操作二：延迟锁定</h4><p>当调用函数时传入std::defer_lock，构造函数不会自动加锁，而由程序员在后续代码中决定什么时候加锁，加什么样的锁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(mtx,std::defer_lock)</span></span>;<br></code></pre></td></tr></table></figure><p>查看源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">unique_lock</span>&#123;<br>    <span class="hljs-function">xxx</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">unique_lock</span><span class="hljs-params">(_Mutex&amp; _Mtx, <span class="hljs-type">defer_lock_t</span>)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">: _Pmtx(_STD addressof(_Mtx)), _Owns(false)</span><br><span class="hljs-function">&#123;</span><span class="hljs-comment">// 构造函数什么都不做，没有加锁</span><br>&#125;<br><br>    xxx<br>&#125;<br></code></pre></td></tr></table></figure><p>之后可以进行手动加锁：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">lg.lock()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>查看源码：是调用mutex的lock函数</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sqf">  void <span class="hljs-built_in">lock</span>()<br>&#123;<span class="hljs-comment">// lock the mutex</span><br><span class="hljs-variable">_Validate</span>();<br><span class="hljs-variable">_Pmtx</span>-&gt;<span class="hljs-built_in">lock</span>();<br><span class="hljs-variable">_Owns</span> = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="操作三：尝试加锁并返回是否加锁成功-try-lock"><a href="#操作三：尝试加锁并返回是否加锁成功-try-lock" class="headerlink" title="操作三：尝试加锁并返回是否加锁成功-try_lock"></a>操作三：尝试加锁并返回是否加锁成功-try_lock</h4><p>try_lock尝试获得mutex所有权，如果可以就加锁返回true，否则返回false，程序继续往下运行。</p><p>如下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>std::mutex mtx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(mtx, std::defer_lock)</span></span>;<br>    <span class="hljs-keyword">if</span>(lg.<span class="hljs-built_in">try_lock</span>())&#123;<br>        a++;<br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">3</span>));<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        b++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>t1获得mtx所有权后，会对a加1，等待2s，此时t2尝试获取mtx所有权，但无法获取，返回false，执行b加1.</p><p>也可以写成这样：在构造函数中加入try_to_lock的参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(mtx, std::try_to_lock)</span></span>;<br>    <span class="hljs-keyword">if</span>(lock.<span class="hljs-built_in">owns_lock</span>())&#123;<br>        a++;<br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">3</span>));<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        b++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="操作四：在一段时间内尝试加锁-try-lock-for"><a href="#操作四：在一段时间内尝试加锁-try-lock-for" class="headerlink" title="操作四：在一段时间内尝试加锁-try_lock_for"></a>操作四：在一段时间内尝试加锁-try_lock_for</h4><p>try_lock_for尝试在一定时间内获得mutex所有权，如果可以就加锁返回true，否则返回false，程序继续往下运行。</p><p>如下面的例子：(此时mutex要选用timed_mutex)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>std::timed_mutex mtx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-function">std::unique_lock&lt;timed_mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(mtx, std::defer_lock)</span></span>;<br>    <span class="hljs-keyword">if</span>(lg.<span class="hljs-built_in">try_lock_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>)))&#123;<br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">2</span>));<br>        a++;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        b++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>t1获得mtx所有权后，会对a加1，等待2s，此时t2尝试在5s内获取mtx所有权。在等待过程中t1休眠完毕，释放mtx所有权，t2就可以加锁，再对a加1。最终a&#x3D;2,b&#x3D;0</p><h4 id="特性：所有权可以移动但是不能复制"><a href="#特性：所有权可以移动但是不能复制" class="headerlink" title="特性：所有权可以移动但是不能复制"></a>特性：所有权可以移动但是不能复制</h4><p>查看源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++">    <span class="hljs-built_in">unique_lock</span>(unique_lock&amp;&amp; _Other) <span class="hljs-keyword">noexcept</span><br>: _Pmtx(_Other._Pmtx), _Owns(_Other._Owns)<br>&#123;<span class="hljs-comment">// 可以移动另一个mutex的所有权</span><br>_Other._Pmtx = <span class="hljs-literal">nullptr</span>;<br>_Other._Owns = <span class="hljs-literal">false</span>;<br>&#125;<br><br>unique_lock&amp; <span class="hljs-keyword">operator</span>=(unique_lock&amp;&amp; _Other)<br>&#123;<span class="hljs-comment">// 等号可以用于移动另一个mutex的所有权</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != _STD <span class="hljs-built_in">addressof</span>(_Other))<br>&#123;<br><span class="hljs-keyword">if</span> (_Owns)<br>_Pmtx-&gt;<span class="hljs-built_in">unlock</span>();<br>_Pmtx = _Other._Pmtx;<br>_Owns = _Other._Owns;<br>_Other._Pmtx = <span class="hljs-literal">nullptr</span>;<br>_Other._Owns = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> (*<span class="hljs-keyword">this</span>);<br>&#125;<br><br>    <span class="hljs-built_in">unique_lock</span>(<span class="hljs-type">const</span> unique_lock&amp;) = <span class="hljs-keyword">delete</span>;<br>    unique_lock&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> unique_lock&amp;) = <span class="hljs-keyword">delete</span>;<br>```  <br><br>### <span class="hljs-built_in">call_once</span>()<br><br>使用场景：某些类是单例模式，在整个程序中只能创建一个实例，此时多线程调用可能有问题。<br><br>如下面的例子，该类使用了一个静态成员函数 <span class="hljs-built_in">getInstance</span>() 来获取单例实例，用了一个静态局部变量 instance 来存储单例实例。由于静态局部变量只会被初始化一次，因此该实现可以确保单例实例只会被创建一次。<br><br>```C++<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>         <span class="hljs-type">static</span> Singleton instance;<br>         <span class="hljs-keyword">return</span> instance;<br>    &#125;    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setData</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>         m_data = data;<br>    &#125;    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>         <span class="hljs-keyword">return</span> m_data;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125; <span class="hljs-comment">//构造函数为private</span><br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;    <span class="hljs-comment">// 禁用拷贝构造和等号</span><br>    <span class="hljs-type">int</span> m_data = <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>但如果多个线程同时调用 getInstance() 函数，可能会导致多个对象被创建，从而违反了单例模式的要求。并且可能会出现多个线程同时调用 setData() 函数来修改m_data，可能会导致数据不一致或不正确的结果。</p><p>此时可以用call_once函数，call_once函数将输入一个std::once_flag类型的变量，用于标记该函数是否已经被调用过。将该类改写为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>            std::<span class="hljs-built_in">call_once</span>(m_onceFlag, &amp;Singleton::init);<br>            <span class="hljs-keyword">return</span> *m_instance;<br>    &#125;    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setData</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>        m_data = data;<br>    &#125;    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;        <br>    <span class="hljs-keyword">return</span> m_data;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;    <br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        m_instance.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> Singleton);<br>    &#125;    <br>    <span class="hljs-type">static</span> std::unique_ptr&lt;Singleton&gt; m_instance;    <br>    <span class="hljs-type">static</span> std::once_flag m_onceFlag;    <br>    <span class="hljs-type">int</span> m_data = <span class="hljs-number">0</span>;<br>&#125;;<br><br>std::unique_ptr&lt;Singleton&gt; Singleton::m_instance;<br>std::once_flag Singleton::m_onceFlag;<br></code></pre></td></tr></table></figure><p>此时，我们创建了一个静态成员变量 m_onceFlag 来标记初始化是否已经完成。在 getInstance() 函数中，我们使用 std::call_once 来调用 init() 函数，仅当第一次调用时m_onceFlag有效，可以调用init()。后续再有线程运行到此处无法调用init()，直接返回该实例。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="http://www.seestudy.cn/?list_9/">陈子青C++公开课:C++11 跨平台多线程编程与线程池</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++多线程学习笔记-1</title>
    <link href="/2023/08/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
    <url>/2023/08/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>进程与线程：</p><p>进程是运行中的程序。</p><p>线程是进程中可并行的一个子程序，主要目的是提高程序运行效率。最大线程个数是CPU核数。</p>          </div><h3 id="Thread线程库的基本使用"><a href="#Thread线程库的基本使用" class="headerlink" title="Thread线程库的基本使用"></a>Thread线程库的基本使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printMessage</span><span class="hljs-params">(std::string msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; msg &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(printMessage, <span class="hljs-string">&quot;Hello thread!&quot;</span>)</span></span>;<br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li><p>定义一个线程：</p> <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-title">std::</span><span class="hljs-keyword">thread</span>(function_name, args)<br></code></pre></td></tr></table></figure></li><li><p>等待线程完成</p> <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">t.<span class="hljs-keyword">join</span>()<br></code></pre></td></tr></table></figure><p> 等待线程完成后主程序才往下运行。如果没有这一句，上面的线程在没有打印完msg时主程序已结束，就会报错。</p></li><li><p>分离线程</p> <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">t.detach<span class="hljs-comment">()</span><br></code></pre></td></tr></table></figure><p> 分离线程，让它在后台运行。往往用于多进程的情况。</p></li><li><p>joinable</p> <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">bool isJoin <span class="hljs-operator">=</span> t.joinable()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p> joinable()方法返回一个布尔值，如果线程可以被join()或detach()，则返回true，否则返回false。防止直接使用join报错。</p></li></ol><h4 id="变量未定义问题"><a href="#变量未定义问题" class="headerlink" title="变量未定义问题"></a>变量未定义问题</h4><p>传递的函数需要引用，指针类型变量时容易出现的线程没运行完，变量已被释放的问题。</p><ol><li><p>函数参数是引用</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span></span>&#123;<br>    x += <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(foo, std::ref(a))</span></span>;<br>    t.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; a &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> std::ref用于取某个变量的引用，但要保证在线程函数执行期间，变量 <code>a</code> 的生命周期是有效的。</p></li><li><p>函数参数是指针</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>* x)</span></span>&#123;<br>    std::cout &lt;&lt; *x &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> *ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(foo, ptr)</span></span>;<br>    <span class="hljs-comment">// delete ptr;</span><br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 如果在注释处释放指针，线程还没执行完，foo函数根据地址取到的就是一个未知的数。</p></li><li><p>解决方法：用智能指针</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>&#123;<br>        std::cout&lt;&lt; <span class="hljs-string">&quot;Hello!&quot;</span> &lt;&lt; std::endl; <br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::shared_ptr&lt;A&gt; a = std::make_shared&lt;A&gt;;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(&amp;A::foo, a)</span></span>;<br><br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 用智能指针来定义需要传递的指针参数，这样该参数就能在不需要的时候自动析构。</p></li><li><p>入口函数为类的私有函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// friend void thread_foo();</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>&#123;<br>        std::cout&lt;&lt; <span class="hljs-string">&quot;Hello!&quot;</span> &lt;&lt; std::endl; <br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::shared_ptr&lt;A&gt; a = std::make_shared&lt;A&gt;;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(&amp;A::foo, a)</span></span>;<br><br>    t.<span class="hljs-built_in">join</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">thread_foo</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果直接运行，会报错，因为函数thread_foo无法访问类的私由函数。但用注释那行，将该函数设为友元，则可以访问。</p></li></ol><h3 id="互斥量mutex"><a href="#互斥量mutex" class="headerlink" title="互斥量mutex"></a>互斥量mutex</h3><p>多个线程访问一个变量，且对变量进行修改，此时会出现函数竞争问题，导致函数运行结果不确定。因此需要用到互斥锁，使得每次只能有一个程序访问变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>std::mutex mtx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br>    &#123;<br>        mtx.<span class="hljs-built_in">lock</span>();<br>        a += <span class="hljs-number">1</span>;<br>        mtx.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; a &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>倘若不加互斥锁，可能导致多个线程对a操作，此时操作重叠就可能出现问题。加了互斥锁，每次只能有一个线程访问a，使得最终<code>a=20000</code></p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>如下面程序中的情况，线程<code>t1</code>运行<code>func1</code>，获取了<code>mtx1</code>的所有权，如果此时正好线程<code>t2</code>运行<code>func2</code>获得了<code>mtx2</code>的所有权。那就会出现<code>t1</code>,<code>t2</code>都在等对方，都无法运行的死锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br>std::mutex mtx1, mtx2;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123;  <br>    mtx1.<span class="hljs-built_in">lock</span>();  <br>    mtx2.<span class="hljs-built_in">lock</span>();                  <br>    mtx2.<span class="hljs-built_in">unlock</span>();<br>    mtx1.<span class="hljs-built_in">unlock</span>();    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123;    <br>    mtx2.<span class="hljs-built_in">lock</span>();<br>    mtx1.<span class="hljs-built_in">lock</span>();        <br>    mtx1.<span class="hljs-built_in">unlock</span>();    <br>    mtx2.<span class="hljs-built_in">unlock</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func1)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func2)</span></span>;    <br>    t1.<span class="hljs-built_in">join</span>();    <br>    t2.<span class="hljs-built_in">join</span>();    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.seestudy.cn/?list_9/">http://www.seestudy.cn/?list_9/</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pyside6安装后报错及解决方法</title>
    <link href="/2023/08/24/pyside6%E5%AE%89%E8%A3%85%E5%90%8E%E4%BD%BF%E7%94%A8%E6%8A%A5%E9%94%99/"/>
    <url>/2023/08/24/pyside6%E5%AE%89%E8%A3%85%E5%90%8E%E4%BD%BF%E7%94%A8%E6%8A%A5%E9%94%99/</url>
    
    <content type="html"><![CDATA[<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>ubuntu 20.04</p><h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><p>通过pip安装完后pyside6，使用时报错</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">qt.qpa.plugin: Could <span class="hljs-keyword">not</span> <span class="hljs-built_in">load</span> <span class="hljs-keyword">the</span> Qt <span class="hljs-built_in">platform</span> plugin <span class="hljs-string">&quot;xcb&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;&quot;</span> even though <span class="hljs-keyword">it</span> was found.<br>This application failed <span class="hljs-built_in">to</span> <span class="hljs-built_in">start</span> because no Qt <span class="hljs-built_in">platform</span> plugin could be initialized. Reinstalling <span class="hljs-keyword">the</span> application may fix this problem.<br><br>Available <span class="hljs-built_in">platform</span> plugins are: offscreen, wayland-egl, linuxfb, vkkhrdisplay, minimalegl, minimal, wayland, xcb, eglfs, vnc.<br><br>Aborted (core dumped)<br></code></pre></td></tr></table></figure><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>参考<a href="https://blog.csdn.net/LOVEmy134611/article/details/107212845">https://blog.csdn.net/LOVEmy134611/article/details/107212845</a></p><ol><li><p>修改脚本文件<code>~/.bashrc</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">vim ~/.bashrc</span><br></code></pre></td></tr></table></figure></li><li><p>在最后加入</p> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">QT_DEBUG_PLUGINS</span>=1<br></code></pre></td></tr></table></figure></li><li><p>保存退出，使配置文件生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">source</span> ~/.bashrc</span><br></code></pre></td></tr></table></figure></li><li><p>再次调用pyside6函数，查看详细报错输出，在最下方找到</p> <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">xxx<br>libxcb-cursor.<span class="hljs-keyword">so</span>.0: cannot <span class="hljs-keyword">open</span> shared object <span class="hljs-keyword">file</span>: <span class="hljs-keyword">No</span> such <span class="hljs-keyword">file</span> or directory<br>xxx<br></code></pre></td></tr></table></figure></li><li><p>安装库libxcb-cursor0后，能够正常运行</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> libxcb-cursor0<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2024秋招美团笔试题目记录(2023.8.12, 2023.8.19)</title>
    <link href="/2023/08/12/2024%E7%A7%8B%E6%8B%9B%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95(2023.8.12,2023.8.19)/"/>
    <url>/2023/08/12/2024%E7%A7%8B%E6%8B%9B%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95(2023.8.12,2023.8.19)/</url>
    
    <content type="html"><![CDATA[<h2 id="8-12"><a href="#8-12" class="headerlink" title="8.12"></a>8.12</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p><strong>题目描述：</strong></p><p>给定一个排列$A &#x3D; [a_1, a_2, …, a_n]$，数字不重复。给定两个数x, y, 判断x, y 在A中是否相邻，输出yes or no.</p><p><strong>例子：</strong><br>输入第一行是A的长度，第二行A，第三行x y</p><p>Input: </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">No</span><br></code></pre></td></tr></table></figure><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p><a href="https://leetcode.cn/problems/distance-between-bus-stops/">Leetcode 1184. 公交站间的距离</a></p><h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><p><strong>题目描述：</strong></p><p>给一个矩阵$A_{mxn}$，代表一块蛋糕，每个位置的值$A_{i,j}$代表这部分蛋糕的美味度，横着或竖着切一刀，使得两部分蛋糕美味度之差尽可能小。输出最小的差。</p><p><strong>例子：</strong><br>输入第一行是m，n，第二行开始是A</p><p>Input: </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span> <br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">0<br></code></pre></td></tr></table></figure><h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><p><strong>题目描述：</strong><br>给定一棵树，开始时所有节点为白色。如果两个相连的节点的值相乘是完全平方数，且它们都是白色，可以将这两个节点染成红色。输出最多能染色几个节点。</p><p><strong>例子：</strong><br>输入第一行是节点数n，第二行是各个节点的值，接下来n-1行是节点的边</p><p>Input: </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">3</span> <span class="hljs-number">12</span> <br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure><p>My answer:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">issquare</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">sqrt</span>(n));<br>    <span class="hljs-keyword">if</span>(x * x == n)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Solution</span>(<span class="hljs-type">int</span> n)<br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>            edge.<span class="hljs-built_in">resize</span>(n, tmp);<br>            match.<span class="hljs-built_in">resize</span>(n, <span class="hljs-number">-1</span>);<br>            num = n;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">        </span>&#123;<br>            edge[i].<span class="hljs-built_in">push_back</span>(j);<br>            edge[j].<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search_max</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (match[i] != <span class="hljs-number">-1</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j:edge[i])<br>            &#123;<br>                <span class="hljs-keyword">if</span> (match[j] == <span class="hljs-number">-1</span> || <span class="hljs-built_in">search</span>(match[j]))<br>                &#123;<br>                    match[i] = j;<br>                    match[j] = i;<br>                    sum++;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : edge[i])<br>        &#123;<br>            <span class="hljs-keyword">if</span>(j == match[i])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(match[j] == <span class="hljs-number">-1</span> || <span class="hljs-built_in">search</span>(match[j]))<br>            &#123;<br>                match[i] = j;<br>                match[j] = i;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> num;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; edge;<br>        vector&lt;<span class="hljs-type">int</span>&gt; match;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n) &#123; <span class="hljs-comment">// 注意 while 处理多个 case</span><br>        <span class="hljs-function">Solution <span class="hljs-title">s</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">value</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            cin &gt;&gt; value[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> x, y;<br>            cin &gt;&gt; x &gt;&gt; y;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">issquare</span>(value[x<span class="hljs-number">-1</span>] * value[y<span class="hljs-number">-1</span>]))&#123;<br>                s.<span class="hljs-built_in">add_edge</span>(x - <span class="hljs-number">1</span>, y - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;        <br>        cout &lt;&lt; s.<span class="hljs-built_in">search_max</span>() * <span class="hljs-number">2</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-19"><a href="#8-19" class="headerlink" title="8.19"></a>8.19</h2><h3 id="第一题-1"><a href="#第一题-1" class="headerlink" title="第一题"></a>第一题</h3><p><strong>题目描述：</strong></p><p>给定一个整数x，一个上限m，当x超过上限m时从1开始重新计数（就是取余）</p><p><strong>例子：</strong></p><p>输入第一个数x，第二个m</p><p>Input: </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>2<br>4<br>2<br></code></pre></td></tr></table></figure><h3 id="第二题-1"><a href="#第二题-1" class="headerlink" title="第二题"></a>第二题</h3><p>输入一个整数数组${a_i}$，总和$sum&#x3D;a_1 + a_2 + … + a_n$，可以将其中一个加号换成乘号，也可以不换。求可能的sum的最大值</p><p><strong>例子：</strong></p><p>第一行是数组个数</p><p>第二行是数组元素</p><p>Input: </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">24<br></code></pre></td></tr></table></figure><p>1 + 2 + 4 * 5 + 1 &#x3D; 24</p><p>可以枚举乘号的位置，只需要注意$a_i$变量类型设为long long int</p><h3 id="第三题-1"><a href="#第三题-1" class="headerlink" title="第三题"></a>第三题</h3><p><strong>题目描述：</strong></p><p>对于一个只含0，1的字符串，对其某一位取反定义为操作一次，对一个字符串操作最少次数使其相邻两位不同，这个最少次数为字符串的权值。现给定一个字符串，求其所有字符串的权值之和。</p><p><strong>例子：</strong></p><p>Input: </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">10001<br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">8<br></code></pre></td></tr></table></figure><p>长度为2的子串：两个00，每个权重为1<br>长度为3的子串：3个子串，每个权重为1<br>长度为4的子串：2个子串，每个权重为1<br>长度为5的子串：1个，权重为1<br>总共 2 + 3 + 2 + 1 &#x3D; 8</p><p>My answer:<br>假设对长度为len,结束位置为i的子字符串，使其变为相邻两位不同且最后一位为0的最小变换次数为$a_0[len][i]$,最后一位为1的最小变换次数为$a_1[len][i]$。则递推公式为</p><p>若s[i] &#x3D; 0：</p><p>$$a_0[len][i] &#x3D; min(a_1[len - 1][i-1], len - 1)$$<br>$$a_1[len][i] &#x3D; min(a_0[len - 1][i-1], len)$$</p><p>s[i] &#x3D; 1同理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; s) &#123; <span class="hljs-comment">// 注意 while 处理多个 case</span><br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a0</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">a0_tmp</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a1</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">a1_tmp</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;0&#x27;</span>)<br>                a1[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                a0[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">2</span>; l &lt;= n; l++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>; i &lt; n; i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;0&#x27;</span>)<br>                &#123;<br>                    a0_tmp[i] = <span class="hljs-built_in">min</span>(a1[i<span class="hljs-number">-1</span>], l - <span class="hljs-number">1</span>);<br>                    a1_tmp[i] = <span class="hljs-built_in">min</span>(a0[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>, l);<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    a1_tmp[i] = <span class="hljs-built_in">min</span>(a0[i<span class="hljs-number">-1</span>], l - <span class="hljs-number">1</span>);<br>                    a0_tmp[i] = <span class="hljs-built_in">min</span>(a1[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>, l);<br>                &#125;<br>                sum += <span class="hljs-built_in">min</span>(a0_tmp[i],a1_tmp[i]);<br>            &#125;<br>            a0.<span class="hljs-built_in">swap</span>(a0_tmp);<br>            a1.<span class="hljs-built_in">swap</span>(a1_tmp);<br>        &#125;<br>        cout &lt;&lt; sum &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第四题-1"><a href="#第四题-1" class="headerlink" title="第四题"></a>第四题</h3><p><strong>题目描述：</strong><br>给定n个正数，一次操作可以对一个数加1，一个数减1. 问使其众数出现次数最多的最少操作数。</p><p><strong>例子：</strong></p><p>第一行是n</p><p>第二行是n个数</p><p>Input: </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span> <br><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>0<br></code></pre></td></tr></table></figure><p>这题没做出来，只想到</p><ul><li><p>如果$a_i$的总和sum能整除n，那最小次数就是 $\frac{1}{2}\sum |a_i - \frac{sum}{n}|$</p></li><li><p>如果不整除，众数个数已等于n-1，答案就是0</p></li><li><p>其他情况：<br>n个数，将其中n-1个变为值v，要次数最少那剩余的一个一定是最大值或最小值。应该要枚举v的可能取值？</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>2024秋招记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/08/10/hello-world/"/>
    <url>/2023/08/10/hello-world/</url>
    
    <content type="html"><![CDATA[<h2 id="写博客的初衷"><a href="#写博客的初衷" class="headerlink" title="写博客的初衷"></a>写博客的初衷</h2><p>有一个毛病困扰了我很久，也是近几年阻碍我向前走的主要原因———我消极的完美主义。</p><p>追溯它的源头，大概是我从小在与世界交互时，收到一些负反馈（比如难以建立良好的人际关系，感觉到他人的疏远，排斥，不喜），我没有勇敢地去面对问题，而是更封闭自己，开始在虚假的幻想中获得安慰。看那些虚无缥缈的小说，假设自己是一个完美的被所有人爱的主角，每晚在这样幻想中沉沉睡去。我变得逃避现实，不敢面对问题；我追求一个完美的虚假的形象；我极度渴望得到他人的认可与爱。</p><p>这些病态的心理导致了我严重的拖延症，行动力差，自我封闭。我在工作时经常陷入无关紧要的细节，在多人场合中保持沉默，甚至连朋友圈都不敢发。我得想办法解决或者改善这个毛病。</p><p>我尝试通过看书找到药方，或者用道理说服自己。从心理上来说，我要改变的底层认知是：接受不完美的自己；意识到微小的进步有巨大的意义。但从小扎根在心底的认知似乎很难改变。我想应该直接从行动出发，或许写博客是一个很好的治愈方法。</p><p>在博客中尽量把我真实的所思所想，我的学习过程写出来，一段粗糙的读书笔记也好，一个简单的技术问题总结也好，尽管不完美也可以直接发出来，被素不相识的人们看到。浅薄无知，笨拙粗糙都没有关系，在一点点的进步中，或许我也会得到肯定和鼓励，而这将带给我莫大的欢喜。</p><h2 id="关于西西弗斯的石头"><a href="#关于西西弗斯的石头" class="headerlink" title="关于西西弗斯的石头"></a>关于西西弗斯的石头</h2><p>西西弗斯的神话里，他绑架了死神，让世间没有死亡，因此受到惩罚，要将一块巨石推上山顶，石头快到山顶就滚落，西西弗斯因此永无止境地重复这样毫无意义的事。</p><p>在加缪对这个故事的解释里，人生就和推石块一样，一样的荒谬，一样的无意义。但当西西弗斯去在意脚下的泥土，去观察巨石的颗粒，当他勇敢无畏地，坚定地选择一次一次推上石块，与虚无进行抗争时，他就为自己创造了意义。我读到这个故事时深为触动，后来看了一些对存在主义哲学的介绍，这些观念塑造了我基础的人生观：</p><p><strong>人生没有既定的意义，需要自己去赋予。但存在本身是有意义的，只有存在才能观察，才能感受。</strong> 因此这个博客也以此为名，这是我的石头，是我认为或许没意义但是要做的事，而我将在这个过程去体验，去观察，去感受。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
