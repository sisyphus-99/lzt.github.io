<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>pyside6应用过程中的问题记录</title>
    <link href="/2023/09/19/pyside6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/09/19/pyside6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>近期在做的任务要把交通路网结构用PySide6可视化，并添加一些选择车道，拖拽车辆之类的交互操作。以下是在应用过程中出现的一些问题和解决方案。</p><h3 id="问题1：qgraphicsview画polyline"><a href="#问题1：qgraphicsview画polyline" class="headerlink" title="问题1：qgraphicsview画polyline"></a>问题1：qgraphicsview画polyline</h3><p>由于希望界面上的部件都可以交互（点击，拖拽），因此我尝试在<code>QGrahicsView</code>类里画，但发现<code>QGraphicsScene</code>没有可直接调用的画polyline的函数，可行的方法是先画出QPainterPath，再用QGraphicsPath。如下面的程序，drawPolyline函数可输入2D points, color, width，画出这些点的折线段。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainWidget</span>(QtWidgets.QGraphicsView)<br>&#123;<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.initUI()<br>        self.scaleFactor = <span class="hljs-number">1</span><br>        self.resize(<span class="hljs-number">800</span>, <span class="hljs-number">800</span>) <br><br>        self.scene_map = QtWidgets.QGraphicsScene()<br>        self.scene_map.setSceneRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">700</span>, <span class="hljs-number">700</span>)<br>        self.scene_map.setBackgroundBrush(Qt.white)<br>        self.setScene(self.scene_map)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">drawPolyline</span>(<span class="hljs-params">self, points:<span class="hljs-built_in">list</span>[<span class="hljs-built_in">tuple</span>], color:QtGui.QColor, width:<span class="hljs-built_in">int</span> = <span class="hljs-number">1.0</span></span>):<br>        points = [QPointF(x,y) <span class="hljs-keyword">for</span> x,y <span class="hljs-keyword">in</span> points]<br>        path = QtGui.QPainterPath()<br>        polygon = QtGui.QPolygonF(points)<br>        path.addPolygon(polygon)<br>        <br>        pen = QtGui.QPen(color)<br>        pen.setWidth(width)<br>        new_item = QtWidgets.QGraphicsPathItem(path, <span class="hljs-literal">None</span>)<br>        new_item.setPath(path)<br>        new_item.setPen(pen)<br>        self.scene_map.addItem(new_item)<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="问题2：画出来的polyline不够平滑，有锯齿"><a href="#问题2：画出来的polyline不够平滑，有锯齿" class="headerlink" title="问题2：画出来的polyline不够平滑，有锯齿"></a>问题2：画出来的polyline不够平滑，有锯齿</h3><p>用上述方式画出的图如下图左图所示：斜线会有锯齿，只有完全水平或竖直或45度的线才是粗细均匀的。</p><img src="/2023/09/19/pyside6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/1.png" class="" title="fig:1"><p>为了平滑线段，可以给<code>QGraphicsview</code>设置渲染的参数<code>setRenderHint</code>为antialiasing（抗锯齿）。在<code>__init__</code>函数里加入下面一行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.setRenderHint(QtGui.QPainter.Antialiasing, <span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>得到的结果如上面右图所示，可以看到没有锯齿了。</p><h3 id="问题3：拖拽时view无法超过scene的大小"><a href="#问题3：拖拽时view无法超过scene的大小" class="headerlink" title="问题3：拖拽时view无法超过scene的大小"></a>问题3：拖拽时view无法超过scene的大小</h3><p>设置滚轮放大缩小功能需要重写wheelEvent函数，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">wheelEvent</span>(<span class="hljs-params">self, event: QtGui.QWheelEvent</span>) -&amp;gt; <span class="hljs-literal">None</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.scene().items()) == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span><br><br>    curPoint = event.position()<br>    scenePos = self.mapToScene(QPoint(curPoint.x(), curPoint.y()))<br><br>    viewWidth = self.viewport().width()<br>    viewHeight = self.viewport().height()<br><br>    hScale = curPoint.x() / viewWidth<br>    vScale = curPoint.y() / viewHeight<br><br>    wheelDeltaValue = event.angleDelta().y()<br>    self.scaleFactor = self.transform().m11()<br>    <span class="hljs-keyword">if</span> (self.scaleFactor &amp;lt; <span class="hljs-number">0.05</span> <span class="hljs-keyword">and</span> wheelDeltaValue&amp;lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">or</span> (self.scaleFactor&amp;gt;<span class="hljs-number">50</span> <span class="hljs-keyword">and</span> wheelDeltaValue&amp;gt;<span class="hljs-number">0</span>):<br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">if</span> wheelDeltaValue &amp;gt; <span class="hljs-number">0</span>:<br>        self.scale(<span class="hljs-number">1.1</span>, <span class="hljs-number">1.1</span>)<br>    <span class="hljs-keyword">else</span>:<br>        self.scale(<span class="hljs-number">1.0</span>/<span class="hljs-number">1.1</span>, <span class="hljs-number">1.0</span>/<span class="hljs-number">1.1</span>)<br>    <br>    viewPoint = self.transform().<span class="hljs-built_in">map</span>(scenePos)<br>    self.horizontalScrollBar().setValue(<span class="hljs-built_in">int</span>(viewPoint.x() - viewWidth * hScale ))<br>    self.verticalScrollBar().setValue(<span class="hljs-built_in">int</span>(viewPoint.y() - viewHeight * vScale ))<br><br>    self.update()<br></code></pre></td></tr></table></figure><p>设置鼠标拖拽功能只需要给QGraphicsView设置setDragMode，在window类初始化时加入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)<br></code></pre></td></tr></table></figure><p>但在显示底图时由于图比较大，我并不想一开始显示全部，而只是显示一部分，如下图（1）。此时我的拖拽功能只在相比原始scene放大时才有用（在图（2）时可以拖拽）。当地图缩小后尽管还未显示地图全貌，但无法拖动（图（3）无法拖动）。</p><img src="/2023/09/19/pyside6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/2.png" class="" title="fig:2"><p>参考这个回答：<a href="https://stackoverflow.com/questions/55007339/allow-qgraphicsview-to-move-outside-scene">https://stackoverflow.com/questions/55007339/allow-qgraphicsview-to-move-outside-scene</a></p><p>一个简单粗暴的解决方法是给scene设置足够大的初始大小。在我的例子中我将大小改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.scene_map.setSceneRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">2000</span>)<br></code></pre></td></tr></table></figure><p>这样就可以在上图（3）仍然可以拖动。不过修改scene_map的大小后要注意原本点的位置的按照scene_map的大小改变。由于<code>QGraphicsScene</code>默认是中心和<code>QGraphicsView</code>对齐的，如scene_map大小设为(2000,2000)，那么此时scene中心点的坐标(1000,1000)会显示在view的中心。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PCL对大规模点云进行体素降采样</title>
    <link href="/2023/09/14/pcl%E5%A4%A7%E8%A7%84%E6%A8%A1%E7%82%B9%E4%BA%91%E9%99%8D%E9%87%87%E6%A0%B7/"/>
    <url>/2023/09/14/pcl%E5%A4%A7%E8%A7%84%E6%A8%A1%E7%82%B9%E4%BA%91%E9%99%8D%E9%87%87%E6%A0%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="普通体素降采样"><a href="#普通体素降采样" class="headerlink" title="普通体素降采样"></a>普通体素降采样</h3><p>直接调用voxel_grid库，参考<a href="https://pcl.readthedocs.io/projects/tutorials/en/latest/voxel_grid.html">官方教程</a>，只需要设置体素的大小<code>setLeafSize(x, y, z)</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pcl/io/pcd_io.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pcl/point_types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pcl/filters/voxel_grid.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    pcl::<span class="hljs-function">PCLPointCloud2::Ptr <span class="hljs-title">cloud</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> pcl::PCLPointCloud2 ())</span></span>;<br>    pcl::<span class="hljs-function">PCLPointCloud2::Ptr <span class="hljs-title">cloud_filtered</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> pcl::PCLPointCloud2 ())</span></span>;<br><br>    <span class="hljs-comment">// 读入点云</span><br>    pcl::PCDReader reader;<br>    reader.<span class="hljs-built_in">read</span> (<span class="hljs-string">&quot;table_scene_lms400.pcd&quot;</span>, *cloud); <br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;PointCloud before filtering: &quot;</span> &lt;&lt; cloud-&gt;width * cloud-&gt;height  &lt;&lt; <span class="hljs-string">&quot; data points (&quot;</span> &lt;&lt; pcl::<span class="hljs-built_in">getFieldsList</span> (*cloud) &lt;&lt; <span class="hljs-string">&quot;).&quot;</span> &lt;&lt; std::endl;<br>    <br>    <span class="hljs-comment">// 过滤</span><br>    pcl::VoxelGrid&lt;pcl::PCLPointCloud2&gt; sor;<br>    sor.<span class="hljs-built_in">setInputCloud</span> (cloud); <span class="hljs-comment">// 输入点云</span><br>    sor.<span class="hljs-built_in">setLeafSize</span> (<span class="hljs-number">0.01f</span>, <span class="hljs-number">0.01f</span>, <span class="hljs-number">0.01f</span>); <span class="hljs-comment">// 设置体素大小</span><br>    sor.<span class="hljs-built_in">filter</span> (*cloud_filtered);<br><br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;PointCloud after filtering: &quot;</span> &lt;&lt; cloud_filtered-&gt;width * cloud_filtered-&gt;height &lt;&lt; <span class="hljs-string">&quot; data points (&quot;</span> &lt;&lt; pcl::<span class="hljs-built_in">getFieldsList</span> (*cloud_filtered) &lt;&lt; <span class="hljs-string">&quot;).&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>然而，对于大规模的点云（如点个数超过100000），就会导致格点数超过整型最大值，报错：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Leaf size <span class="hljs-keyword">is</span> too small <span class="hljs-keyword">for</span> the <span class="hljs-keyword">input</span> dataset. <span class="hljs-type">Integer</span> indices would overflow.<br></code></pre></td></tr></table></figure><p>此时可以采用八叉树结构，将整个点云分成有大小限制的若干个叶节点，对每个叶节点分别做体素过滤，再合起来</p><h3 id="octree体素过滤"><a href="#octree体素过滤" class="headerlink" title="octree体素过滤"></a>octree体素过滤</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 原大规模点云</span><br>pcl::PointCloud&lt;pcl::PointXYZI&gt;::<span class="hljs-function">Ptr <span class="hljs-title">cloud_in</span><span class="hljs-params">(<span class="hljs-keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZI&gt;())</span></span>;<br><br><span class="hljs-comment">// 输出的降采样点云</span><br>pcl::PointCloud&lt;pcl::PointXYZI&gt;::<span class="hljs-function">Ptr <span class="hljs-title">cloud_out</span><span class="hljs-params">(<span class="hljs-keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZI&gt;())</span></span>;<br><br>pcl::PointCloud&lt;pcl::PointXYZI&gt;::<span class="hljs-function">Ptr <span class="hljs-title">cloud_tmp</span><span class="hljs-params">(<span class="hljs-keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZI&gt;())</span></span>;<br>pcl::PointCloud&lt;pcl::PointXYZI&gt;::<span class="hljs-function">Ptr <span class="hljs-title">cloud_tmp_ds</span><span class="hljs-params">(<span class="hljs-keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZI&gt;())</span></span>;<br><br><span class="hljs-comment">// 同样的体素过滤器VoxelGrid</span><br><span class="hljs-type">static</span> <span class="hljs-type">float</span> kLeafSize = <span class="hljs-number">0.2</span>;<br>pcl::VoxelGrid&lt;pcl::PointXYZI&gt; filter_map;<br>filter_map.<span class="hljs-built_in">setLeafSize</span>(kLeafSize, kLeafSize, kLeafSize);<br><br><span class="hljs-comment">// 将点云存入octree,设置子区域大小为1250*leaf_size（1250^3&lt;2^31，这样点数不会超过整型范围）</span><br><br>cloud_out-&gt;<span class="hljs-built_in">clear</span>();<br>pcl::octree::OctreePointCloud&lt;pcl::PointXYZI&gt; octree&#123;<span class="hljs-number">1250</span> * kLeafSize&#125;;<br>octree.<span class="hljs-built_in">setInputCloud</span>(cloud_map);<br>octree.<span class="hljs-built_in">addPointsFromInputCloud</span>();<br><br><span class="hljs-comment">// 遍历每个区域降采样</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = octree.<span class="hljs-built_in">leaf_depth_begin</span>(); it != octree.<span class="hljs-built_in">leaf_depth_end</span>(); ++it) &#123;<br>  <span class="hljs-keyword">auto</span> ids = it.<span class="hljs-built_in">getLeafContainer</span>().<span class="hljs-built_in">getPointIndicesVector</span>();<br>  cloud_tmp-&gt;<span class="hljs-built_in">clear</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> id : ids) &#123;<br>    cloud_tmp-&gt;<span class="hljs-built_in">push_back</span>(octree.<span class="hljs-built_in">getInputCloud</span>()-&gt;points[id]);<br>  &#125;<br>  filter_map.<span class="hljs-built_in">setInputCloud</span>(cloud_tmp);<br>  filter_map.<span class="hljs-built_in">filter</span>(*cloud_tmp_ds);<br>  *cloud_out += *cloud_tmp_ds;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SLAM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2024秋招华为机试题目记录(2023.8.30)</title>
    <link href="/2023/08/31/2024%E7%A7%8B%E6%8B%9B%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/08/31/2024%E7%A7%8B%E6%8B%9B%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="第一题（100分）"><a href="#第一题（100分）" class="headerlink" title="第一题（100分）"></a>第一题（100分）</h3><p>设计一个自动计算打卡时间的程序。输入：员工一天多次进出公司的时间点。输出：总有效工作时间。</p><ul><li>如果离开公司在15分钟以内，不从总时长中扣除</li><li>12:00-14:00,18:00-19:30是午休和晚餐时间，不算工作时间</li></ul><p><strong>输入描述：</strong></p><p>第一行:员工当天进门禁的次数n。</p><p>第二行:员工当天进门禁的所有时间，以空格分隔。（24小时制，格式为xx:xx）</p><p>第三行:员工当天出门禁的次数m。</p><p>第四行:员工当天出门禁的所有时间，以空格分隔。</p><p>注: 0 &lt; n,m &lt; 100，不存在相同的出入门禁时间，也不存在连续的出门禁或入门禁的情况。</p><p><strong>输出描述：</strong><br>当日的工作时长。</p><p><strong>样例输入</strong>：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">5</span><br><span class="hljs-attribute">07</span>:<span class="hljs-number">50</span> <span class="hljs-number">08</span>:<span class="hljs-number">50</span> <span class="hljs-number">12</span>:<span class="hljs-number">30</span> <span class="hljs-number">13</span>:<span class="hljs-number">40</span> <span class="hljs-number">19</span>:<span class="hljs-number">50</span><br><span class="hljs-attribute">5</span><br><span class="hljs-attribute">08</span>:<span class="hljs-number">45</span> <span class="hljs-number">12</span>:<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">20</span> <span class="hljs-number">18</span>:<span class="hljs-number">30</span> <span class="hljs-number">20</span>:<span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">530<br></code></pre></td></tr></table></figure><p><strong>My answer:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> in,out;<br>    cin &gt;&gt; in;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">in_time</span><span class="hljs-params">(in)</span></span>;<br>    string str;<br>    <span class="hljs-type">int</span> time;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; in; i++)<br>    &#123;<br>        cin &gt;&gt; str;<br>        time = <span class="hljs-built_in">stoi</span>(str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)) * <span class="hljs-number">60</span> + <span class="hljs-built_in">stoi</span>(str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">3</span>));<br>        <span class="hljs-keyword">if</span>(time&gt;<span class="hljs-number">12</span>*<span class="hljs-number">60</span> &amp;&amp; time&lt;=<span class="hljs-number">14</span>*<span class="hljs-number">60</span>)time=<span class="hljs-number">14</span>*<span class="hljs-number">60</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(time&gt;<span class="hljs-number">18</span>*<span class="hljs-number">60</span> &amp;&amp; time&lt;=<span class="hljs-number">195</span>*<span class="hljs-number">6</span>)time=<span class="hljs-number">195</span>*<span class="hljs-number">6</span>;<br>        in_time[i] = time;<br>    &#125;<br>    cin &gt;&gt; out;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">out_time</span><span class="hljs-params">(out)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; out; i++)<br>    &#123;<br>        cin &gt;&gt; str;<br>        time = <span class="hljs-built_in">stoi</span>(str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)) * <span class="hljs-number">60</span> + <span class="hljs-built_in">stoi</span>(str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">3</span>));<br>        <span class="hljs-keyword">if</span>(time&gt;=<span class="hljs-number">12</span>*<span class="hljs-number">60</span> &amp;&amp; time&lt;<span class="hljs-number">14</span>*<span class="hljs-number">60</span>)time=<span class="hljs-number">12</span>*<span class="hljs-number">60</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(time&gt;=<span class="hljs-number">18</span>*<span class="hljs-number">60</span> &amp;&amp; time&lt;<span class="hljs-number">195</span>*<span class="hljs-number">6</span>)time=<span class="hljs-number">18</span>*<span class="hljs-number">60</span>;<br>        out_time[i] = time;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> time_sum = out_time[out<span class="hljs-number">-1</span>] - in_time[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span>(out_time[out<span class="hljs-number">-1</span>]&gt;=<span class="hljs-number">195</span>*<span class="hljs-number">6</span> &amp;&amp; in_time[<span class="hljs-number">0</span>]&lt;=<span class="hljs-number">18</span>*<span class="hljs-number">60</span>)time_sum -= <span class="hljs-number">90</span>;<br>    <span class="hljs-keyword">if</span>(out_time[out<span class="hljs-number">-1</span>]&gt;=<span class="hljs-number">14</span>*<span class="hljs-number">60</span> &amp;&amp; in_time[<span class="hljs-number">0</span>]&lt;=<span class="hljs-number">12</span>*<span class="hljs-number">60</span>)time_sum -= <span class="hljs-number">120</span>;<br>        <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; in; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> back = in_time[i];<br>        <span class="hljs-type">int</span> leave = out_time[i<span class="hljs-number">-1</span>];<br>        <span class="hljs-type">int</span> leave_time = back - leave;<br>        <span class="hljs-keyword">if</span>(leave_time &lt;= <span class="hljs-number">15</span>)<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(back&gt;=<span class="hljs-number">195</span>*<span class="hljs-number">6</span> &amp;&amp; leave&lt;=<span class="hljs-number">18</span>*<span class="hljs-number">60</span>)leave_time -= <span class="hljs-number">90</span>;<br>        <span class="hljs-keyword">if</span>(back&gt;=<span class="hljs-number">14</span>*<span class="hljs-number">60</span> &amp;&amp; leave&lt;=<span class="hljs-number">12</span>*<span class="hljs-number">60</span>)leave_time -= <span class="hljs-number">120</span>;<br>        <span class="hljs-keyword">if</span>(leave_time &gt; <span class="hljs-number">0</span>)<br>            time_sum -= leave_time;      <br>    &#125;<br>    <span class="hljs-keyword">if</span>(time_sum &lt;<span class="hljs-number">0</span>)<br>        time_sum = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; time_sum &lt;&lt;endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p><strong>思路：</strong><br>(1) 读入时间的时候，进入的时间如果在休息时间内，就设成休息时间的结束。如果离开时间在休息时间内，就设成休息时间的开始。<br>(2) 总时间首先是最后离开的时间减去一开始进入的时间。再根据起止时间的范围，判断是否减去午休和晚餐的时间。<br>(3) 再考虑中间每次离开，如果大于15分钟，就从总时长中减去</p><h3 id="第二题（200分）"><a href="#第二题（200分）" class="headerlink" title="第二题（200分）"></a>第二题（200分）</h3><p>已知一棵完全二叉树，满足每个结点的值是它的叶结点频率的最大值加最小值除以2减去它的父节点的值之和。给定叶节点的个数和频率，求这个完全二叉树。</p><p>如：</p><img src="/2023/08/31/2024%E7%A7%8B%E6%8B%9B%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/1.png" class="" title="fig:1"><p>输入节点数4，输入四个节点的频率。根节点的叶节点为4个节点，四个节点的最大值加最小值除以2，再减去其根节点（没有根节点），得到13。其他节点同理，可以看到计算完成后，每一个根节点到叶节点的值之和是该叶节点的频率。</p><p><strong>输入描述：</strong></p><p>第一行：叶节点个数。一定是2的n次。</p><p>第二行：每个叶节点的频率，0 &lt; x &lt; 1000000</p><p><strong>输出描述：</strong></p><p>二叉树的层序遍历，注意最后不能有空格</p><p><strong>样例输入：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">18 </span><span class="hljs-number">24</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">13 </span><span class="hljs-number">8</span> -<span class="hljs-number">10</span> -<span class="hljs-number">3</span> <span class="hljs-number">3</span> -<span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>My answer:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_max_min</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; leaf, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> num, <span class="hljs-type">int</span>&amp; max, <span class="hljs-type">int</span> &amp;min)</span></span><br><span class="hljs-function"></span>&#123;<br>    min = leaf[left];<br>    max = leaf[left];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = left+<span class="hljs-number">1</span>; i &lt; left+num; i++)<br>    &#123;<br>        min = min &lt; leaf[i] ? min : leaf[i];<br>        max = max &gt; leaf[i] ? max : leaf[i];<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leaf</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>, min = <span class="hljs-number">1000000</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin &gt;&gt; leaf[i];<br>    &#125;<br>    <span class="hljs-type">int</span> layers = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">log</span>(n)/<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>)) + <span class="hljs-number">1</span>;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; fathers, fathers_tmp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; layers; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> num = n / <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,i);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,i);j++)<br>        &#123;<br>            <span class="hljs-type">int</span> value;<br>            <span class="hljs-keyword">if</span>(i != layers - <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-type">int</span> min,max;<br>                <span class="hljs-built_in">get_max_min</span>(leaf, num*(j), num, max, min);<br>                value  = (max+min)/<span class="hljs-number">2</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                value = leaf[j];<br>            fathers_tmp.<span class="hljs-built_in">push_back</span>(value);<br>            <span class="hljs-keyword">if</span>(fathers.<span class="hljs-built_in">size</span>()!=<span class="hljs-number">0</span>) value -= fathers[j/<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span>(j==n<span class="hljs-number">-1</span>)cout &lt;&lt; value &lt;&lt; endl;<br>            <span class="hljs-keyword">else</span><br>                cout &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        fathers.<span class="hljs-built_in">assign</span>(fathers_tmp.<span class="hljs-built_in">begin</span>(),fathers_tmp.<span class="hljs-built_in">end</span>());<br>        fathers_tmp.<span class="hljs-built_in">clear</span>();<br>    &#125;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路：</strong><br>从根节点开始按层计算。对每个节点，确定节点对应的叶节点，找到最大值最小值。同时保存上一层所有节点的父节点值加上本节点的值之和。</p><h3 id="第三题（300分）"><a href="#第三题（300分）" class="headerlink" title="第三题（300分）"></a>第三题（300分）</h3><p>有n个任务，任务之间有依赖关系（只有做完任务A，才能做任务B），每个任务需要不同内存，在尽快完成所有任务的情况下需要的最小内存是多少</p><p><strong>输入描述：</strong></p><p>第一行：任务个数</p><p>第二行：每个任务占用内存量</p><p>第3~3+n行：任务之间的依赖关系</p><p><strong>输出描述：</strong></p><p>需要的最小内存</p><p><em>这题没做完，案例也没有记录下来。拓扑排序相关之前做的比较少，如果有时间需要刷一刷这类题。</em></p>]]></content>
    
    
    <categories>
      
      <category>2024秋招记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>c++多线程学习笔记-2</title>
    <link href="/2023/08/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/"/>
    <url>/2023/08/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/</url>
    
    <content type="html"><![CDATA[<p>单纯的mutex需要手动进行加锁和解锁，如果加锁解锁不匹配，程序就会出现bug无法运行。此外，因为抛出异常或return等操作可能导致没有解锁就退出的问题。更好的办法是采用”资源分配时初始化”(RAII)方法来加锁、解锁。此时主要会用到lock_guard和unique_lock两个类。</p><h3 id="std-lock-guard"><a href="#std-lock-guard" class="headerlink" title="std::lock_guard"></a>std::lock_guard</h3><ul><li>当构造函数被调用时，该互斥量会被自动锁定</li><li>当析构函数被调用时，该互斥量会自动解锁</li><li>lock_guard对象不能复制或移动，因此只能在局部作用域中使用</li></ul><p>例子如下，两个线程都对一个全局变量进行累加，如果不加锁线程就可能同时对a进行操作，产生矛盾。使用lock_guard，我们不需要手动解锁，在lock_guard被析构时自动解锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>std::mutex mtx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br>    &#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(mtx)</span></span>;<br>        a++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; a &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">20000</span><br></code></pre></td></tr></table></figure><p>从lock_guard的源码分析（除了构造函数和析构函数以外，没有其他函数）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Mutex</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">lock_guard</span><br>&#123;<span class="hljs-comment">// class with destructor that unlocks a mutex</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">using</span> mutex_type = _Mutex;<br><br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">lock_guard</span><span class="hljs-params">(_Mutex&amp; _Mtx)</span></span><br><span class="hljs-function">: _MyMutex(_Mtx)</span><br><span class="hljs-function">&#123;</span><span class="hljs-comment">// 构造函数中对mtx加锁</span><br>_MyMutex.<span class="hljs-built_in">lock</span>();<br>&#125;<br><br><span class="hljs-built_in">lock_guard</span>(_Mutex&amp; _Mtx, <span class="hljs-type">adopt_lock_t</span>)<br>: _MyMutex(_Mtx)<br>&#123;<span class="hljs-comment">// 当前mtx已获得变量所有权时，调用lock_guard需要加一个常数，此时不用再次加锁</span><br>&#125;<br><br>~<span class="hljs-built_in">lock_guard</span>() <span class="hljs-keyword">noexcept</span><br>&#123;<span class="hljs-comment">// 在析构函数中对mtx解锁</span><br>_MyMutex.<span class="hljs-built_in">unlock</span>();<br>&#125;<br><br>    <span class="hljs-comment">// 禁用拷贝构造和等于（不能复制和移动）</span><br><span class="hljs-built_in">lock_guard</span>(<span class="hljs-type">const</span> lock_guard&amp;) = <span class="hljs-keyword">delete</span>;<br>lock_guard&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> lock_guard&amp;) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-keyword">private</span>:<br>_Mutex&amp; _MyMutex;<br>&#125;;<br><br></code></pre></td></tr></table></figure><div class="note note-success">            <p>explicit: 构造类时不支持隐式转换。也就是必须是一个已被定义为_Mutex类的变量才能用于构造lock_guard</p>          </div><h3 id="std-unique-lock"><a href="#std-unique-lock" class="headerlink" title="std::unique_lock"></a>std::unique_lock</h3><p>相比lock_guard，unique_lock可以对互斥量做更丰富的操作，因此使用更加广泛，但同时占用的资源也会更多。</p><h4 id="操作一：自动加锁解锁"><a href="#操作一：自动加锁解锁" class="headerlink" title="操作一：自动加锁解锁"></a>操作一：自动加锁解锁</h4><p>用上述例子，将lock_guard换成unique_lock可以实现同样功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>std::mutex mtx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br>    &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(mtx)</span></span>;<br>        a++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; a &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="操作二：延迟锁定"><a href="#操作二：延迟锁定" class="headerlink" title="操作二：延迟锁定"></a>操作二：延迟锁定</h4><p>当调用函数时传入std::defer_lock，构造函数不会自动加锁，而由程序员在后续代码中决定什么时候加锁，加什么样的锁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(mtx,std::defer_lock)</span></span>;<br></code></pre></td></tr></table></figure><p>查看源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">unique_lock</span>&#123;<br>    <span class="hljs-function">xxx</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">unique_lock</span><span class="hljs-params">(_Mutex&amp; _Mtx, <span class="hljs-type">defer_lock_t</span>)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">: _Pmtx(_STD addressof(_Mtx)), _Owns(false)</span><br><span class="hljs-function">&#123;</span><span class="hljs-comment">// 构造函数什么都不做，没有加锁</span><br>&#125;<br><br>    xxx<br>&#125;<br></code></pre></td></tr></table></figure><p>之后可以进行手动加锁：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">lg.lock()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>查看源码：是调用mutex的lock函数</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sqf">  void <span class="hljs-built_in">lock</span>()<br>&#123;<span class="hljs-comment">// lock the mutex</span><br><span class="hljs-variable">_Validate</span>();<br><span class="hljs-variable">_Pmtx</span>-&gt;<span class="hljs-built_in">lock</span>();<br><span class="hljs-variable">_Owns</span> = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="操作三：尝试加锁并返回是否加锁成功-try-lock"><a href="#操作三：尝试加锁并返回是否加锁成功-try-lock" class="headerlink" title="操作三：尝试加锁并返回是否加锁成功-try_lock"></a>操作三：尝试加锁并返回是否加锁成功-try_lock</h4><p>try_lock尝试获得mutex所有权，如果可以就加锁返回true，否则返回false，程序继续往下运行。</p><p>如下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>std::mutex mtx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(mtx, std::defer_lock)</span></span>;<br>    <span class="hljs-keyword">if</span>(lg.<span class="hljs-built_in">try_lock</span>())&#123;<br>        a++;<br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">3</span>));<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        b++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>t1获得mtx所有权后，会对a加1，等待2s，此时t2尝试获取mtx所有权，但无法获取，返回false，执行b加1.</p><p>也可以写成这样：在构造函数中加入try_to_lock的参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(mtx, std::try_to_lock)</span></span>;<br>    <span class="hljs-keyword">if</span>(lock.<span class="hljs-built_in">owns_lock</span>())&#123;<br>        a++;<br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">3</span>));<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        b++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="操作四：在一段时间内尝试加锁-try-lock-for"><a href="#操作四：在一段时间内尝试加锁-try-lock-for" class="headerlink" title="操作四：在一段时间内尝试加锁-try_lock_for"></a>操作四：在一段时间内尝试加锁-try_lock_for</h4><p>try_lock_for尝试在一定时间内获得mutex所有权，如果可以就加锁返回true，否则返回false，程序继续往下运行。</p><p>如下面的例子：(此时mutex要选用timed_mutex)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>std::timed_mutex mtx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-function">std::unique_lock&lt;timed_mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(mtx, std::defer_lock)</span></span>;<br>    <span class="hljs-keyword">if</span>(lg.<span class="hljs-built_in">try_lock_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>)))&#123;<br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">2</span>));<br>        a++;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        b++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>t1获得mtx所有权后，会对a加1，等待2s，此时t2尝试在5s内获取mtx所有权。在等待过程中t1休眠完毕，释放mtx所有权，t2就可以加锁，再对a加1。最终a&#x3D;2,b&#x3D;0</p><h4 id="特性：所有权可以移动但是不能复制"><a href="#特性：所有权可以移动但是不能复制" class="headerlink" title="特性：所有权可以移动但是不能复制"></a>特性：所有权可以移动但是不能复制</h4><p>查看源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++">    <span class="hljs-built_in">unique_lock</span>(unique_lock&amp;&amp; _Other) <span class="hljs-keyword">noexcept</span><br>: _Pmtx(_Other._Pmtx), _Owns(_Other._Owns)<br>&#123;<span class="hljs-comment">// 可以移动另一个mutex的所有权</span><br>_Other._Pmtx = <span class="hljs-literal">nullptr</span>;<br>_Other._Owns = <span class="hljs-literal">false</span>;<br>&#125;<br><br>unique_lock&amp; <span class="hljs-keyword">operator</span>=(unique_lock&amp;&amp; _Other)<br>&#123;<span class="hljs-comment">// 等号可以用于移动另一个mutex的所有权</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != _STD <span class="hljs-built_in">addressof</span>(_Other))<br>&#123;<br><span class="hljs-keyword">if</span> (_Owns)<br>_Pmtx-&gt;<span class="hljs-built_in">unlock</span>();<br>_Pmtx = _Other._Pmtx;<br>_Owns = _Other._Owns;<br>_Other._Pmtx = <span class="hljs-literal">nullptr</span>;<br>_Other._Owns = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> (*<span class="hljs-keyword">this</span>);<br>&#125;<br><br>    <span class="hljs-built_in">unique_lock</span>(<span class="hljs-type">const</span> unique_lock&amp;) = <span class="hljs-keyword">delete</span>;<br>    unique_lock&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> unique_lock&amp;) = <span class="hljs-keyword">delete</span>;<br>```  <br><br>### <span class="hljs-built_in">call_once</span>()<br><br>使用场景：某些类是单例模式，在整个程序中只能创建一个实例，此时多线程调用可能有问题。<br><br>如下面的例子，该类使用了一个静态成员函数 <span class="hljs-built_in">getInstance</span>() 来获取单例实例，用了一个静态局部变量 instance 来存储单例实例。由于静态局部变量只会被初始化一次，因此该实现可以确保单例实例只会被创建一次。<br><br>```C++<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>         <span class="hljs-type">static</span> Singleton instance;<br>         <span class="hljs-keyword">return</span> instance;<br>    &#125;    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setData</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>         m_data = data;<br>    &#125;    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>         <span class="hljs-keyword">return</span> m_data;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125; <span class="hljs-comment">//构造函数为private</span><br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;    <span class="hljs-comment">// 禁用拷贝构造和等号</span><br>    <span class="hljs-type">int</span> m_data = <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>但如果多个线程同时调用 getInstance() 函数，可能会导致多个对象被创建，从而违反了单例模式的要求。并且可能会出现多个线程同时调用 setData() 函数来修改m_data，可能会导致数据不一致或不正确的结果。</p><p>此时可以用call_once函数，call_once函数将输入一个std::once_flag类型的变量，用于标记该函数是否已经被调用过。将该类改写为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>            std::<span class="hljs-built_in">call_once</span>(m_onceFlag, &amp;Singleton::init);<br>            <span class="hljs-keyword">return</span> *m_instance;<br>    &#125;    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setData</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>        m_data = data;<br>    &#125;    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;        <br>    <span class="hljs-keyword">return</span> m_data;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;    <br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        m_instance.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> Singleton);<br>    &#125;    <br>    <span class="hljs-type">static</span> std::unique_ptr&lt;Singleton&gt; m_instance;    <br>    <span class="hljs-type">static</span> std::once_flag m_onceFlag;    <br>    <span class="hljs-type">int</span> m_data = <span class="hljs-number">0</span>;<br>&#125;;<br><br>std::unique_ptr&lt;Singleton&gt; Singleton::m_instance;<br>std::once_flag Singleton::m_onceFlag;<br></code></pre></td></tr></table></figure><p>此时，我们创建了一个静态成员变量 m_onceFlag 来标记初始化是否已经完成。在 getInstance() 函数中，我们使用 std::call_once 来调用 init() 函数，仅当第一次调用时m_onceFlag有效，可以调用init()。后续再有线程运行到此处无法调用init()，直接返回该实例。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="http://www.seestudy.cn/?list_9/">陈子青C++公开课:C++11 跨平台多线程编程与线程池</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++多线程学习笔记-1</title>
    <link href="/2023/08/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
    <url>/2023/08/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>进程与线程：</p><p>进程是运行中的程序。</p><p>线程是进程中可并行的一个子程序，主要目的是提高程序运行效率。最大线程个数是CPU核数。</p>          </div><h3 id="Thread线程库的基本使用"><a href="#Thread线程库的基本使用" class="headerlink" title="Thread线程库的基本使用"></a>Thread线程库的基本使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printMessage</span><span class="hljs-params">(std::string msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; msg &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(printMessage, <span class="hljs-string">&quot;Hello thread!&quot;</span>)</span></span>;<br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li><p>定义一个线程：</p> <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-title">std::</span><span class="hljs-keyword">thread</span>(function_name, args)<br></code></pre></td></tr></table></figure></li><li><p>等待线程完成</p> <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">t.<span class="hljs-keyword">join</span>()<br></code></pre></td></tr></table></figure><p> 等待线程完成后主程序才往下运行。如果没有这一句，上面的线程在没有打印完msg时主程序已结束，就会报错。</p></li><li><p>分离线程</p> <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">t.detach<span class="hljs-comment">()</span><br></code></pre></td></tr></table></figure><p> 分离线程，让它在后台运行。往往用于多进程的情况。</p></li><li><p>joinable</p> <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">bool isJoin <span class="hljs-operator">=</span> t.joinable()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p> joinable()方法返回一个布尔值，如果线程可以被join()或detach()，则返回true，否则返回false。防止直接使用join报错。</p></li></ol><h4 id="变量未定义问题"><a href="#变量未定义问题" class="headerlink" title="变量未定义问题"></a>变量未定义问题</h4><p>传递的函数需要引用，指针类型变量时容易出现的线程没运行完，变量已被释放的问题。</p><ol><li><p>函数参数是引用</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span></span>&#123;<br>    x += <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(foo, std::ref(a))</span></span>;<br>    t.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; a &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> std::ref用于取某个变量的引用，但要保证在线程函数执行期间，变量 <code>a</code> 的生命周期是有效的。</p></li><li><p>函数参数是指针</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>* x)</span></span>&#123;<br>    std::cout &lt;&lt; *x &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> *ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(foo, ptr)</span></span>;<br>    <span class="hljs-comment">// delete ptr;</span><br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 如果在注释处释放指针，线程还没执行完，foo函数根据地址取到的就是一个未知的数。</p></li><li><p>解决方法：用智能指针</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>&#123;<br>        std::cout&lt;&lt; <span class="hljs-string">&quot;Hello!&quot;</span> &lt;&lt; std::endl; <br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::shared_ptr&lt;A&gt; a = std::make_shared&lt;A&gt;;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(&amp;A::foo, a)</span></span>;<br><br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 用智能指针来定义需要传递的指针参数，这样该参数就能在不需要的时候自动析构。</p></li><li><p>入口函数为类的私有函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// friend void thread_foo();</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>&#123;<br>        std::cout&lt;&lt; <span class="hljs-string">&quot;Hello!&quot;</span> &lt;&lt; std::endl; <br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::shared_ptr&lt;A&gt; a = std::make_shared&lt;A&gt;;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(&amp;A::foo, a)</span></span>;<br><br>    t.<span class="hljs-built_in">join</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">thread_foo</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果直接运行，会报错，因为函数thread_foo无法访问类的私由函数。但用注释那行，将该函数设为友元，则可以访问。</p></li></ol><h3 id="互斥量mutex"><a href="#互斥量mutex" class="headerlink" title="互斥量mutex"></a>互斥量mutex</h3><p>多个线程访问一个变量，且对变量进行修改，此时会出现函数竞争问题，导致函数运行结果不确定。因此需要用到互斥锁，使得每次只能有一个程序访问变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>std::mutex mtx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br>    &#123;<br>        mtx.<span class="hljs-built_in">lock</span>();<br>        a += <span class="hljs-number">1</span>;<br>        mtx.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; a &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>倘若不加互斥锁，可能导致多个线程对a操作，此时操作重叠就可能出现问题。加了互斥锁，每次只能有一个线程访问a，使得最终<code>a=20000</code></p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>如下面程序中的情况，线程<code>t1</code>运行<code>func1</code>，获取了<code>mtx1</code>的所有权，如果此时正好线程<code>t2</code>运行<code>func2</code>获得了<code>mtx2</code>的所有权。那就会出现<code>t1</code>,<code>t2</code>都在等对方，都无法运行的死锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br>std::mutex mtx1, mtx2;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123;  <br>    mtx1.<span class="hljs-built_in">lock</span>();  <br>    mtx2.<span class="hljs-built_in">lock</span>();                  <br>    mtx2.<span class="hljs-built_in">unlock</span>();<br>    mtx1.<span class="hljs-built_in">unlock</span>();    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123;    <br>    mtx2.<span class="hljs-built_in">lock</span>();<br>    mtx1.<span class="hljs-built_in">lock</span>();        <br>    mtx1.<span class="hljs-built_in">unlock</span>();    <br>    mtx2.<span class="hljs-built_in">unlock</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func1)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func2)</span></span>;    <br>    t1.<span class="hljs-built_in">join</span>();    <br>    t2.<span class="hljs-built_in">join</span>();    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.seestudy.cn/?list_9/">http://www.seestudy.cn/?list_9/</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pyside6安装后报错及解决方法</title>
    <link href="/2023/08/24/pyside6%E5%AE%89%E8%A3%85%E5%90%8E%E4%BD%BF%E7%94%A8%E6%8A%A5%E9%94%99/"/>
    <url>/2023/08/24/pyside6%E5%AE%89%E8%A3%85%E5%90%8E%E4%BD%BF%E7%94%A8%E6%8A%A5%E9%94%99/</url>
    
    <content type="html"><![CDATA[<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>ubuntu 20.04</p><h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><p>通过pip安装完后pyside6，使用时报错</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">qt.qpa.plugin: Could <span class="hljs-keyword">not</span> <span class="hljs-built_in">load</span> <span class="hljs-keyword">the</span> Qt <span class="hljs-built_in">platform</span> plugin <span class="hljs-string">&quot;xcb&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;&quot;</span> even though <span class="hljs-keyword">it</span> was found.<br>This application failed <span class="hljs-built_in">to</span> <span class="hljs-built_in">start</span> because no Qt <span class="hljs-built_in">platform</span> plugin could be initialized. Reinstalling <span class="hljs-keyword">the</span> application may fix this problem.<br><br>Available <span class="hljs-built_in">platform</span> plugins are: offscreen, wayland-egl, linuxfb, vkkhrdisplay, minimalegl, minimal, wayland, xcb, eglfs, vnc.<br><br>Aborted (core dumped)<br></code></pre></td></tr></table></figure><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>参考<a href="https://blog.csdn.net/LOVEmy134611/article/details/107212845">https://blog.csdn.net/LOVEmy134611/article/details/107212845</a></p><ol><li><p>修改脚本文件<code>~/.bashrc</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">vim ~/.bashrc</span><br></code></pre></td></tr></table></figure></li><li><p>在最后加入</p> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">QT_DEBUG_PLUGINS</span>=1<br></code></pre></td></tr></table></figure></li><li><p>保存退出，使配置文件生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">source</span> ~/.bashrc</span><br></code></pre></td></tr></table></figure></li><li><p>再次调用pyside6函数，查看详细报错输出，在最下方找到</p> <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">xxx<br>libxcb-cursor.<span class="hljs-keyword">so</span>.0: cannot <span class="hljs-keyword">open</span> shared object <span class="hljs-keyword">file</span>: <span class="hljs-keyword">No</span> such <span class="hljs-keyword">file</span> or directory<br>xxx<br></code></pre></td></tr></table></figure></li><li><p>安装库libxcb-cursor0后，能够正常运行</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> libxcb-cursor0<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2024秋招美团笔试题目记录(2023.8.12, 2023.8.19)</title>
    <link href="/2023/08/12/2024%E7%A7%8B%E6%8B%9B%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95(2023.8.12,2023.8.19)/"/>
    <url>/2023/08/12/2024%E7%A7%8B%E6%8B%9B%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95(2023.8.12,2023.8.19)/</url>
    
    <content type="html"><![CDATA[<h2 id="8-12"><a href="#8-12" class="headerlink" title="8.12"></a>8.12</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p><strong>题目描述：</strong></p><p>给定一个排列$A &#x3D; [a_1, a_2, …, a_n]$，数字不重复。给定两个数x, y, 判断x, y 在A中是否相邻，输出yes or no.</p><p><strong>例子：</strong><br>输入第一行是A的长度，第二行A，第三行x y</p><p>Input: </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">No</span><br></code></pre></td></tr></table></figure><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p><a href="https://leetcode.cn/problems/distance-between-bus-stops/">Leetcode 1184. 公交站间的距离</a></p><h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><p><strong>题目描述：</strong></p><p>给一个矩阵$A_{mxn}$，代表一块蛋糕，每个位置的值$A_{i,j}$代表这部分蛋糕的美味度，横着或竖着切一刀，使得两部分蛋糕美味度之差尽可能小。输出最小的差。</p><p><strong>例子：</strong><br>输入第一行是m，n，第二行开始是A</p><p>Input: </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span> <br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">0<br></code></pre></td></tr></table></figure><h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><p><strong>题目描述：</strong><br>给定一棵树，开始时所有节点为白色。如果两个相连的节点的值相乘是完全平方数，且它们都是白色，可以将这两个节点染成红色。输出最多能染色几个节点。</p><p><strong>例子：</strong><br>输入第一行是节点数n，第二行是各个节点的值，接下来n-1行是节点的边</p><p>Input: </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">3</span> <span class="hljs-number">12</span> <br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure><p>My answer:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">issquare</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">sqrt</span>(n));<br>    <span class="hljs-keyword">if</span>(x * x == n)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Solution</span>(<span class="hljs-type">int</span> n)<br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>            edge.<span class="hljs-built_in">resize</span>(n, tmp);<br>            match.<span class="hljs-built_in">resize</span>(n, <span class="hljs-number">-1</span>);<br>            num = n;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">        </span>&#123;<br>            edge[i].<span class="hljs-built_in">push_back</span>(j);<br>            edge[j].<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search_max</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (match[i] != <span class="hljs-number">-1</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j:edge[i])<br>            &#123;<br>                <span class="hljs-keyword">if</span> (match[j] == <span class="hljs-number">-1</span> || <span class="hljs-built_in">search</span>(match[j]))<br>                &#123;<br>                    match[i] = j;<br>                    match[j] = i;<br>                    sum++;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : edge[i])<br>        &#123;<br>            <span class="hljs-keyword">if</span>(j == match[i])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(match[j] == <span class="hljs-number">-1</span> || <span class="hljs-built_in">search</span>(match[j]))<br>            &#123;<br>                match[i] = j;<br>                match[j] = i;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> num;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; edge;<br>        vector&lt;<span class="hljs-type">int</span>&gt; match;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n) &#123; <span class="hljs-comment">// 注意 while 处理多个 case</span><br>        <span class="hljs-function">Solution <span class="hljs-title">s</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">value</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            cin &gt;&gt; value[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> x, y;<br>            cin &gt;&gt; x &gt;&gt; y;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">issquare</span>(value[x<span class="hljs-number">-1</span>] * value[y<span class="hljs-number">-1</span>]))&#123;<br>                s.<span class="hljs-built_in">add_edge</span>(x - <span class="hljs-number">1</span>, y - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;        <br>        cout &lt;&lt; s.<span class="hljs-built_in">search_max</span>() * <span class="hljs-number">2</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-19"><a href="#8-19" class="headerlink" title="8.19"></a>8.19</h2><h3 id="第一题-1"><a href="#第一题-1" class="headerlink" title="第一题"></a>第一题</h3><p><strong>题目描述：</strong></p><p>给定一个整数x，一个上限m，当x超过上限m时从1开始重新计数（就是取余）</p><p><strong>例子：</strong></p><p>输入第一个数x，第二个m</p><p>Input: </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>2<br>4<br>2<br></code></pre></td></tr></table></figure><h3 id="第二题-1"><a href="#第二题-1" class="headerlink" title="第二题"></a>第二题</h3><p>输入一个整数数组${a_i}$，总和$sum&#x3D;a_1 + a_2 + … + a_n$，可以将其中一个加号换成乘号，也可以不换。求可能的sum的最大值</p><p><strong>例子：</strong></p><p>第一行是数组个数</p><p>第二行是数组元素</p><p>Input: </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">24<br></code></pre></td></tr></table></figure><p>1 + 2 + 4 * 5 + 1 &#x3D; 24</p><p>可以枚举乘号的位置，只需要注意$a_i$变量类型设为long long int</p><h3 id="第三题-1"><a href="#第三题-1" class="headerlink" title="第三题"></a>第三题</h3><p><strong>题目描述：</strong></p><p>对于一个只含0，1的字符串，对其某一位取反定义为操作一次，对一个字符串操作最少次数使其相邻两位不同，这个最少次数为字符串的权值。现给定一个字符串，求其所有字符串的权值之和。</p><p><strong>例子：</strong></p><p>Input: </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">10001<br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">8<br></code></pre></td></tr></table></figure><p>长度为2的子串：两个00，每个权重为1<br>长度为3的子串：3个子串，每个权重为1<br>长度为4的子串：2个子串，每个权重为1<br>长度为5的子串：1个，权重为1<br>总共 2 + 3 + 2 + 1 &#x3D; 8</p><p>My answer:<br>假设对长度为len,结束位置为i的子字符串，使其变为相邻两位不同且最后一位为0的最小变换次数为$a_0[len][i]$,最后一位为1的最小变换次数为$a_1[len][i]$。则递推公式为</p><p>若s[i] &#x3D; 0：</p><p>$$a_0[len][i] &#x3D; min(a_1[len - 1][i-1], len - 1)$$<br>$$a_1[len][i] &#x3D; min(a_0[len - 1][i-1], len)$$</p><p>s[i] &#x3D; 1同理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; s) &#123; <span class="hljs-comment">// 注意 while 处理多个 case</span><br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a0</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">a0_tmp</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a1</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">a1_tmp</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;0&#x27;</span>)<br>                a1[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                a0[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">2</span>; l &lt;= n; l++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>; i &lt; n; i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;0&#x27;</span>)<br>                &#123;<br>                    a0_tmp[i] = <span class="hljs-built_in">min</span>(a1[i<span class="hljs-number">-1</span>], l - <span class="hljs-number">1</span>);<br>                    a1_tmp[i] = <span class="hljs-built_in">min</span>(a0[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>, l);<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    a1_tmp[i] = <span class="hljs-built_in">min</span>(a0[i<span class="hljs-number">-1</span>], l - <span class="hljs-number">1</span>);<br>                    a0_tmp[i] = <span class="hljs-built_in">min</span>(a1[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>, l);<br>                &#125;<br>                sum += <span class="hljs-built_in">min</span>(a0_tmp[i],a1_tmp[i]);<br>            &#125;<br>            a0.<span class="hljs-built_in">swap</span>(a0_tmp);<br>            a1.<span class="hljs-built_in">swap</span>(a1_tmp);<br>        &#125;<br>        cout &lt;&lt; sum &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第四题-1"><a href="#第四题-1" class="headerlink" title="第四题"></a>第四题</h3><p><strong>题目描述：</strong><br>给定n个正数，一次操作可以对一个数加1，一个数减1. 问使其众数出现次数最多的最少操作数。</p><p><strong>例子：</strong></p><p>第一行是n</p><p>第二行是n个数</p><p>Input: </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span> <br><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>0<br></code></pre></td></tr></table></figure><p>这题没做出来，只想到</p><ul><li><p>如果$a_i$的总和sum能整除n，那最小次数就是 $\frac{1}{2}\sum |a_i - \frac{sum}{n}|$</p></li><li><p>如果不整除，众数个数已等于n-1，答案就是0</p></li><li><p>其他情况：<br>n个数，将其中n-1个变为值v，要次数最少那剩余的一个一定是最大值或最小值。应该要枚举v的可能取值？</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>2024秋招记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/08/10/hello-world/"/>
    <url>/2023/08/10/hello-world/</url>
    
    <content type="html"><![CDATA[<h2 id="写博客的初衷"><a href="#写博客的初衷" class="headerlink" title="写博客的初衷"></a>写博客的初衷</h2><p>有一个毛病困扰了我很久，也是近几年阻碍我向前走的主要原因———我消极的完美主义。</p><p>追溯它的源头，大概是我从小在与世界交互时，收到一些负反馈（比如难以建立良好的人际关系，感觉到他人的疏远，排斥，不喜），我没有勇敢地去面对问题，而是更封闭自己，开始在虚假的幻想中获得安慰。看那些虚无缥缈的小说，假设自己是一个完美的被所有人爱的主角，每晚在这样幻想中沉沉睡去。我变得逃避现实，不敢面对问题；我追求一个完美的虚假的形象；我极度渴望得到他人的认可与爱。</p><p>这些病态的心理导致了我严重的拖延症，行动力差，自我封闭。我在工作时经常陷入无关紧要的细节，在多人场合中保持沉默，甚至连朋友圈都不敢发。我得想办法解决或者改善这个毛病。</p><p>我尝试通过看书找到药方，或者用道理说服自己。从心理上来说，我要改变的底层认知是：接受不完美的自己；意识到微小的进步有巨大的意义。但从小扎根在心底的认知似乎很难改变。我想应该直接从行动出发，或许写博客是一个很好的治愈方法。</p><p>在博客中尽量把我真实的所思所想，我的学习过程写出来，一段粗糙的读书笔记也好，一个简单的技术问题总结也好，尽管不完美也可以直接发出来，被素不相识的人们看到。浅薄无知，笨拙粗糙都没有关系，在一点点的进步中，或许我也会得到肯定和鼓励，而这将带给我莫大的欢喜。</p><h2 id="关于西西弗斯的石头"><a href="#关于西西弗斯的石头" class="headerlink" title="关于西西弗斯的石头"></a>关于西西弗斯的石头</h2><p>西西弗斯的神话里，他绑架了死神，让世间没有死亡，因此受到惩罚，要将一块巨石推上山顶，石头快到山顶就滚落，西西弗斯因此永无止境地重复这样毫无意义的事。</p><p>在加缪对这个故事的解释里，人生就和推石块一样，一样的荒谬，一样的无意义。但当西西弗斯去在意脚下的泥土，去观察巨石的颗粒，当他勇敢无畏地，坚定地选择一次一次推上石块，与虚无进行抗争时，他就为自己创造了意义。我读到这个故事时深为触动，后来看了一些对存在主义哲学的介绍，这些观念塑造了我基础的人生观：</p><p><strong>人生没有既定的意义，需要自己去赋予。但存在本身是有意义的，只有存在才能观察，才能感受。</strong> 因此这个博客也以此为名，这是我的石头，是我认为或许没意义但是要做的事，而我将在这个过程去体验，去观察，去感受。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
