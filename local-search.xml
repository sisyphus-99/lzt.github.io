<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>不同相机和畸变模型</title>
    <link href="/2024/06/05/%E4%B8%8D%E5%90%8C%E7%9B%B8%E6%9C%BA%E5%92%8C%E7%95%B8%E5%8F%98%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/06/05/%E4%B8%8D%E5%90%8C%E7%9B%B8%E6%9C%BA%E5%92%8C%E7%95%B8%E5%8F%98%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="相机成像模型">相机成像模型</h2><h3 id="针孔模型pinhole-model">针孔模型(pinhole model)</h3><p>针孔模型是最常见的相机假设模型，对于空间点P(x,y,z)，经过外参T和内参K投影到图像上的点(u,v):</p><p><span class="math display">\[\lambda \left[ \begin{matrix}    u \\ v \\ 1\end{matrix}\right] = K [R | t] \left[ \begin{matrix}    x \\ y \\ z \\ 1\end{matrix}\right]\]</span></p><h3 id="全向模型omnidirectional-model">全向模型(omnidirectionalmodel)</h3><p>这类相机有360度FOV或者有超过半球的视野。它们有很高的畸变，不能用传统小孔成像模型来描述。</p><p>目前存在几种构建广角相机的方法：</p><ol type="1"><li><p>Dioptric camera(折光相机): 使用一组shapedlens(如鱼眼镜头)，提供略大于半球的视野。鱼眼相机在2000年左右开始使用</p></li><li><p>Catadioptric camera(反射折射相机): lens+mirror.在1990年提出[1]</p></li></ol><center><img src="1.png" width="40%" height="40%" /></center><p><em>catadioptric camera示意图，上方是一个反射镜（可能为双曲线，抛物线，椭圆等），再经过下方一个正常的单孔镜头成像</em></p><ol start="3" type="1"><li>polydioptric cameras: 多个相机的视野组合，能提供360度视野</li></ol><h4 id="用于catadioptric-camera的统一模型">用于catadioptriccamera的统一模型</h4><p><strong>Unified projection model</strong> for central catadioptriccameras: 在2000由 Geyer and Daniilidis[2] 提出 (后来由 Barreto andAraujo[3] 改进)，适用于双曲线、抛物线、椭球面的反射镜组成的折反射相机，但不适合鱼眼相机。</p><p>model的示意图：</p><center><img src="2.png" width="60%" height="60%" /></center><p>mirror坐标系的中心为<spanclass="math inline">\(C\)</span>，相机坐标系的中心为<spanclass="math inline">\(C_\epsilon\)</span>。两个坐标系的X,Y,Z轴方向一致，只是原点在Z方向有一个偏移<spanclass="math inline">\(\epsilon\)</span>。</p><p>假设P是空间中的一个点，P=(x,y,z)是其在mirror坐标系下的坐标。</p><p>（1）将<span class="math inline">\(P\)</span>投影到单位球面上</p><p><span class="math display">\[P_s = \frac{P}{\|P\|} = (x_s, y_s,z_s)\]</span></p><p>（2）将<span class="math inline">\(P_s\)</span>转移到相机坐标系</p><p><span class="math display">\[P_\epsilon= (x_s, y_s, z_s +\epsilon)\]</span></p><p>（3）将<spanclass="math inline">\(P_\epsilon\)</span>转移到归一化图像平面</p><p><span class="math display">\[M = (x_m, y_m, 1) = (\frac{x_s}{z_s +\epsilon}, \frac{y_s}{z_s + \epsilon}, 1)\]</span></p><ol start="4" type="1"><li>将M转移到图像平面</li></ol><p><span class="math display">\[p=\left[\begin{matrix} f_x &amp; 0 &amp;u_0 \\ 0 &amp; f_y &amp; v_0 \\ 0 &amp; 0 &amp; 1 \end{matrix}\right]M\]</span></p><p>其中，我们可以得到<spanclass="math inline">\(P_s\)</span>关于M的函数：</p><p><span class="math display">\[P_s=g(M) \propto \left[ \begin{matrix}    x_m \\ y_m \\ 1-\epsilon \frac{x_m^2+y_m^2 +1}{\epsilon+\sqrt{1+(1-\epsilon^2)(x_m^2+y_m^2)}}\end{matrix} \right]\]</span></p><h4 id="taylor模型">Taylor模型</h4><p>上述模型可以描述catadioptriccamera，但却无法用于精确描述鱼眼相机。这主要是因为三种类型的catadioptriccamera可以通过精确的参数函数（抛物线、双曲线、椭圆）来表示，但鱼眼镜头的投影模型因相机而异，并且取决于视场角，没有一个统一的参数化模型。</p><p>2006年由Scaramuzza et al. [4,5]提出的Taylor模型统一了catadioptriccamera和鱼眼相机模型。它的主要想法为：</p><p>对于归一化图像上的点M和鱼眼（镜子）坐标系下的3D点<spanclass="math inline">\(P_s\)</span>，映射关系为：</p><p><span class="math display">\[P_s=g(M)\propto \left[ \begin{matrix}    x_m \\ y_m \\ a_0+a_2\rho^2+... +a_N\rho^N\end{matrix} \right]\]</span></p><p>其中<span class="math inline">\(\rho = \sqrt{x_m^2+y_m^2}\)</span></p><p>根据多项式的次数不同，该模型可以用来描述perspective camera, fisheyecamera, catadioptric camera</p><h2 id="畸变模型">畸变模型</h2><h3 id="radtanradial-tangential-distortion">Radtan(radial-tangentialdistortion)</h3><p>由<strong>径向畸变</strong>和<strong>切向畸变</strong>组合。</p><p><strong>径向畸变</strong>是由透镜形状引起的畸变，其畸变程度和离光心的距离相关，主要分为枕形畸变和桶型畸变。畸变公式为：</p><p><spanclass="math display">\[\left.\left\{\begin{array}{c}x_{distorted}=x(1+k_1r^2+k_2r^4+k_3r^6)\\\\y_{distorted}=y(1+k_1r^2+k_2r^4+k_3r^6)\end{array}\right.\right.\]</span></p><p>其中<span class="math inline">\(r^2 = x^2 +y^2\)</span>。对于畸变较小的图像中心区域主要是k1起作用，对于畸变较大的边缘区域主要是k2起作用，普通摄像头用这两个系数就可以很好的进行径向畸变的矫正。对于畸变很大的相机，比如鱼眼镜头可以加入k3进行畸变矫正。</p><p>在相机组装过程中由于不能严格使得透镜和成像平面完全平行，这样引起的畸变称为<strong>切向畸变</strong></p><p>组合起来的公式为：</p><p><spanclass="math display">\[\left.\left\{\begin{array}{l}x_{distorted}=x(1+k_1r^2+k_2r^4+k_3r^6)+2p_1xy+p_2(r^2+2x^2)\\\\y_{distorted}=y(1+k_1r^2+k_2r^4+k_3r^6)+p_1(r^2+2y^2)+2p^2xy\end{array}\right.\right.\]</span></p><p>畸变参数包括<spanclass="math inline">\(k_1,k_2,(k_3),p_1,p_2\)</span></p><h3 id="fov">FOV</h3><p><spanclass="math display">\[\left.\left\{\begin{array}{l}x_{distorted}=\frac{r_d}{r}x\\\\y_{distorted}=\frac{r_d}{r}y\end{array}\right.\right.\]</span><span class="math display">\[r^2=x^2+y^2\]</span> <spanclass="math display">\[r_d=\frac{1}{\omega}arctan(2 \cdot r \cdottan(\frac{\omega}{2}))\]</span></p><p>畸变参数<span class="math inline">\(\omega\)</span></p><h3 id="等距畸变equidistantequi">等距畸变(Equidistant,EQUI)</h3><p>设相机坐标系下三维点<spanclass="math inline">\(P=(x,y,z)\)</span>，<spanclass="math inline">\(\theta\)</span>为入射角</p><p><spanclass="math display">\[r^2=\frac{x^2}{z^2}+\frac{y^2}{z^2}\]</span><spanclass="math display">\[\theta=arctan(\frac{\sqrt{x^2+y^2}}{z})=arctan(r)\]</span></p><p>畸变： <span class="math display">\[\theta_d=\theta + k_1 \theta^3 +k_2 \theta^5 +k_3 \theta^7 + k_4 \theta^9\]</span></p><p><spanclass="math display">\[\left.\left\{\begin{array}{l}x_{distorted}=\frac{\theta_d}{r}x\\\\y_{distorted}=\frac{\theta_d}{r}y\end{array}\right.\right.\]</span></p><p>畸变参数<span class="math inline">\(k_1,k_2,k_3,k_4\)</span></p><h2 id="参考文献">参考文献</h2><p>[1] Yagi, Y., Kawato, S. (1990). Panorama scene analysis with conicprojection. IEEE International Conference on Intelligent Robots andSystems, Workshop on Towards a New Frontier of Applications</p><p>[2] Geyer, C., Daniilidis, K. (2000). A unifying theory for centralpanoramic systems and practical applications. European Conference onComputer Vision</p><p>[3] (Barreto, J.P., Araujo, H.). Issues on the geometry of centralcatadioptric image formation</p><p>[4] Scaramuzza, D., Martinelli, A., Siegwart, R. (2006). A flexibletechnique for accurate omnidirectional camera calibration and structurefrom motion. IEEE International Conference on Computer VisionSystems</p><p>[5] Scaramuzza, D., Martinelli, A., Siegwart, R. (2006). A toolboxfor easy calibrating omnidirectional cameras. IEEE InternationalConference on In- telligent Robots and Systems</p>]]></content>
    
    
    <categories>
      
      <category>SLAM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IMU预积分理论推导</title>
    <link href="/2023/11/07/imu%E9%A2%84%E7%A7%AF%E5%88%86%E7%90%86%E8%AE%BA%E6%8E%A8%E5%AF%BC/"/>
    <url>/2023/11/07/imu%E9%A2%84%E7%A7%AF%E5%88%86%E7%90%86%E8%AE%BA%E6%8E%A8%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<p>IMU与视觉或激光耦合是目前SLAM的常用形式。在后端优化中，我们需要通过IMU测量和状态量构建的残差，同时计算残差相对于状态量的雅可比矩阵，以及噪声量的协方差矩阵。为了减少计算量，IMU预积分是目前主要使用的一种形式。</p><h3 id="基本思路">基本思路</h3><p><strong>预积分的主要目的是使得IMU测量量与绝对位姿解耦，避免在位姿更新时需要更新测量量的积分。</strong></p><p>IMU的输出为加速度和角速度，测量模型为（这里考虑以惯性坐标系为参考系）：</p><center><img src="2.png" width="50%" height="50%" /></center><p>其中</p><p><span class="math display">\[n_a \sim N(0,\sigma_a^2),\ n_\omega \simN(0,\sigma_\omega^2)\]</span></p><p><span class="math display">\[\dot{b}_{a_t}=n_{b_a},\\dot{b}_{\omega_t}=n_{b_\omega}\]</span></p><p><span class="math display">\[n_{b_a} \sim N(0,\sigma_{b_a}^2),\n_{b_\omega} \sim N(0,\sigma_{b_\omega}^2)\]</span></p><p><span class="math inline">\(\sigma_a, \sigma_\omega, \sigma_{b_a},\sigma_{b_\omega}\)</span>是IMU的参数，预先经过allen方差等方法标定后作为参数输入。</p><p>那么我们要建立测量值与状态量之间的关系显然需要积分，即通过IMU的运动模型：</p><center><img src="1.png" width="100%" height="100%" /></center><p>上述公式是对连续值的积分，但事实上IMU测量值是一定频率的，离散的。假设<spanclass="math inline">\(t_i \ in [t_k,t_{k+1}]\)</span>是两个相机帧之间的IMU帧，积分公式可以转化为累加的形式：</p><center><img src="3.png" width="100%" height="100%" /></center><p>（来源 https://zhuanlan.zhihu.com/p/388859808）</p><p>这里符号表示和上方不统一，但意思是一致的，即把原来的连续值积分转化为数值累加/累乘。</p><p>根据这个公式，我们事实上已经建立起状态量和测量值之间的关系，可以构建残差了。但问题时，一旦状态量更新，如<spanclass="math inline">\(R_i\)</span>改变，那么由于速度、位置积分中有<spanclass="math inline">\(R_k\)</span>，那i~j之间的速度，位置量必须重新积分，这增加了很大计算量。</p><p>预积分正是为了改进这个问题，它定义了一种相对的运动量（在vinsMono中，这种方式被表述为以k时刻的体坐标系为参考坐标系）。</p><center><img src="4.png" width="100%" height="100%" /></center><div class="note note-success">            <p>预积分量并没有直接的物理含义。<span class="math inline">\(\Delta v,\Deltap\)</span>并不表示某两个速度或位置上的偏差，只是如此定义而已。当然，从量纲上来说，应该与角度、速度、位移对应。</p>          </div><p>可以看到此时等式右侧现在与状态量中的位置，速度，姿态无关。此时更新状态量中的p,q,v，相邻两帧之间的IMU测量值约束也不需要重新计算。不过，如果零偏发生变化，那么还是需要重新积分的，但是考虑到零偏的变化程度比较小，我们能利用修正而非重新计算的思路来调整积分量。</p><h3 id="预积分测量模型">预积分测量模型</h3><p>在测量模型中，我们需要建立预积分测量和状态量之间的关系，同时分析其噪声。</p><h4 id="旋转">旋转</h4><p>我们定义预积分测量量</p><center><img src="5.png" width="50%" height="50%" /></center><p>而我们定义的预积分状态量<span class="math inline">\(\DeltaR_{ij}\)</span>可以表示为：</p><center><img src="6.png" width="60%" height="60%" /></center><p>不断地把观测置换到左侧，并把噪声置换到右侧，并且把噪声项内部<spanclass="math inline">\(\Delta\widetilde{R}\)</span>的项合并，可以得到：</p><center><img src="7.png" width="60%" height="60%" /></center><h4 id="速度">速度</h4><p>定义预积分速度观测量为：</p><center><img src="8.png" width="60%" height="60%" /></center><p>那么可以推导状态量与观测量之间的关系：</p><center><img src="9.png" width="60%" height="60%" /></center><center><img src="10.png" width="60%" height="60%" /></center><h4 id="位置">位置</h4><p>定义预积分位置观测量为：</p><center><img src="11.png" width="60%" height="60%" /></center><p>那么位置状态量与观测量的关系可以写为：</p><center><img src="12.png" width="60%" height="60%" /></center><p>将它们代回最初的定义式，可以简单写为：</p><center><img src="13.png" width="60%" height="60%" /></center><p>可以看到，这里左侧是定义的预积分测量量，只包含原始测量值和偏差，且是累加累乘的形式，很容易由k时刻推导到k+1时刻。从右侧看来，也很容易根据i和j时刻的状态变量来推测预测分观测量的大小，从而写出误差公式，形成最小二乘。</p><p>现在的问题是：预积分的噪声是否符合零均值的高斯分布？如果是，它的协方差有多大？和IMU本身的噪声之间是什么关系</p><h3 id="预积分噪声模型">预积分噪声模型</h3><p>参考 https://zhuanlan.zhihu.com/p/388859808</p><p>噪声的协方差矩阵</p><h3 id="零偏的更新">零偏的更新</h3><p>参考 https://zhuanlan.zhihu.com/p/388859808</p><h3 id="预积分的雅可比矩阵">预积分的雅可比矩阵</h3><p>参考 https://zhuanlan.zhihu.com/p/388859808</p>]]></content>
    
    
    <categories>
      
      <category>SLAM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>秋招面试题记录(拟合直线，平面)</title>
    <link href="/2023/10/31/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%952/"/>
    <url>/2023/10/31/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%952/</url>
    
    <content type="html"><![CDATA[<h3 id="给定一组2d点拟合直线">给定一组2D点，拟合直线</h3><p>假设要求的直线方程为<spanclass="math inline">\(y=ax+b\)</span>，采样点为<spanclass="math inline">\((x_i, y_i), i = 0, 1, ... , n-1\)</span>.</p><p>用fitLine函数实现，输入为一组2D点，输出参数a,b</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Eigen/Core&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Eigen/Dense&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span> </span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;Eigen::Vector2d&gt; points;<br>    <span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>)); <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>    &#123;<br>        Eigen::Vector2d point;<br>        point &lt;&lt; i, <span class="hljs-number">2</span> * i + <span class="hljs-number">3</span> + <span class="hljs-built_in">rand</span>() % <span class="hljs-number">10</span> * <span class="hljs-number">0.1</span>;<br>        points.<span class="hljs-built_in">push_back</span>(point);<br>    &#125;<br>    <span class="hljs-built_in">fitLine</span>(points);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="求线性方程组的最小二乘解">求线性方程组的最小二乘解</h4><p>假设要求的直线方程为<spanclass="math inline">\(y=ax+b\)</span>，而采样点为<spanclass="math inline">\((x_i, y_i), i = 0, 1, ... , n-1\)</span></p><p>那么建立方程</p><p><span class="math display">\[\left[\begin{matrix}    x_1 &amp; 1 \\ x_2 &amp; 1 \\ ... \\ x_n &amp; 1\end{matrix}\right] \left[\begin{matrix}    a \\ b\end{matrix}\right] = \left[\begin{matrix}    y_1 \\ y_2 \\ ... \\ y_n\end{matrix}\right]\]</span></p><p>我们得到了AX=B的矩阵形式。可以用SVD分解,QR分解，正规方程（cholesky分解）来求解。（具体公式参考<ahref="https://sisyphus-99.github.io/2023/10/15/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/">矩阵分解</a>）</p><p>在实现中直接调用Eigen函数来完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fitLine</span><span class="hljs-params">(vector&lt;Eigen::Vector2d&gt; points)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = points.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">Eigen::MatrixXd <span class="hljs-title">A</span><span class="hljs-params">(n, <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">Eigen::VectorXd <span class="hljs-title">b</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-built_in">A</span>(i, <span class="hljs-number">0</span>) = points[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-built_in">A</span>(i, <span class="hljs-number">1</span>) = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">b</span>(i) = points[i][<span class="hljs-number">1</span>];<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;SVD solution is:\n&quot;</span><br>        &lt;&lt; A.<span class="hljs-built_in">bdcSvd</span>(Eigen::ComputeThinU | Eigen::ComputeThinV).<span class="hljs-built_in">solve</span>(b) &lt;&lt; std::endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;The solution using the QR decomposition is:\n&quot;</span><br>        &lt;&lt; A.<span class="hljs-built_in">colPivHouseholderQr</span>().<span class="hljs-built_in">solve</span>(b) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;The solution using normal equations is:\n&quot;</span><br>        &lt;&lt; (A.<span class="hljs-built_in">transpose</span>() * A).<span class="hljs-built_in">ldlt</span>().<span class="hljs-built_in">solve</span>(A.<span class="hljs-built_in">transpose</span>() * b) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>最小二乘法的问题：噪声点的影响很大。可以使用加权最小二乘，使得距离大权重小。设置距离阈值去除离群值。</p><h4 id="用ransac求解">用RANSAC求解</h4><p>随机选两个点，计算直线方程，统计内点比例。选内点比例最高的直线参数作为估计。可以对最终的内点重新求最小二乘解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fitLine</span><span class="hljs-params">(vector&lt;Eigen::Vector2d&gt; points)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = points.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">double</span> bestScore = <span class="hljs-number">-1.</span>;<br>    <span class="hljs-type">int</span> K = <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; K; k++)<br>    &#123;<br>        <span class="hljs-type">int</span> i1=<span class="hljs-number">0</span>, i2=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i1==i2)<br>        &#123;<br>            i1 = <span class="hljs-built_in">randn</span>() % n;<br>            i2 = <span class="hljs-built_in">randn</span>() % n;<br>        &#125;<br>        Eigen::Vector2d point1 = points[i1];<br>        Eigen::Vector2d point2 = points[i2];<br>        <span class="hljs-type">double</span> score = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            Eigen::Vector3d point3 = points[i3];<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>((y3−y1)*(x2−x1)−(y2−y1)*(x3−x1))&lt;= <span class="hljs-number">0.0001</span> )<br>            &#123;<br>                score+=<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(score &gt; bestScore)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(point1[<span class="hljs-number">0</span>] != point2[<span class="hljs-number">0</span>])&#123;<br>                <span class="hljs-type">double</span> k = (point1[<span class="hljs-number">1</span>]-point2[<span class="hljs-number">1</span>])/(point1[<span class="hljs-number">0</span>]-point2[<span class="hljs-number">0</span>]);<br>                b = point1[<span class="hljs-number">1</span>] - k * point1[<span class="hljs-number">0</span>];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                b = (point1[<span class="hljs-number">0</span>] + point2[<span class="hljs-number">0</span>]) / <span class="hljs-number">2</span>;<br>            &#125;<br>            bestScore = score;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>RANSAC能够有效去除噪声点，但是需要迭代多次，耗时较长。</p><h4 id="用ceres求解">用ceres求解</h4><p>用梯度下降来求解，是最小二乘法一种通用解决方法。只要有损失函数，损失函数相对于优化变量的雅可比矩阵，就可以求解。</p><p>此处代码参考《视觉SLAM十四讲》里的cere拟合曲线</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;opencv2/core/core.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ceres/ceres.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 代价函数的计算模型</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CURVE_FITTING_COST</span><br>&#123;<br>    <span class="hljs-built_in">CURVE_FITTING_COST</span> ( <span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y ) : _x ( x ), _y ( y ) &#123;&#125;<br>    <span class="hljs-comment">// 残差的计算</span><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> T* <span class="hljs-type">const</span> ab, <span class="hljs-comment">// 模型参数，有 2 维</span></span></span><br><span class="hljs-params"><span class="hljs-function">    T* residual )</span> <span class="hljs-type">const</span> <span class="hljs-comment">// 残差</span></span><br><span class="hljs-function">    </span>&#123;<br>    <span class="hljs-comment">// y-(ax+b)</span><br>    residual[<span class="hljs-number">0</span>] = <span class="hljs-built_in">T</span> ( _y ) - ( ab[<span class="hljs-number">0</span>]*<span class="hljs-built_in">T</span> ( _x )  + ab[<span class="hljs-number">1</span>] );<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> _x, _y; <span class="hljs-comment">// x,y 数据</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">( <span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> a=<span class="hljs-number">1.0</span>, b=<span class="hljs-number">2.0</span>; <span class="hljs-comment">// 真实参数值</span><br>    <span class="hljs-type">int</span> N=<span class="hljs-number">100</span>; <span class="hljs-comment">// 数据点</span><br>    <span class="hljs-type">double</span> w_sigma=<span class="hljs-number">1.0</span>; <span class="hljs-comment">// 噪声 Sigma 值</span><br>    cv::RNG rng; <span class="hljs-comment">// OpenCV 随机数产生器</span><br>    <span class="hljs-type">double</span> ab[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// abc 参数的估计值</span><br><br>    vector&lt;<span class="hljs-type">double</span>&gt; x_data, y_data; <span class="hljs-comment">// 数据</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;generating data: &quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;N; i++ )<br>    &#123;<br>        <span class="hljs-type">double</span> x = i/<span class="hljs-number">100.0</span>;<br>        x_data.<span class="hljs-built_in">push_back</span> ( x );<br>        y_data.<span class="hljs-built_in">push_back</span> (<br>            a*x + b + rng.<span class="hljs-built_in">gaussian</span> ( w_sigma )<br>        );<br>        cout&lt;&lt;x_data[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;y_data[i]&lt;&lt;endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 构建最小二乘问题</span><br>    ceres::Problem problem;<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;N; i++ )<br>    &#123;<br>        problem.<span class="hljs-built_in">AddResidualBlock</span> ( <span class="hljs-comment">// 向问题中添加误差项</span><br>            <span class="hljs-keyword">new</span> ceres::<span class="hljs-built_in">AutoDiffCostFunction</span>&lt;CURVE_FITTING_COST, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&gt; (<br>                <span class="hljs-keyword">new</span> <span class="hljs-built_in">CURVE_FITTING_COST</span> ( x_data[i], y_data[i] )<br>            ),<br>            <span class="hljs-literal">nullptr</span>, <span class="hljs-comment">// 核函数，这里不使用，为空</span><br>            ab <span class="hljs-comment">// 待估计参数</span><br>        );<br>    &#125;<br><br>    <span class="hljs-comment">// 配置求解器</span><br>    ceres::Solver::Options options; <span class="hljs-comment">// 这里有很多配置项可以填</span><br>    options.linear_solver_type = ceres::DENSE_QR; <span class="hljs-comment">// 增量方程如何求解</span><br>    options.minimizer_progress_to_stdout = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 输出到cout</span><br><br>    ceres::Solver::Summary summary; <span class="hljs-comment">// 优化信息</span><br>    chrono::steady_clock::time_point t1 = chrono::steady_clock::<span class="hljs-built_in">now</span>();<br>    ceres::<span class="hljs-built_in">Solve</span> ( options, &amp;problem, &amp;summary ); <span class="hljs-comment">// 开始优化</span><br>    chrono::steady_clock::time_point t2 = chrono::steady_clock::<span class="hljs-built_in">now</span>();<br>    chrono::duration&lt;<span class="hljs-type">double</span>&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;<span class="hljs-type">double</span>&gt;&gt;( t2-t1 );<br>    cout&lt;&lt;<span class="hljs-string">&quot;solve time cost = &quot;</span>&lt;&lt;time_used.<span class="hljs-built_in">count</span>()&lt;&lt;<span class="hljs-string">&quot; seconds. &quot;</span>&lt;&lt;endl;<br><br>    <span class="hljs-comment">// 输出结果</span><br>    cout&lt;&lt;summary.<span class="hljs-built_in">BriefReport</span>() &lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;estimated a,b = &quot;</span>;<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">auto</span> a:ab ) cout&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    cout&lt;&lt;endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>ceres使用的优化方法有信任域和线搜索两类。Line Search先固定搜索方向，然后在该方向寻找步长，以最速下降法和 Gauss-Newton法为代表。而 Trust Region则先固定搜索区域，再考虑找该区域内的最优点。此类方法以 L-M 为代表。</p><h3 id="给定一组3d点拟合平面">给定一组3D点，拟合平面</h3><p>用<code>矩阵分解</code>，<code>RANSAC</code>方法，<code>梯度下降</code>拟合平面与拟合直线类似，此处不做赘述。</p><h4 id="用pca降维">用PCA降维</h4><p>一组三维点<span class="math inline">\(P_i=(x_i,y_i,z_i)\)</span></p><ol type="1"><li>先将均值中心化，即把坐标原点放到所有点的中心</li></ol><p><span class="math display">\[\vec{m} =(\overline{x},\overline{y},\overline{z})\]</span></p><p><span class="math display">\[P_i&#39;=P_i - \vec{m}\]</span></p><ol start="2" type="1"><li>再计算协方差矩阵</li></ol><p><span class="math display">\[A = \left( \begin{matrix}    x&#39;_1 &amp; y&#39;_1 &amp; z&#39;_1 \\ x&#39;_2 &amp; y&#39;_2&amp; z&#39;_2 \\    ... &amp; ... &amp; ...\end{matrix} \right)\]</span></p><p><span class="math display">\[C = \frac{1}{N}A^TA\]</span></p><ol start="3" type="1"><li>计算协方差矩阵的特征向量<span class="math inline">\(e_1, e_2,e_3\)</span>。其中对应两个较大的特征值的特征向量构成平面，而特征值最小的向量即为平面的法向量。</li></ol>]]></content>
    
    
    <categories>
      
      <category>2024秋招</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>秋招面试代码题记录（树的直径相关）</title>
    <link href="/2023/10/23/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/10/23/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>小明去A市旅游，已知A市有N个旅游景点，景点之间有路径连接组成一棵树。现在小明想要经过其中M个节点，问能经过这M个节点的最短时间（假设每条边需要时间相同），以及开始节点的最小编号。</p><p>输入：</p><p>第1行：节点数 需要经过的节点数</p><p>第2-N行：每一行表示连接两个节点的一条边</p><p>第3行：M个数，表示需要经过的节点编号</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">7 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>思路：</p><p>当一棵树（节点为N）的每个节点都要经过时，经过所有节点的最短路径的长度是?</p><p>由于树的特殊结构，N个节点一定有N-1条边。选择一个叶节点为起点，我们从起点到终点的边只要走一次，其余边要走两次。走过的总路长为</p><p><span class="math display">\[l = L_{start,end} + 2 * (N-1-L_{start,end}) = 2N-2 - L_{start,end}\]</span></p><p>因此我们要让从起点到终点距离最长，可以得到总的走过的距离最短。</p><p>再考虑如果只需要经过其中M个节点。那么只要先构造出包含这M个节点的最小的树。</p><p>所以步骤可以分为:</p><p>（1）保存树的信息</p><p>（2）找到连通M个节点的最小的树</p><p>（3）找到这个树中两个节点之间的最远距离</p><h3 id="构造树">1.构造树</h3><p>树可以记录节点数N，边edges(vector&lt;vector<int>&gt;)，另外根据题目要求再用一个is_visit（长度为N的boolvector）记录每个节点是否需要经过。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Solution</span>(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)&#123;<br>            M = m;<br>            N = n;<br>            edges.<span class="hljs-built_in">resize</span>(N);<br>            is_visit.<span class="hljs-built_in">resize</span>(N, <span class="hljs-literal">false</span>);<br>is_delete.<span class="hljs-built_in">resize</span>(N, <span class="hljs-literal">false</span>);<br>&#125;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span>&#123;<br>            edges[i].<span class="hljs-built_in">push_back</span>(j);<br>            edges[j].<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setVisit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>is_visit[i] = <span class="hljs-literal">true</span>;<br>&#125;<br>        <br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> M, N;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; edges;<br>        vector&lt;<span class="hljs-type">int</span>&gt; is_visit;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> M, N;<br>    cin &gt;&gt; N &gt;&gt; M;<br>    <span class="hljs-function">Solution <span class="hljs-title">solution</span><span class="hljs-params">(M, N)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N - <span class="hljs-number">1</span>; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; M; i++)&#123;<br><span class="hljs-type">int</span> a;<br>cin &gt;&gt; a;<br>solution.<span class="hljs-built_in">setVisit</span>(a);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="找到连通m个节点的最小树">2.找到连通M个节点的最小树</h3><p>需要删除不用经过的节点。</p><p>对于不用访问的点来说，如果它是叶节点，那么可以删除。如果它不是叶节点，但它的叶节点都不用访问，那么它也可以删除。</p><p>我们可以递归地进行删除：</p><p>从一个节点出发，定义一个函数delete(current,father)，在函数内访问它除father之外的所有节点，递归删除它的子节点，如果遍历完所有子节点均已删除，就删除该节点。使用一个is_delete(boolvector)记录已删除的节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(<span class="hljs-type">int</span> current, <span class="hljs-type">int</span> father)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : edges[current])<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i == father)<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">deleteNode</span>(i, current);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!is_visit[current])&#123;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : edges[current])&#123;<br>            <span class="hljs-keyword">if</span>(i == father)<span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(!is_delete[i])&#123;<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag)&#123;<br>            is_delete[current] = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="树的直径">3.树的直径</h3><p>找树上两个节点之间的最远距离是计算树的直径。可以参考<ahref="https://leetcode.cn/problems/tree-diameter/description/">Leetcode1245</a></p><p>题解中给出了三种方法，这里实现其中两种</p><h4 id="执行两轮-bfs广度优先搜索">执行两轮 BFS（广度优先搜索）</h4><p>从任意一点A出发，找到离其最远的一个点B。点B一定是最远路径的一个端点。再找到距离B最远的点C，BC即为最远路径。</p><p>证明过程如下: https://oi-wiki.org/graph/tree-diameter/</p><center><img src="1.png" width="100%" height="100%" /></center><p>实现代码：findLongestNode(node)使用bfs找到距离某个节点node的最远点，设置一个node结构存储bfs搜索时每个点的距离</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-type">int</span> index;<br><span class="hljs-type">int</span> dist;<br><span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> dist): <span class="hljs-built_in">index</span>(index), <span class="hljs-built_in">dist</span>(dist) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLongestPath</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(is_delete[i])&#123;<br>        i++;<br>    &#125;<br>    Node nodeA = <span class="hljs-built_in">findLongest</span>(i);<br>    Node nodeB = <span class="hljs-built_in">findLongest</span>(nodeA.index);<br>    <span class="hljs-keyword">return</span> nodeB.dist;<br>&#125;<br><br><span class="hljs-function">Node <span class="hljs-title">findLongest</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(N, <span class="hljs-literal">false</span>)</span></span>;<br>    vector&lt;Node&gt; q;<br>    q.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Node</span>(i, <span class="hljs-number">0</span>));<br>    <span class="hljs-type">int</span> current_index = <span class="hljs-number">0</span>;<br>    visited[i] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(current_index &lt; q.<span class="hljs-built_in">size</span>())&#123;<br>        Node current = q[current_index];        <br>        current_index++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> node_index : edges[current.index])&#123;<br>            <span class="hljs-keyword">if</span>(!visited[node_index])&#123;<br>                q.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Node</span>(node_index, current.dist + <span class="hljs-number">1</span>));<br>                visited[node_index] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> q.<span class="hljs-built_in">back</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="dfs">DFS</h4><p>如果一个点已知在最长路径上，那么我们找到从它出发的最长和次长路径，将两个距离相加就是最长路径的长度。对于已遍历过节点，下一次找最长路径时不需要再经过，因此我们可以随便取一个点，作为根节点，然后从根节点出发，找到每个节点向下延伸最远的两个距离。例如在求findlongest(0,-1)时，我们要找从节点0出发的最远距离，通过递归地调用findlongest(node,0)，找到所有与0节点相连的node向下的最远距离。在寻找过程中用一个全局变量longest_length记录最长+次长。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br>longest_path = <span class="hljs-number">0</span><br><br><span class="hljs-type">int</span> <span class="hljs-built_in">findLongestPath</span>()<br>&#123;<br>    <span class="hljs-built_in">findLongest</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLongest</span><span class="hljs-params">(<span class="hljs-type">int</span> current, <span class="hljs-type">int</span> father)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> d1 = <span class="hljs-number">0</span>, d2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> node: edges[current])&#123;<br>        <span class="hljs-keyword">if</span>(node == father)<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">int</span> dist = <span class="hljs-built_in">findLongest</span>(node, current) + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(dist &gt; d1)&#123;<br>            d2 = d1;<br>            d1 = dist;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dist &gt; d2)&#123;<br>            d2 = dist;<br>        &#125;<br>    &#125;<br>    longest_path = <span class="hljs-built_in">max</span>(d1 + d2);<br>    <span class="hljs-keyword">return</span> d1;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完整代码">完整代码</h3><p>这里找最长路径使用了第一种方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-type">int</span> index;<br><span class="hljs-type">int</span> dist;<br><span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> dist): <span class="hljs-built_in">index</span>(index), <span class="hljs-built_in">dist</span>(dist) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Solution</span>(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)&#123;<br>            M = m;<br>            N = n;<br>            edges.<span class="hljs-built_in">resize</span>(N);<br>            is_visit.<span class="hljs-built_in">resize</span>(N, <span class="hljs-literal">false</span>);<br>is_delete.<span class="hljs-built_in">resize</span>(N, <span class="hljs-literal">false</span>);<br>&#125;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span>&#123;<br>            edges[i].<span class="hljs-built_in">push_back</span>(j);<br>            edges[j].<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setVisit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>is_visit[i] = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(<span class="hljs-type">int</span> current, <span class="hljs-type">int</span> father)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : edges[current])<br>&#123;<br><span class="hljs-keyword">if</span>(i == father)<span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">deleteNode</span>(i, current);<br>&#125;<br><span class="hljs-keyword">if</span>(!is_visit[current])&#123;<br><span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : edges[current])&#123;<br><span class="hljs-keyword">if</span>(i == father)<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(!is_delete[i])&#123;<br>flag = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(flag)&#123;<br>is_delete[current] = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getRemainedNum</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)&#123;<br><span class="hljs-keyword">if</span>(!is_delete[i])<br>n++;<br>&#125;<br><span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLongestPath</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(is_delete[i])&#123;<br>i++;<br>&#125;<br>Node nodeA = <span class="hljs-built_in">findLongest</span>(i);<br>Node nodeB = <span class="hljs-built_in">findLongest</span>(nodeA.index);<br><span class="hljs-keyword">return</span> nodeB.dist;<br>&#125;<br><br><span class="hljs-function">Node <span class="hljs-title">findLongest</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br><span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(N, <span class="hljs-literal">false</span>)</span></span>;<br>vector&lt;Node&gt; q;<br>q.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Node</span>(i, <span class="hljs-number">0</span>));<br><span class="hljs-type">int</span> current_index = <span class="hljs-number">0</span>;<br>visited[i] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span>(current_index &lt; q.<span class="hljs-built_in">size</span>())&#123;<br>Node current = q[current_index];<br>current_index++;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> node_index : edges[current.index])&#123;<br><span class="hljs-keyword">if</span>(!is_delete[i] &amp;&amp; !visited[node_index])&#123;<br>q.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Node</span>(node_index, current.dist + <span class="hljs-number">1</span>));<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> q.<span class="hljs-built_in">back</span>();<br>&#125;<br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> M, N;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; edges;<br>        vector&lt;<span class="hljs-type">bool</span>&gt; is_visit;<br>vector&lt;<span class="hljs-type">bool</span>&gt; is_delete;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> M, N;<br>    cin &gt;&gt; N &gt;&gt; M;<br>    <span class="hljs-function">Solution <span class="hljs-title">solution</span><span class="hljs-params">(M, N)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N - <span class="hljs-number">1</span>; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>solution.<span class="hljs-built_in">addEdge</span>(a, b);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; M; i++)&#123;<br><span class="hljs-type">int</span> a;<br>cin &gt;&gt; a;<br>solution.<span class="hljs-built_in">setVisit</span>(a);<br>&#125;<br>solution.<span class="hljs-built_in">deleteNode</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br><span class="hljs-type">int</span> remained = solution.<span class="hljs-built_in">getRemainedNum</span>();<br><span class="hljs-type">int</span> c = solution.<span class="hljs-built_in">findLongestPath</span>();<br><span class="hljs-type">int</span> shortest = <span class="hljs-number">2</span> * (remained - <span class="hljs-number">1</span>) - c;<br>cout &lt;&lt; c &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>2024秋招</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IMU建模与状态估计</title>
    <link href="/2023/10/20/imu%E6%A8%A1%E5%9E%8B%E6%8E%A8%E5%AF%BC/"/>
    <url>/2023/10/20/imu%E6%A8%A1%E5%9E%8B%E6%8E%A8%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<p>惯性测量单元(Inertial Measurement Unit,IMU)通常包含三个互相垂直的速率陀螺仪(rate-gyroscpoe)以及三个互相垂直的加速度计(accelerometer)，分别用于测量角速度和线加速度。在VIO，LIO中，IMU常以紧耦合的方式融入里程计中，进行组合状态估计。此时需要对IMU建立测量模型，状态模型，误差模型。</p><h2 id="imu模型基础">IMU模型基础</h2><h3 id="测量原理">测量原理</h3><p>为了推导IMU测量模型，噪声模型，先对IMU中加速度计和陀螺仪测量原理简单介绍。</p><h4 id="加速度计">加速度计</h4><p>加速度计测量物体受到的比力，即去掉重力后整体加速度，或者单位质量上作用的非引力。压电式和电容式加速度计是通过受力导致的电压或电容变化来计算出压力的大小。三个相互正交的加速度计可以测量出三个方向的比力。</p><h4 id="陀螺仪">陀螺仪</h4><p><strong>科里奥利力</strong></p><center><img src="1.png" width="100%" height="100%" /></center><p>计算公式如下：</p><p><span class="math display">\[F=2mv\omega\]</span></p><p>压电式或电容式陀螺仪通过受力导致的电压或电容变化来计算科里奥利力的大小。</p><h3 id="误差来源">误差来源</h3><h4 id="系统误差">系统误差</h4><p>陀螺仪和加速度计的系统误差一般包含以下几种：</p><ul><li>零偏，一个常值误差。当然在实际使用时零偏不是稳定的，对零偏的不稳定性分析引发了各个噪声参数</li><li>比力因子误差：传感器输出值与实际值之间的比例关系。由于传感器测量到输出数据，要经过ADC，数据转换中导致实际输出数据和测量数据之间存在比例关系。</li><li>安装误差：由于加工工艺原因，陀螺仪的三个轴并不完全正交，这个误差可以表示为</li></ul><center><img src="2.png" width="100%" height="100%" /></center><p>（来源 https://www.guyuehome.com/35086)</p><p>这样安装误差是12个参数。</p><p>由此得到误差模型：</p><center><img src="3.png" width="100%" height="100%" /></center><h4 id="系统误差标定">系统误差标定</h4><p>标定过程相当于求解误差模型中的参数，如果我们有了一组真实角速度，加速度和测量值，就可以建立一个方程，这种方法就是基于转台的标定。然而由于转台比较昂贵，也有不依赖转台的方法，主要依靠输入和真值之间得差异（静止的时候加速度应该是重力加速度）。</p><p>（1）基于转台的标定通过转台控制真实的角速度，加速度，再读取陀螺仪和加速度计的读数。这里有一个问题，陀螺仪的输入是角速度，但是转台一般角速度不如角度精度高，因此不是直接以角速度作为真值，而是以积分得到的角度作为真值。</p><p>（2）不依赖于转台的标定：当加速度计静止时，测到的三个加速度的矢量和就是重力加速度，即<spanclass="math inline">\(\|g\|^2=\|a\|^2\)</span>.而实际上两者模的差值就和误差参数相关。通过多个不同静止位置加速度计的测量值可以计算出加速度计的内参。校正完加速度计后，再估计陀螺仪内参中的安装误差和尺度因子误差（零偏由于在短时间的累积中对姿态影响较小，不通过这种方法标，而是用静止状态标定）。</p><p>假设第k个位置得到加速度测量1，旋转一定角度到第k+1个位置，得到加速度测量2，在这段时间对角速度测量值积分可以得到姿态变换。通过姿态变换可以得到推测的加速度测量2',则测量2和2'的差就与误差参数有关。</p><h4 id="随机误差">随机误差</h4><p>参考 https://www.guyuehome.com/35085</p><p>主要包括量化误差，随机游走，零偏不稳定性，速率斜坡，零偏重复性。目前主要通过Allen方差（分析测量值方差和时间的双对数曲线）估计这些参数。</p><h2 id="imu-状态估计">IMU 状态估计</h2><h3 id="imu状态量">IMU状态量</h3><p>那么在实际应用中，IMU的确定性误差如比例因子，非正交安装误差，一个恒定的零偏，假设出厂前已经过校准。随机误差中温度引起的误差假设也已经校准，零偏重复性是在两次上电之间的，在单次运行中不考虑。而零偏不稳定性和随机游走需要在测量模型中加入。</p><p>IMU的状态量通常表示为：</p><p><spanclass="math display">\[\textbf{X}_{IMU}=[\textbf{q}^I_G,\textbf{p}^I_G,\textbf{v}^I_G,\textbf{b}_g,\textbf{b}_a]\]</span></p><p>分别是IMU坐标系相对于世界坐标系的姿态（四元数），位置，速度，加速度。陀螺仪和加速度计的偏差。</p><p>对于 IMU状态估计问题，需要提供运动模型、观测（噪声）模型、估计误差模型：</p><p><span class="math display">\[x=f(\dot{x})\]</span> <spanclass="math display">\[z=g(x)+n\]</span> <spanclass="math display">\[\delta x = e(\hat{x},x)\]</span></p><p>这是一个通用的模型，x是系统的状态量，<spanclass="math inline">\(\dot{x}\)</span>是状态量对时间的导数。z是对状态量x的观测值，<spanclass="math inline">\(\deltax\)</span>是观测值和真实值之间的误差。接下来我们推导对于IMU的这三个方程。</p><h3 id="运动模型">运动模型</h3><p><spanclass="math display">\[\dot{\textbf{p}}_G^I=\textbf{v}^I_G\]</span></p><p><spanclass="math display">\[\dot{\textbf{v}}_G^I=\textbf{a}^I_G\]</span></p><p><span class="math display">\[\dot{\textbf{q}}^I_G = \frac{1}{2} \left[\begin{matrix}    - \lfloor \omega \times \rfloor &amp; \omega \\ -\omega^T &amp; 0\end{matrix} \right ] \textbf{q}_G^I (3) = \frac{1}{2}\Omega(\omega)\textbf{q}_G^I\]</span></p><p><span class="math display">\[\dot{\textbf{b}}_g = \textbf{n}_{\omegag}\]</span></p><p><span class="math display">\[\dot{\textbf{b}}_a = \textbf{n}_{\omegaa}\]</span></p><p>前两个公式比较好理解。</p><p>公式3推导可参考：文献[2]</p><p>公式4,5:零偏被建模为一个随机游走过程，其导数是高斯分布的。也就是<spanclass="math inline">\(\textbf{n}_{\omega g} \sim N(0,\sigma_g^2),\textbf{n}_{\omega a} \sim N(0,\sigma_a^2)\)</span></p><h3 id="imu测量模型">IMU测量模型</h3><p>需要注意的是，观测在不同参考坐标系下形式不同。（根据参考坐标系是否为惯性坐标系，加速度的观测不同）</p><h4 id="ecef-非惯性坐标系">ECEF-非惯性坐标系</h4><p>Earth-Centered-Earth-Fixed (ECEF)Frame：地心地固坐标系（东北天坐标系）。以地心为坐标原点，向北为 z轴，x-y 平面为赤道平面，x 轴指向经纬度 (0,0) 点。ECI固连在地球上，跟随地球自转，非惯性坐标系。MSCKF 一代 [1] 使用 ECEF为参考坐标系 {G}。</p><p>记 <span class="math inline">\({\boldsymbol \omega}_G\)</span>为地球自转角速度， <span class="math inline">\({}^G{\bf g}\)</span>为重力加速度， <span class="math inline">\({\boldsymbol \omega}_m,{\bfa}_m\)</span> 为陀螺仪和加速度计的观测量，观测模型由以下公式给出</p><p><span class="math display">\[{\boldsymbol \omega}_m = {\boldsymbol\omega}+{\bf R}({}^I_G \bar{q}){\boldsymbol \omega}_G+{\bf b}_g+{\bfn}_g \]</span></p><p><span class="math display">\[ {\bf a}_m = {\bf R}({}^I_G\bar{q})({}^G{\bf a} -{}^G{\bf g} +2{\boldsymbol\omega}_G^{\land}{}^G{\bf v}_I+({\boldsymbol\omega}_G^{\land})^2{}^G{\bf p}_I)+{\bf b}_a+{\bf n}_a \]</span></p><p>推导参考链接[2]</p><h4 id="eci-惯性坐标系">ECI-惯性坐标系</h4><p>Earth-Centered-Inertial (ECI)Frame：地心惯性坐标系。以地心为坐标原点，向北为 z 轴，x-y平面为赤道平面，x 轴指向春分点（vernal equinoxpoint，即每年春分时日心-地心连线与赤道的交点）。ECI不跟随地球自转，在惯性导航中视为惯性坐标系。MSCKF 二代 [3] 使用 ECI为参考坐标系 {G}。</p><p>观测模型为</p><p><span class="math display">\[ {\boldsymbol \omega}_m = {\boldsymbol\omega}+{\bf b}_g+{\bf n}_g \]</span></p><p><span class="math display">\[ {\bf a}_m = {\bf R}({}^I_G\bar{q})({}^G{\bf a} -{}^G{\bf g} )+{\bf b}_a+{\bf n}_a \]</span></p><h2 id="参考资料">参考资料</h2><p>[1]https://fzheng.me/2016/11/20/imu_model_eq/#0-%E6%80%BB%E8%A7%88</p><p>[2] Trawny N, Roumeliotis S I. Indirect Kalman filter for 3D attitudeestimation[J]. University of Minnesota, Dept. of Comp. Sci. &amp; Eng.,Tech. Rep, 2005, 2: 2005.</p><p>[3] https://www.guyuehome.com/35085</p>]]></content>
    
    
    <categories>
      
      <category>SLAM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>transformer学习记录（二）原始结构</title>
    <link href="/2023/10/18/transformer%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/"/>
    <url>/2023/10/18/transformer%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/</url>
    
    <content type="html"><![CDATA[<h2 id="整体结构">整体结构</h2><p>原始的transformer应用在NLP领域，输入一个句子，输出另一个句子。整个结构可以分为编码器和解码器两大模块，其中编码器模块由若干个（6）结构相同的编码器按顺序连接，而解码器也有若干个顺序连接。如下图所示</p><center><img src="1.png" width="70%" height="70%" /></center><h2 id="输入">输入</h2><p>通过embeddingalgorithm（每个单词按字典对应一个向量）可以将输入的原始句子转换为embeddings。例如，一个单词转化为512维vector，一个句子的所有embeddings组成一个list.list的长度是固定的（通常可以设为训练集中最长的句子的长度），设定某个特殊embedding作为实际的句子结束符。</p><h2 id="encoder">encoder</h2><p>最底层的encoder接收输入向量，而接下来每一个encoder把上一个encoder的输出作为输入。每一个小的encoder结构是相同的。</p><h3 id="自注意力层">自注意力层</h3><p>每一个小的编码器在结构上可以分为两层：自注意力和前馈层。</p><center><img src="2.png" width="50%" height="50%" /></center><p>每个位置的单词在编码器中都流经其自己的路径。自注意力层中这些路径存在依赖关系，因为自注意力层将寻找单词之间的联系。而前馈层则没有这种依赖关系，因此前馈层可以并行运行。</p><h4 id="从high-level理解self-attention">从highlevel理解self-attention</h4><p>假设我们想要翻译下面这个句子：</p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk"><span class="hljs-comment">&quot;The animal didn&#x27;t cross the street because it was too tired&quot;</span><br></code></pre></td></tr></table></figure><p><code>it</code>在句子里指代哪个单词呢，我们希望自注意力将其与<code>animal</code>联系起来。当模型处理每个单词时，自注意力层查看其它单词并用当前词和其他词的关联程度，对当前词进行编码，希望为当前位置加上上下文的线索。</p><h4 id="从detail理解self-attention">从detail理解self-attention</h4><p>我们首先来看怎么用vector来计算self-attention，这个过程更容易理解，再进一步看它实际是如何用矩阵实现的。</p><h5 id="vector形式">vector形式</h5><p><strong>第一步：生成q,k,v</strong></p><p>从每个输入向量生成3个向量。即对一个单词，我们生成一个query vector,key vector, value vector。这些vector的维度通常小于输入embedding，主要是为了在多头注意力机制下保持输出维度的不变。</p><div class="note note-warnning">            <p>但是多头注意力的输出并不是拼在一起后就直接输入下一个encoder，而是还要经过一个聚合的矩阵，那这里为什么要保持维度呢？</p>          </div><center><img src="3.png" width="70%" height="70%" /></center><p><strong>第二步：计算注意力分数</strong></p><p>假设我们要计算所有单词相对于<code>thinking</code>单词的自注意力分数（也就是所有单词与这个单词的联系），例如某个单词machine，其相对于thinking的注意力表示了我们要将多少程度的machines的含义加到thinking单词输出的编码值中。</p><p>这个分数通过对 query vector 和 keyvector的点积得到，即在算thinking的注意力分数时，thinking本身的注意力是<span class="math inline">\(q_1^T k_1\)</span> ,machines对于thinking的注意力是 <span class="math inline">\(q_1^Tk_2\)</span>. 相对于是用代表单词1的query去和其他单词的 key相乘，相似度表示了两者的联系。</p><p><strong>第三步和第四步</strong></p><p>先将分数除以8（key vector维度的平方根），使得梯度更加稳定（值太大的话经过softmax梯度趋向于0）。再经过一个softmax层，所有注意力转化为了和为1的概率值</p><p><strong>第五步和第六步</strong></p><p>各个注意力分数与valuevector相乘。即把各个注意力乘上单词本身的值。再把所有乘完的值加起来，作为第一个单词在自注意力层一个头的输出。</p><p>整个过程可理解为：当前词的输出希望能计算一个由所有词的含义得到的加权和，那么问题就是所有词的权重怎么计算，要加权的值怎么计算。在实现中，要加权的值是由原始输入根据学习参数得到的value，权重值是由每个词自身的query去乘所有其他词的key得到，query相当于是当前词与其他词寻找联系的信息，key相当于是当前词能提供给其他词的信息。</p><h5 id="矩阵形式">矩阵形式</h5><p>在实际的实现中，这些计算是通过矩阵来做的。所有的输入单词组成一个矩阵X(nx m), n是单词个数，m是每个单词的embedding维度。</p><p><strong>第一步</strong></p><p>X乘上三个系数矩阵（权重由训练进行优化）得到Q,K,V矩阵，如下图所示</p><center><img src="5.png" width="70%" height="70%" /></center><p><strong>第二步</strong></p><p>最终输出可由Q,K,V计算得到：</p><p><spanclass="math display">\[Z=softmax(\frac{QK^T}{\sqrt{d_k}})V\]</span></p><center><img src="6.png" width="50%" height="50%" /></center><h4 id="多头注意力机制">多头注意力机制</h4><p>多头注意力机制是指上述这样的Q,K,V计算了多次（由不同的权重矩阵生成新的Q,K,V），产生多个输出Z,拼在一起组成了下一个encoder的输入。</p><p>这样做的好处是：</p><ol type="1"><li>它扩展了模型的能力，使其能关注不同的位置（可以理解为每个头的一个输出代表了输出位置的一个单词）</li><li>它使得注意力层有了多个表示子空间（每组随机初始化的Q，K，V能学习到一个不同的表示子空间），增强了模型的表达能力</li></ol><p>用实际例子来说明：</p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk"><span class="hljs-comment">&quot;The animal didn&#x27;t cross the street because it was too tired&quot;</span><br></code></pre></td></tr></table></figure><p>在对<code>it</code>进行编码时，训练得到的多头注意力的一个头会最关注<code>animal</code>，其他头更关注<code>tired</code>，因此最终模型对<code>it</code>的表示是<code>animal</code>，<code>tired</code>表示的综合。</p><p>经过多头注意力机制，我们得到了多个矩阵Z：</p><center><img src="7.png" width="50%" height="50%" /></center><p>为了把这个多个输出拼在一起，我们先将其直接拼接，再乘以一个权重矩阵W来聚合所有Z的信息：</p><center><img src="8.png" width="50%" height="50%" /></center><h3 id="残差">残差</h3><p>另外在实现上的一个细节是，自注意力和FFN层都连接了一个残差层。残差层使得网络只需拟合增量，而不需要拟合恒等映射，使得模型更能拟合到正确的表达。</p><h3 id="layernorm">LayerNorm</h3><p>在经过残差连接后，再经过残差连接对特征做归一化。LayerNorm对每个样本内部做归一化，下图展示了LayerNorm和 BatchNorm 归一化的维度的差别：</p><center><img src="11.jpg" width="70%" height="70%" /></center><div class="note note-danger">            <p>BatchNorm和LayerNorm的比较，transformer中使用LayerNorm的原因（参考https://zhuanlan.zhihu.com/p/492803886，但仍然没有太理解）</p>          </div><h3 id="feed-forward-network">Feed Forward Network</h3><p>对自注意力的输出进行多个线性连接和非线性激活函数，相对于对每个位置的向量进行非线性变换，从而提高模型的表达能力。</p><h2 id="positional-encoding">positional encoding</h2><p>在前面描述的注意力机制中，我们用q,k,v能够为当前单词添加其他各个单词的信息，但这里却忽略了单词之间的距离，没有用上句子中各个单词的顺序信息，而这对于理解语义来说也是非常重要的。</p><p>为了表示sequence的顺序，transformer加入了一个positionalencoding。</p><center><img src="9.png" width="50%" height="50%" /></center><p>这些向量遵循一种特定模式，有助于确定每个单词的位置。在计算注意力期间，这些值在embedding中点积可以提供有意义的距离。</p><p>将positional encoding 可视化：</p><center><img src="10.png" width="100%" height="100%" /></center><p>左图是Tenso2Tensor中的实现：横坐标为embedding的维度512，纵坐标为词的顺序，可以看到分成了两块区域，左半边是用sine函数生成的，右半边是用cosine函数生成的。右图是原始论文中的，把cosinesine两个信号穿插在一起。</p><h2 id="decoder">decoder</h2><p>encoder和decoder的连接方式如下图所示：</p><center><img src="12.png" width="100%" height="100%" /></center><p>可以看到一个decoder内部包含两个注意力层。第一个是对decoder输入的自注意力，第二个使用了从encoder编码向量中得到的K,V矩阵。</p><p>decoder中的自注意力层的操作和encoder中有些许不同。自注意力层只被允许考虑之前位置的输出，这通过将未来的位置加上mask(将值设为－Inf) 实现。</p><p>encoder的输出通过权重矩阵转化为了一些注意力向量K和V。这些向量在每个decoder的encoder-decoderattention层中使用（即此时的Q来自decoder的上一层输出，K,V来自encoder的输出），帮助decoder关注输入sequence中合适的位置。</p><p>每一步，decoder得到一个输出，这个输出会再次输入最底层的decoder得到一个新的输出，一直这样循环进行直到特殊标志输出。每一步的输出在输入decoder前也会加入位置编码（decoder的第一个输入是设置的某个起始符，知道输出终止符时结束）</p><h2 id="最后的线性层和softmax层">最后的线性层和softmax层</h2><p>decoder输出的一个向量，通过一个全连接层，转化为一个大的多的向量叫做逻辑向量logits vector（它的长度是模型的词汇量的大小），这个向量的每个单元对应一个单词，单元的值代表这个单词的分数概率。softmax层将所有分数转化到0－1分数最高的单元对应的单词作为这个时刻的输出。</p><h2 id="参考资料">参考资料</h2><p>[1] https://jalammar.github.io/illustrated-transformer/</p>]]></content>
    
    
    <categories>
      
      <category>deep learning</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>矩阵分解</title>
    <link href="/2023/10/15/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/"/>
    <url>/2023/10/15/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="svd分解">SVD分解</h3><p>对任何一个矩阵<span class="math inline">\(A_{m,n}\)</span></p><p><span class="math display">\[A_{m,n}=U_{m,m}\Sigma_{m,n}V^T_{n,n}\]</span></p><center><img src="1.png" width="100%" height="100%" /></center><p>其中<spanclass="math inline">\(U_{m,m},V_{n,n}\)</span>是正交矩阵，<spanclass="math inline">\(\Sigma_{m,n}\)</span>是对角矩阵，对角矩阵中对角线的值称为A的奇异值，U中每一列是A的左奇异向量，V中每一列是A的右奇异向量。</p><p><span class="math display">\[A^TA = V(\Sigma^T\Sigma)V^T\]</span></p><p><span class="math display">\[AA^T = U(\Sigma\Sigma^T)U^T\]</span></p><p>可以看到U,V分别是<span class="math inline">\(AA^T\)</span>和<spanclass="math inline">\(A^TA\)</span>的特征向量，<spanclass="math inline">\(\sigma^2\)</span>是<spanclass="math inline">\(AA^T\)</span>和<spanclass="math inline">\(A^TA\)</span>的特征值</p><h3 id="qr分解">QR分解</h3><p>实数矩阵A可以分解为：</p><p><span class="math display">\[A_{m,n}=Q_{m,m}R_{m,n}\]</span></p><p>其中Q是正交矩阵，R是上三角矩阵。</p><h3 id="用矩阵分解求linear-least-squareslls">用矩阵分解求Linear leastsquares(LLS)</h3><p>SVD分解最稳定，但耗时最长。正规方程求解用了LDLT分解，最不稳定，但耗时最少。QR分解介于两者之间。</p><h4 id="svd分解-1">SVD分解</h4><p>LLS问题可以定位为求解：</p><p><span class="math display">\[\min_x\|Ax-b\|^2_2\]</span></p><p><spanclass="math display">\[\|Ax-b\|_2^2=\|U^T(AVVTx-b)\|^2_2=\|\SigmaV^Tx-U^Tb\|_2^2 \]</span></p><p>令<span class="math inline">\(V^Tx=Z\)</span></p><p><spanclass="math display">\[=\sum^r_{i=1}(\sigma_iz_i-u_i^Tb)^2+\sum^m_{i=r+1}(u_i^Tb)^2\]</span></p><p>则解为：</p><p><span class="math display">\[z_i=\frac{u_i^Tb}{\sigma_i}, i = 1,2,...,r\]</span></p><p><span class="math display">\[z_i = arbitrary, i =r+1,...,n\]</span></p><p><span class="math display">\[x=VZ\]</span></p><h4 id="qr分解-1">QR分解</h4><p>A可以分解为：</p><p><span class="math display">\[A = Q\left[\begin{matrix}    R \\ 0\end{matrix}\right]\]</span></p><p>则有：</p><p><span class="math display">\[Q^T(Ax-b) = Q^T(Q\left[\begin{matrix}    R \\ 0\end{matrix}\right]x-b)=\left[\begin{matrix}    Rx-(Q^Tb)_n \\ (Q^Tb)_{m-n}\end{matrix}\right]=\left[\begin{matrix}    u \\ v\end{matrix}\right]\]</span></p><p>优化的函数为：</p><p><spanclass="math display">\[\|Ax-b\|^2_2=(Ax-b)^T(Ax-b)=(Ax-b)^TQQ^T(Ax-b)=u^Tu+v^Tv\]</span></p><p>由于v与x无关，令u=0，得到</p><p><span class="math display">\[\hat{x}=R^{-1}(Q^Tb)_n\]</span></p><h4 id="正规方程">正规方程</h4><p><span class="math display">\[f(x) = \|Ax-b\|^2_2 = (Ax-b)^T(Ax-b) =x^TA^TAx-x^TA^Tb-b^TAx+b^Tb\]</span></p><p>矩阵求导有以下三个等式：</p><p><span class="math display">\[ \nabla (  x^ {T}  A^ {T}  b)=  A^{T}  b,\nabla  (  b^ {T}  Ax)=  A^ {T}  b,\nabla (  x^ {T}  A^ {T}  Ax)=  2A^ {T}  Ax \]</span></p><p><span class="math display">\[\nabla f(x)= 2 A^TAx -2A^Tb\]</span></p><p>令<span class="math inline">\(\nabla f(x)=0\)</span> 得 <spanclass="math inline">\(A^TAx=A^Tb\)</span></p><div class="note note-success">            <p>导数为0处一定是局部最小值吗？为什么不是最大值或者是鞍点？进一步分析二阶导的性质。由于<spanclass="math inline">\(\nabla^2f(x)=2A^TA\)</span>半正定，因此一定是极小值。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图片消失点，地平线标定相机</title>
    <link href="/2023/09/29/%E5%9B%BE%E7%89%87%E6%B6%88%E5%A4%B1%E7%82%B9%E5%9C%B0%E5%B9%B3%E7%BA%BF%E6%A0%87%E5%AE%9A%E7%9B%B8%E6%9C%BA/"/>
    <url>/2023/09/29/%E5%9B%BE%E7%89%87%E6%B6%88%E5%A4%B1%E7%82%B9%E5%9C%B0%E5%B9%B3%E7%BA%BF%E6%A0%87%E5%AE%9A%E7%9B%B8%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>用消失点和地平线标定相机是我的一项工作中的内容，其中涉及的一些多视图几何原理，在此做一个整理和回顾。</p>          </div><h3id="用道路消失点标定相机与道路的roll和pitch">用道路消失点标定相机与道路的roll和pitch</h3><p>从直观定义上来说，消失点是空间中的平行线投影到图像平面后产生的交点，可以认为三维空间中的平行线在无穷远处相交。那么从数学上，空间中一个方向与图像中消失点坐标的关系是怎样的呢？</p><p>空间点投影到2D平面的方程如下：</p><p><span class="math display">\[\lambda \left[ \begin{matrix}    u \\ v \\ 1\end{matrix}\right] = K [R | t] \left[ \begin{matrix}    x \\ y \\ z \\ 1\end{matrix}\right]\]</span></p><p>空间中一条直线可以由一个方向向量为<spanclass="math inline">\(\vec{v}\)</span>，一个点为<spanclass="math inline">\(P_0\)</span>来定义。这条直线上的点可以表示为：</p><p><span class="math display">\[P = P_0 + k \vec{v} \]</span></p><p>取不同的<spanclass="math inline">\(P_0\)</span>可以得到一组平行的直线</p><p>把P代入投影方程，得到：</p><p><span class="math display">\[\lambda \left[ \begin{matrix}    u \\ v \\ 1\end{matrix}\right] = K [R | t] \left[ \begin{matrix}    P_0 + k\vec{v} \\ 1\end{matrix}\right]\]</span></p><p>消失点可以理解为空间直线无穷远处的点，即<spanclass="math inline">\(k\to \infty\)</span>，此时<spanclass="math inline">\(P_0\)</span>和下面的1都约等于0. 那么公式转为：</p><p><span class="math display">\[ \lambda \left[ \begin{matrix}    u \\ v \\ 1\end{matrix}\right] = K [R | t] \left[ \begin{matrix}    \vec{v} \\ 0\end{matrix}\right] = KR \vec{v}\]</span></p><p>现在来看如何进行标定。假设我们的世界坐标系建立在道路方向上，绕z,x,y的角分别为roll，pitch,yaw</p><center><img src="1.png" width="100%" height="100%" /></center><p>那么道路的方向<span class="math inline">\(\vec{v}\)</span>即为<spanclass="math inline">\((0,0,1)\)</span></p><p>得到</p><p><span class="math display">\[\lambda p = K R \left[ \begin{matrix}    0 \\ 0 \\ 1\end{matrix}\right] = KR_3 = K \left[ \begin{matrix}    -cos(pitch)sin(yaw) \\ sin(pitch) \\ cos(pitch)cos(yaw)\end{matrix}\right] \]</span></p><p>可以看到只留下了pitch,yaw角。说明消失点对于roll角是不可观的。</p><p>我们可以利用旋转矩阵正交性（列向量模为1）消去<spanclass="math inline">\(\lambda\)</span></p><p><span class="math display">\[\frac{K^{-1}p}{\|K^{-1}p\|} = \left[\begin{matrix}    -cos(pitch)sin(yaw) \\ sin(pitch) \\ cos(pitch)cos(yaw)\end{matrix}\right] \]</span></p><p>左边已知，可求出pitch和yaw</p><h3 id="用地平线估计roll角">用地平线估计roll角</h3><p>这里所指的地平线可以认为是地平面和与其平行的平面在无穷远处的交线。</p><p>一个简单的推导如下：假设相机坐标系下的三维消失线为<spanclass="math inline">\(l_\infty\)</span>,消失点为<spanclass="math inline">\(P_\infty\)</span>(都是齐次坐标系表示），那么有</p><p><span class="math display">\[P_\infty^T l_\infty = 0\]</span></p><p><span class="math display">\[P_\infty^T K^T K^{-T} l_\infty =0\]</span></p><p><span class="math display">\[(KP_\infty)^T K^{-T} l_\infty =0\]</span></p><p>而<span class="math inline">\(p_\infty = KP_\infty\)</span></p><p><span class="math display">\[(p_\infty)^T (K^{-T} l_\infty) =0\]</span></p><p>则<span class="math inline">\(l_{horizon} = K^{-T}l_\infty\)</span></p><p>因此有以下等式，其中g为重力向量，R为世界坐标系到相机坐标系的旋转，K为内参，h是地平线在图像上投影的直线的齐次坐标。</p><p><span class="math display">\[h\propto K^{-T}Rg\]</span></p><p>在上图的道路坐标系下，重力向量可以表示为<spanclass="math inline">\([0,1,0]\)</span>，</p><p><span class="math display">\[\left[\begin{matrix}    h_1 \\ h_2 \\ h_3\end{matrix}\right]=h\propto K^{-T}R_2\]</span></p><p>图像平面上地平线的倾斜角<span class="math inline">\(\theta =arctan(-\frac{h_1}{h_2})\)</span></p><h3 id="用多个消失点估计相机内外参">用多个消失点估计相机内外参</h3><h4id="用三个正交方向的消失点标定相机内外参">用三个正交方向的消失点标定相机内外参</h4><p><strong>求解内参：</strong></p><p>在符合Manhattan假设的环境中（通常是人造建筑物），画面中存在三个正交的方向，如下图所示：</p><center><img src="2.png" width="100%" height="100%" /></center><p>此时我们可以用图像上的三个消失点求解完整的相机内外侧。</p><p>我们把世界坐标系建在这个方向，那么这三个方向在世界坐标系下的方向可以定义为</p><p><span class="math display">\[e_1=\left[\begin{matrix}1 \\ 0 \\ 0\end{matrix}\right], e_2=\left[\begin{matrix}0 \\ 1 \\ 0\end{matrix}\right], e_3=\left[\begin{matrix}0 \\ 0 \\ 1\end{matrix}\right],\]</span></p><p>可以得到：</p><p><span class="math display">\[\lambda_i p_i = K R e_i\]</span></p><p><span class="math display">\[ e_i = \lambda R^T K^{-1}p_i\]</span></p><p>由 <span class="math inline">\(e_i^Te_j = 0\)</span>，可以得到：</p><p><span class="math display">\[ p_i^TK^{-T} R R^T K^{-1} p_j =p_i^TK^{-T} K^{-1} p_j = 0\]</span></p><p>这样两个消失点可以构建一个内参K的方程。</p><p>相机内参矩阵K可以表示为</p><p><span class="math display">\[ \left[ \begin{matrix}    f &amp; 0 &amp; c_x \\ 0 &amp; f &amp; c_y \\ 0 &amp; 0 &amp; 1\end{matrix}\right] \]</span></p><p>这样有3个参数，三个消失点两两配对有三组，可以建立3个方程，求出K</p><p>然而具体求解时消失点在图像平面上也可能是无穷远：</p><center><img src="3.png" width="100%" height="100%" /></center><p>第一种情况下相机坐标系和世界坐标系轴方向一致，两个消失点在图像平面上为无穷远，此时我们得到图像平面上一个有限的消失点，两个无穷远的消失点。此时只能标定光心距——有限的消失点位置<spanclass="math inline">\((u_0, v_0)\)</span>即为内参<spanclass="math inline">\(u_0, v_0\)</span>。</p><p><strong>求解外参旋转：</strong></p><p><span class="math display">\[\lambda_i p_i = K R e_i =KR_i\]</span></p><p>根据<span class="math inline">\(\|R_i\|=1\)</span>可以求出<spanclass="math inline">\(\lambda_i=\frac{1}{\|K^{-1}p_i\|}\)</span></p><p><span class="math display">\[ \left [ \begin{matrix}    \lambda_1 p_1 &amp; \lambda_2 p_2 &amp; \lambda_3 p_3\end{matrix} \right] = KR\]</span></p><p><span class="math display">\[ R = K^{-1}  \left [ \begin{matrix}    \lambda_1 p_1 &amp; \lambda_2 p_2 &amp; \lambda_3 p_3\end{matrix} \right] \]</span></p><h3 id="参考文献">参考文献</h3><p>[1] Temporally Consistent Horizon Lines</p><p>[2]https://www.cs.princeton.edu/courses/archive/fall13/cos429/lectures/11-epipolar</p>]]></content>
    
    
    <categories>
      
      <category>标定</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vins-mono论文与代码阅读（一）overview+feature_tracker</title>
    <link href="/2023/09/29/vinsmono%E8%AE%BA%E6%96%87%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB1/"/>
    <url>/2023/09/29/vinsmono%E8%AE%BA%E6%96%87%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB1/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>Vins mono是VIO方法中必读的经典，我在最初接触SLAM时就有简单阅读，但对其中一些细节一直不甚了解。视觉SLAM相比于激光更加复杂和难理解，这也是我在面试回答不出来的重灾区。这两天想用几篇文章对论文和代码做一个细节的，深入的学习。</p>          </div><h2 id="整体框架">整体框架</h2><p>首先看一下算法的整体框架。Vinsmono论文中的流程图如下：</p><center><img src="1.png" width="100%" height="100%" /></center><p>输入是相机(30Hz)和IMU(100Hz)</p><p>从代码角度，ROSlaunch文件启动了三个节点。相当于三个进程。每个进程有接收和发布的topic</p><table><thead><tr class="header"><th>节点</th><th>订阅topic</th><th>发布topic</th></tr></thead><tbody><tr class="odd"><td>feature_tracker</td><td>IMAGE_TOPIC</td><td>"feature", "feature_img"</td></tr><tr class="even"><td>vins_estimator</td><td>IMU_TOPIC, "/feature_tracker/feature", "/feature_tracker/restart","pose_graph/match_points"</td><td>"imu_propagate"</td></tr><tr class="odd"><td>pose_graph</td><td></td><td></td></tr></tbody></table><h2 id="feature_tracker">feature_tracker</h2><h3 id="overview">overview</h3><p>feature_tracker接收图片，发布检测到的特征点，标出特征点的图片（用于可视化）。</p><p>特征点的结构如下： <figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta"># ros message, 用于存储三维点</span><br><br><span class="hljs-meta"># 数据获取的时间, 坐标系的ID(str)</span><br><span class="hljs-built_in">Header</span> <span class="hljs-built_in">header</span> <br><br><span class="hljs-meta"># 三维点的array,二维点将最后一维写为1，vins中存的是去畸变的点的x,y</span><br>geometry_msgs/Point32[] points<br><br><span class="hljs-meta"># 点的额外信息。vins中加了点的id,未去畸变的u,v,光流法得到的像素速度</span><br>ChannelFloat32[] channels<br></code></pre></td></tr></table></figure></p><p>feature_tracker文件夹下的内容：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c">feature_tracker<br><span class="hljs-string">|- src</span><br>    <span class="hljs-string">|- feature_tracker.cpp</span><br>    <span class="hljs-string">|- feature_tracker.h</span><br>    <span class="hljs-string">|- feature_tracker_node.cpp</span><br>    <span class="hljs-string">|- parameters.cpp</span><br>    <span class="hljs-string">|- parameters.h</span><br></code></pre></td></tr></table></figure><p>主要三个源程序，feature_tracker_node(.cpp/.h)是特征跟踪线程的系统入口，feature_tracker(.cpp/.h)是特征跟踪算法的具体实现，parameters(.cpp/.h)是参数的读取和存放</p><h3 id="细节">细节</h3><p>feature_tracker_node.cpp： - int main() 函数为程序入口 - voidimg_callback()为ROS的回调函数，对每一帧图像消息进行特征点追踪，处理和发布。</p><p>我们从<strong>main()</strong>函数开始看：主要包括初始化；读入参数；订阅和发布。核心在于订阅原始图片信息，通过img_callback跟踪和检测特征点，再发布特征点.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;feature_tracker&quot;</span>); <span class="hljs-comment">// 初始化节点，节点名称为feature_tracker</span><br>    <span class="hljs-function">ros::NodeHandle <span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-string">&quot;~&quot;</span>)</span></span>; <span class="hljs-comment">// 创建节点句柄</span><br>    ros::console::<span class="hljs-built_in">set_logger_level</span>(ROSCONSOLE_DEFAULT_NAME, ros::console::levels::Info);<br><br>    <span class="hljs-comment">// 读入参数</span><br>    <span class="hljs-built_in">readParameters</span>(n); <span class="hljs-comment">// --1 这个函数定义在parameters.cpp中</span><br>    <span class="hljs-comment">// 读入内参</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_OF_CAM; i++)<br>        trackerData[i].<span class="hljs-built_in">readIntrinsicParameter</span>(CAM_NAMES[i]);<br>    <br>    <span class="hljs-comment">// --2 如果是鱼眼相机，就读入MASK</span><br>    <span class="hljs-keyword">if</span>(FISHEYE)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_OF_CAM; i++) <span class="hljs-comment">// NUM_OF_CAM是常量1</span><br>        &#123;<br>            trackerData[i].fisheye_mask = cv::<span class="hljs-built_in">imread</span>(FISHEYE_MASK, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span>(!trackerData[i].fisheye_mask.data)<br>            &#123;<br>                <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;load mask fail&quot;</span>);<br>                <span class="hljs-built_in">ROS_BREAK</span>();<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;load mask success&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 订阅原始图片信息，img_callback对图片进行处理</span><br>    ros::Subscriber sub_img = n.<span class="hljs-built_in">subscribe</span>(IMAGE_TOPIC, <span class="hljs-number">100</span>, img_callback);<br><br>    <span class="hljs-comment">// 发布检测跟踪的特征</span><br>    pub_img = n.<span class="hljs-built_in">advertise</span>&lt;sensor_msgs::PointCloud&gt;(<span class="hljs-string">&quot;feature&quot;</span>, <span class="hljs-number">1000</span>);<br><br>    <span class="hljs-comment">// 发布显示特征点的图片，用于可视化</span><br>    pub_match = n.<span class="hljs-built_in">advertise</span>&lt;sensor_msgs::Image&gt;(<span class="hljs-string">&quot;feature_img&quot;</span>,<span class="hljs-number">1000</span>);<br>    pub_restart = n.<span class="hljs-built_in">advertise</span>&lt;std_msgs::Bool&gt;(<span class="hljs-string">&quot;restart&quot;</span>,<span class="hljs-number">1000</span>);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    if (SHOW_TRACK)</span><br><span class="hljs-comment">        cv::namedWindow(&quot;vis&quot;, cv::WINDOW_NORMAL);</span><br><span class="hljs-comment">    */</span><br>    ros::<span class="hljs-built_in">spin</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么我们进一步来看img_callback函数是怎么做的：核心是对每个trackerData(feature_tracker类)调用了readImage函数，对图片进行处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">img_callback</span><span class="hljs-params">(<span class="hljs-type">const</span> sensor_msgs::ImageConstPtr &amp;img_msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(first_image_flag)<br>    &#123;<br>        first_image_flag = <span class="hljs-literal">false</span>;<br>        first_image_time = img_msg-&gt;header.stamp.<span class="hljs-built_in">toSec</span>();<br>        last_image_time = img_msg-&gt;header.stamp.<span class="hljs-built_in">toSec</span>();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果当前图片消息与前一帧图片消息的时间差不合理，就重置feature_tracker</span><br>    <span class="hljs-keyword">if</span> (img_msg-&gt;header.stamp.<span class="hljs-built_in">toSec</span>() - last_image_time &gt; <span class="hljs-number">1.0</span> || img_msg-&gt;header.stamp.<span class="hljs-built_in">toSec</span>() &lt; last_image_time)<br>    &#123;<br>        <span class="hljs-built_in">ROS_WARN</span>(<span class="hljs-string">&quot;image discontinue! reset the feature tracker!&quot;</span>);<br>        first_image_flag = <span class="hljs-literal">true</span>; <br>        last_image_time = <span class="hljs-number">0</span>;<br>        pub_count = <span class="hljs-number">1</span>;<br>        std_msgs::Bool restart_flag;<br>        restart_flag.data = <span class="hljs-literal">true</span>;<br>        pub_restart.<span class="hljs-built_in">publish</span>(restart_flag);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    last_image_time = img_msg-&gt;header.stamp.<span class="hljs-built_in">toSec</span>();<br><br>    <span class="hljs-comment">// 控制发布的帧频率和图片采集频率相近</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">round</span>(<span class="hljs-number">1.0</span> * pub_count / (img_msg-&gt;header.stamp.<span class="hljs-built_in">toSec</span>() - first_image_time)) &lt;= FREQ) <span class="hljs-comment">// FREQ是params中读入的图片频率</span><br>    &#123;<br>        PUB_THIS_FRAME = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 如果前面的频率和采集频率很接近，说明前面的频率没问题。可以从当前帧重新开始计算</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(<span class="hljs-number">1.0</span> * pub_count / (img_msg-&gt;header.stamp.<span class="hljs-built_in">toSec</span>() - first_image_time) - FREQ) &lt; <span class="hljs-number">0.01</span> * FREQ)<br>        &#123;<br>            first_image_time = img_msg-&gt;header.stamp.<span class="hljs-built_in">toSec</span>();<br>            pub_count = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        PUB_THIS_FRAME = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 把ROS消息中的Image转换为opencv的img</span><br>    cv_bridge::CvImageConstPtr ptr;<br>    <span class="hljs-keyword">if</span> (img_msg-&gt;encoding == <span class="hljs-string">&quot;8UC1&quot;</span>)<br>    &#123;<br>        sensor_msgs::Image img;<br>        img.header = img_msg-&gt;header;<br>        img.height = img_msg-&gt;height;<br>        img.width = img_msg-&gt;width;<br>        img.is_bigendian = img_msg-&gt;is_bigendian;<br>        img.step = img_msg-&gt;step;<br>        img.data = img_msg-&gt;data;<br>        img.encoding = <span class="hljs-string">&quot;mono8&quot;</span>;<br>        ptr = cv_bridge::<span class="hljs-built_in">toCvCopy</span>(img, sensor_msgs::image_encodings::MONO8);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        ptr = cv_bridge::<span class="hljs-built_in">toCvCopy</span>(img_msg, sensor_msgs::image_encodings::MONO8);<br><br>    cv::Mat show_img = ptr-&gt;image;<br>    TicToc t_r;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_OF_CAM; i++)<br>    &#123;<br>        <span class="hljs-built_in">ROS_DEBUG</span>(<span class="hljs-string">&quot;processing camera %d&quot;</span>, i);<br>        <span class="hljs-keyword">if</span> (i != <span class="hljs-number">1</span> || !STEREO_TRACK)<br>            trackerData[i].<span class="hljs-built_in">readImage</span>(ptr-&gt;image.<span class="hljs-built_in">rowRange</span>(ROW * i, ROW * (i + <span class="hljs-number">1</span>)), img_msg-&gt;header.stamp.<span class="hljs-built_in">toSec</span>());  <span class="hljs-comment">// 关键步骤：对图片进行特征跟踪和提取</span><br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (EQUALIZE)<br>            &#123;<br>                cv::Ptr&lt;cv::CLAHE&gt; clahe = cv::<span class="hljs-built_in">createCLAHE</span>();<br>                clahe-&gt;<span class="hljs-built_in">apply</span>(ptr-&gt;image.<span class="hljs-built_in">rowRange</span>(ROW * i, ROW * (i + <span class="hljs-number">1</span>)), trackerData[i].cur_img);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                trackerData[i].cur_img = ptr-&gt;image.<span class="hljs-built_in">rowRange</span>(ROW * i, ROW * (i + <span class="hljs-number">1</span>));<br>        &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> SHOW_UNDISTORTION</span><br>        trackerData[i].<span class="hljs-built_in">showUndistortion</span>(<span class="hljs-string">&quot;undistrotion_&quot;</span> + std::<span class="hljs-built_in">to_string</span>(i));<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;; i++)<br>    &#123;<br>        <span class="hljs-type">bool</span> completed = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; NUM_OF_CAM; j++)<br>            <span class="hljs-keyword">if</span> (j != <span class="hljs-number">1</span> || !STEREO_TRACK)<br>                completed |= trackerData[j].<span class="hljs-built_in">updateID</span>(i);<br>        <span class="hljs-keyword">if</span> (!completed)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 将特征点ID，位置，速度，封装成feature_point信息发布</span><br>    <span class="hljs-keyword">if</span> (PUB_THIS_FRAME)<br>    &#123;<br>        pub_count++;<br>        <span class="hljs-function">sensor_msgs::PointCloudPtr <span class="hljs-title">feature_points</span><span class="hljs-params">(<span class="hljs-keyword">new</span> sensor_msgs::PointCloud)</span></span>;<br>        sensor_msgs::ChannelFloat32 id_of_point;<br>        sensor_msgs::ChannelFloat32 u_of_point;<br>        sensor_msgs::ChannelFloat32 v_of_point;<br>        sensor_msgs::ChannelFloat32 velocity_x_of_point;<br>        sensor_msgs::ChannelFloat32 velocity_y_of_point;<br><br>        feature_points-&gt;header = img_msg-&gt;header;<br>        feature_points-&gt;header.frame_id = <span class="hljs-string">&quot;world&quot;</span>;<br><br>        vector&lt;set&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">hash_ids</span>(NUM_OF_CAM);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_OF_CAM; i++)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> &amp;un_pts = trackerData[i].cur_un_pts;<br>            <span class="hljs-keyword">auto</span> &amp;cur_pts = trackerData[i].cur_pts;<br>            <span class="hljs-keyword">auto</span> &amp;ids = trackerData[i].ids;<br>            <span class="hljs-keyword">auto</span> &amp;pts_velocity = trackerData[i].pts_velocity;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; ids.<span class="hljs-built_in">size</span>(); j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (trackerData[i].track_cnt[j] &gt; <span class="hljs-number">1</span>)<br>                &#123;<br>                    <span class="hljs-type">int</span> p_id = ids[j];<br>                    hash_ids[i].<span class="hljs-built_in">insert</span>(p_id);<br>                    geometry_msgs::Point32 p;<br>                    p.x = un_pts[j].x;<br>                    p.y = un_pts[j].y;<br>                    p.z = <span class="hljs-number">1</span>;<br><br>                    feature_points-&gt;points.<span class="hljs-built_in">push_back</span>(p);<br>                    id_of_point.values.<span class="hljs-built_in">push_back</span>(p_id * NUM_OF_CAM + i);<br>                    u_of_point.values.<span class="hljs-built_in">push_back</span>(cur_pts[j].x);<br>                    v_of_point.values.<span class="hljs-built_in">push_back</span>(cur_pts[j].y);<br>                    velocity_x_of_point.values.<span class="hljs-built_in">push_back</span>(pts_velocity[j].x);<br>                    velocity_y_of_point.values.<span class="hljs-built_in">push_back</span>(pts_velocity[j].y);<br>                &#125;<br>            &#125;<br>        &#125;<br>        feature_points-&gt;channels.<span class="hljs-built_in">push_back</span>(id_of_point);<br>        feature_points-&gt;channels.<span class="hljs-built_in">push_back</span>(u_of_point);<br>        feature_points-&gt;channels.<span class="hljs-built_in">push_back</span>(v_of_point);<br>        feature_points-&gt;channels.<span class="hljs-built_in">push_back</span>(velocity_x_of_point);<br>        feature_points-&gt;channels.<span class="hljs-built_in">push_back</span>(velocity_y_of_point);<br>        <span class="hljs-built_in">ROS_DEBUG</span>(<span class="hljs-string">&quot;publish %f, at %f&quot;</span>, feature_points-&gt;header.stamp.<span class="hljs-built_in">toSec</span>(), ros::Time::<span class="hljs-built_in">now</span>().<span class="hljs-built_in">toSec</span>());<br>        <span class="hljs-comment">// skip the first image; since no optical speed on frist image</span><br>        <span class="hljs-keyword">if</span> (!init_pub)<br>        &#123;<br>            init_pub = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            pub_img.<span class="hljs-built_in">publish</span>(feature_points);<br><br>        <span class="hljs-keyword">if</span> (SHOW_TRACK)<br>        &#123;<br>            ptr = cv_bridge::<span class="hljs-built_in">cvtColor</span>(ptr, sensor_msgs::image_encodings::BGR8);<br>            <span class="hljs-comment">//cv::Mat stereo_img(ROW * NUM_OF_CAM, COL, CV_8UC3);</span><br>            cv::Mat stereo_img = ptr-&gt;image;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_OF_CAM; i++)<br>            &#123;<br>                cv::Mat tmp_img = stereo_img.<span class="hljs-built_in">rowRange</span>(i * ROW, (i + <span class="hljs-number">1</span>) * ROW);<br>                cv::<span class="hljs-built_in">cvtColor</span>(show_img, tmp_img, CV_GRAY2RGB);<br><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; trackerData[i].cur_pts.<span class="hljs-built_in">size</span>(); j++)<br>                &#123;<br>                    <span class="hljs-type">double</span> len = std::<span class="hljs-built_in">min</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span> * trackerData[i].track_cnt[j] / WINDOW_SIZE);<br>                    cv::<span class="hljs-built_in">circle</span>(tmp_img, trackerData[i].cur_pts[j], <span class="hljs-number">2</span>, cv::<span class="hljs-built_in">Scalar</span>(<span class="hljs-number">255</span> * (<span class="hljs-number">1</span> - len), <span class="hljs-number">0</span>, <span class="hljs-number">255</span> * len), <span class="hljs-number">2</span>);<br>                    <span class="hljs-comment">//draw speed line</span><br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                    Vector2d tmp_cur_un_pts (trackerData[i].cur_un_pts[j].x, trackerData[i].cur_un_pts[j].y);</span><br><span class="hljs-comment">                    Vector2d tmp_pts_velocity (trackerData[i].pts_velocity[j].x, trackerData[i].pts_velocity[j].y);</span><br><span class="hljs-comment">                    Vector3d tmp_prev_un_pts;</span><br><span class="hljs-comment">                    tmp_prev_un_pts.head(2) = tmp_cur_un_pts - 0.10 * tmp_pts_velocity;</span><br><span class="hljs-comment">                    tmp_prev_un_pts.z() = 1;</span><br><span class="hljs-comment">                    Vector2d tmp_prev_uv;</span><br><span class="hljs-comment">                    trackerData[i].m_camera-&gt;spaceToPlane(tmp_prev_un_pts, tmp_prev_uv);</span><br><span class="hljs-comment">                    cv::line(tmp_img, trackerData[i].cur_pts[j], cv::Point2f(tmp_prev_uv.x(), tmp_prev_uv.y()), cv::Scalar(255 , 0, 0), 1 , 8, 0);</span><br><span class="hljs-comment">                    */</span><br>                    <span class="hljs-comment">//char name[10];</span><br>                    <span class="hljs-comment">//sprintf(name, &quot;%d&quot;, trackerData[i].ids[j]);</span><br>                    <span class="hljs-comment">//cv::putText(tmp_img, name, trackerData[i].cur_pts[j], cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 0));</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//cv::imshow(&quot;vis&quot;, stereo_img);</span><br>            <span class="hljs-comment">//cv::waitKey(5);</span><br>            pub_match.<span class="hljs-built_in">publish</span>(ptr-&gt;<span class="hljs-built_in">toImageMsg</span>());<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;whole feature tracker processing costs: %f&quot;</span>, t_r.<span class="hljs-built_in">toc</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="readimage">readImage</h5><p>输入的是图片(cv::Mat)，和当前图片的时间戳</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FeatureTracker::readImage</span><span class="hljs-params">(<span class="hljs-type">const</span> cv::Mat &amp;_img, <span class="hljs-type">double</span> _cur_time)</span></span><br><span class="hljs-function"></span>&#123;<br>    cv::Mat img;<br>    TicToc t_r;<br>    cur_time = _cur_time;<br><br>    <span class="hljs-comment">// 是否做直方图均衡化。该参数用于在图片本身过亮或过暗时，用直方图均衡化进行调整，提高图片对比度</span><br>    <span class="hljs-keyword">if</span> (EQUALIZE)<br>    &#123;<br>        cv::Ptr&lt;cv::CLAHE&gt; clahe = cv::<span class="hljs-built_in">createCLAHE</span>(<span class="hljs-number">3.0</span>, cv::<span class="hljs-built_in">Size</span>(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>));<br>        TicToc t_c;<br>        clahe-&gt;<span class="hljs-built_in">apply</span>(_img, img);<br>        <span class="hljs-built_in">ROS_DEBUG</span>(<span class="hljs-string">&quot;CLAHE costs: %fms&quot;</span>, t_c.<span class="hljs-built_in">toc</span>());<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        img = _img;<br><br>    <span class="hljs-keyword">if</span> (forw_img.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        prev_img = cur_img = forw_img = img;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        forw_img = img;<br>    &#125;<br><br>    <span class="hljs-comment">// forw_pts 下一帧跟踪的特征点</span><br>    forw_pts.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-comment">// cur_pts 当前跟踪的特征点</span><br>    <span class="hljs-keyword">if</span> (cur_pts.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        TicToc t_o;<br>        vector&lt;uchar&gt; status;<br>        vector&lt;<span class="hljs-type">float</span>&gt; err;<br>        cv::<span class="hljs-built_in">calcOpticalFlowPyrLK</span>(cur_img, forw_img, cur_pts, forw_pts, status, err, cv::<span class="hljs-built_in">Size</span>(<span class="hljs-number">21</span>, <span class="hljs-number">21</span>), <span class="hljs-number">3</span>); <span class="hljs-comment">// --1 LK光流进行特征跟踪</span><br><br>        <span class="hljs-comment">// 如果一个特征位置变到了图像外面，就将其状态设置为无效</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">int</span>(forw_pts.<span class="hljs-built_in">size</span>()); i++)<br>            <span class="hljs-keyword">if</span> (status[i] &amp;&amp; !<span class="hljs-built_in">inBorder</span>(forw_pts[i]))<br>                status[i] = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 把status[i] = 0的特征点删除</span><br>        <span class="hljs-built_in">reduceVector</span>(prev_pts, status);<br>        <span class="hljs-built_in">reduceVector</span>(cur_pts, status);<br>        <span class="hljs-built_in">reduceVector</span>(forw_pts, status);<br>        <span class="hljs-built_in">reduceVector</span>(ids, status);<br>        <span class="hljs-built_in">reduceVector</span>(cur_un_pts, status);<br>        <span class="hljs-built_in">reduceVector</span>(track_cnt, status);<br>        <span class="hljs-built_in">ROS_DEBUG</span>(<span class="hljs-string">&quot;temporal optical flow costs: %fms&quot;</span>, t_o.<span class="hljs-built_in">toc</span>());<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;n : track_cnt)<br>        n++;<br><br>    <span class="hljs-keyword">if</span> (PUB_THIS_FRAME)<br>    &#123;<br>        <span class="hljs-built_in">rejectWithF</span>(); <span class="hljs-comment">// 用F矩阵剔除外点</span><br>        <span class="hljs-built_in">ROS_DEBUG</span>(<span class="hljs-string">&quot;set mask begins&quot;</span>);<br>        TicToc t_m;<br>        <span class="hljs-built_in">setMask</span>(); <span class="hljs-comment">// 对跟踪点排序，取出现次数多的位置，去除密集区域</span><br>        <span class="hljs-built_in">ROS_DEBUG</span>(<span class="hljs-string">&quot;set mask costs %fms&quot;</span>, t_m.<span class="hljs-built_in">toc</span>());<br><br>        <span class="hljs-built_in">ROS_DEBUG</span>(<span class="hljs-string">&quot;detect feature begins&quot;</span>);<br>        TicToc <span class="hljs-type">t_t</span>;<br>        <span class="hljs-type">int</span> n_max_cnt = MAX_CNT - <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(forw_pts.<span class="hljs-built_in">size</span>());<br>        <span class="hljs-keyword">if</span> (n_max_cnt &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(mask.<span class="hljs-built_in">empty</span>())<br>                cout &lt;&lt; <span class="hljs-string">&quot;mask is empty &quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">if</span> (mask.<span class="hljs-built_in">type</span>() != CV_8UC1)<br>                cout &lt;&lt; <span class="hljs-string">&quot;mask type wrong &quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">if</span> (mask.<span class="hljs-built_in">size</span>() != forw_img.<span class="hljs-built_in">size</span>())<br>                cout &lt;&lt; <span class="hljs-string">&quot;wrong size &quot;</span> &lt;&lt; endl;<br>            cv::<span class="hljs-built_in">goodFeaturesToTrack</span>(forw_img, n_pts, MAX_CNT - forw_pts.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0.01</span>, MIN_DIST, mask); <span class="hljs-comment">// 当特征点数不足时，重新检测角点补足</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            n_pts.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">ROS_DEBUG</span>(<span class="hljs-string">&quot;detect feature costs: %fms&quot;</span>, <span class="hljs-type">t_t</span>.<span class="hljs-built_in">toc</span>());<br><br>        <span class="hljs-built_in">ROS_DEBUG</span>(<span class="hljs-string">&quot;add feature begins&quot;</span>);<br>        TicToc t_a;<br>        <span class="hljs-built_in">addPoints</span>(); <span class="hljs-comment">// 把新检测的特征点加入forw_pts</span><br>        <span class="hljs-built_in">ROS_DEBUG</span>(<span class="hljs-string">&quot;selectFeature costs: %fms&quot;</span>, t_a.<span class="hljs-built_in">toc</span>());<br>    &#125;<br>    prev_img = cur_img;<br>    prev_pts = cur_pts;<br>    prev_un_pts = cur_un_pts;<br>    cur_img = forw_img;<br>    cur_pts = forw_pts; <span class="hljs-comment">// 把检测到的特征点都赋值给cur_pts</span><br>    <span class="hljs-built_in">undistortedPoints</span>(); <span class="hljs-comment">// 去畸变</span><br>    prev_time = cur_time;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="重点解析">重点解析</h5><ol type="1"><li><p>LK光流跟踪：</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">cv::<span class="hljs-built_in">calcOpticalFlowPyrLK</span>(cur_img, forw_img, cur_pts, forw_pts, status, err, cv::<span class="hljs-built_in">Size</span>(<span class="hljs-number">21</span>, <span class="hljs-number">21</span>), <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure></p><ul><li><code>cur_img(cv::Mat)</code>: 输入前一帧图片</li><li><code>forw_img(cv::Mat)</code>: 输入需要跟踪特征的一帧图片</li><li><code>cur_pts(vector&lt;cv::Point2f&gt;)</code>:输入前一帧图片上的特征点</li><li><code>forw_pts(vector&lt;cv::Point2f&gt;)</code>:输出当前一帧图片上的特征点</li><li><code>status(unsigned char)</code>:输出状态向量，如果在当前图像中能够光流得到标定的特征点位置改变，则设置status的对应位置为1，否则设置为0</li></ul></li><li><p>通过基本矩阵剔除外点 rejectWithF()</p><p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void FeatureTracker::reject<span class="hljs-constructor">WithF()</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (forw_pts.size<span class="hljs-literal">()</span> &gt;= <span class="hljs-number">8</span>)<span class="hljs-comment">// 当前帧（追踪上）特征点数量足够多</span><br>    &#123;<br>        <span class="hljs-constructor">ROS_DEBUG(<span class="hljs-string">&quot;FM ransac begins&quot;</span>)</span>;<br>        TicToc t_f;<br>        vector&lt;cv::Point2f&gt; un<span class="hljs-constructor">_cur_pts(<span class="hljs-params">cur_pts</span>.<span class="hljs-params">size</span>()</span>), un<span class="hljs-constructor">_forw_pts(<span class="hljs-params">forw_pts</span>.<span class="hljs-params">size</span>()</span>);<br>        <span class="hljs-keyword">for</span> (unsigned <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; cur_pts.size<span class="hljs-literal">()</span>; i++)<span class="hljs-comment">//遍历上一帧所有特征点</span><br>        &#123;<br><br>            Eigen::Vector3d tmp_p;<br>            <span class="hljs-comment">//将当前帧的特征点和上一帧的特征点用反投影去除畸变</span><br>            m_camera-&gt;lift<span class="hljs-constructor">Projective(Eigen::Vector2d(<span class="hljs-params">cur_pts</span>[<span class="hljs-params">i</span>].<span class="hljs-params">x</span>, <span class="hljs-params">cur_pts</span>[<span class="hljs-params">i</span>].<span class="hljs-params">y</span>)</span>, tmp_p);<br>            tmp_p.x<span class="hljs-literal">()</span> = FOCAL_LENGTH<span class="hljs-operator"> * </span>tmp_p.x<span class="hljs-literal">()</span><span class="hljs-operator"> / </span>tmp_p.z<span class="hljs-literal">()</span> + COL<span class="hljs-operator"> / </span><span class="hljs-number">2.0</span>;<br>            tmp_p.y<span class="hljs-literal">()</span> = FOCAL_LENGTH<span class="hljs-operator"> * </span>tmp_p.y<span class="hljs-literal">()</span><span class="hljs-operator"> / </span>tmp_p.z<span class="hljs-literal">()</span> + ROW<span class="hljs-operator"> / </span><span class="hljs-number">2.0</span>;<br>            un_cur_pts<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = cv::<span class="hljs-constructor">Point2f(<span class="hljs-params">tmp_p</span>.<span class="hljs-params">x</span>()</span>, tmp_p.y<span class="hljs-literal">()</span>);<br><br>            m_camera-&gt;lift<span class="hljs-constructor">Projective(Eigen::Vector2d(<span class="hljs-params">forw_pts</span>[<span class="hljs-params">i</span>].<span class="hljs-params">x</span>, <span class="hljs-params">forw_pts</span>[<span class="hljs-params">i</span>].<span class="hljs-params">y</span>)</span>, tmp_p);<br>            tmp_p.x<span class="hljs-literal">()</span> = FOCAL_LENGTH<span class="hljs-operator"> * </span>tmp_p.x<span class="hljs-literal">()</span><span class="hljs-operator"> / </span>tmp_p.z<span class="hljs-literal">()</span> + COL<span class="hljs-operator"> / </span><span class="hljs-number">2.0</span>;<br>            tmp_p.y<span class="hljs-literal">()</span> = FOCAL_LENGTH<span class="hljs-operator"> * </span>tmp_p.y<span class="hljs-literal">()</span><span class="hljs-operator"> / </span>tmp_p.z<span class="hljs-literal">()</span> + ROW<span class="hljs-operator"> / </span><span class="hljs-number">2.0</span>;<br>            un_forw_pts<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = cv::<span class="hljs-constructor">Point2f(<span class="hljs-params">tmp_p</span>.<span class="hljs-params">x</span>()</span>, tmp_p.y<span class="hljs-literal">()</span>);<br>        &#125;<br><br>        vector&lt;uchar&gt; status;<br>        <span class="hljs-comment">// 2. 调用cv::findFundamentalMat对un_cur_pts和un_forw_pts计算F矩阵，需要归一化相机系，z=1</span><br>        cv::find<span class="hljs-constructor">FundamentalMat(<span class="hljs-params">un_cur_pts</span>, <span class="hljs-params">un_forw_pts</span>, <span class="hljs-params">cv</span>::FM_RANSAC, F_THRESHOLD, 0.99, <span class="hljs-params">status</span>)</span>;<br>        <span class="hljs-built_in">int</span> size_a = cur_pts.size<span class="hljs-literal">()</span>;<br>        <span class="hljs-comment">// 3. 根据status删除一些特征点</span><br>        reduce<span class="hljs-constructor">Vector(<span class="hljs-params">prev_pts</span>, <span class="hljs-params">status</span>)</span>;<br>        reduce<span class="hljs-constructor">Vector(<span class="hljs-params">cur_pts</span>, <span class="hljs-params">status</span>)</span>;<br>        reduce<span class="hljs-constructor">Vector(<span class="hljs-params">forw_pts</span>, <span class="hljs-params">status</span>)</span>;<br>        reduce<span class="hljs-constructor">Vector(<span class="hljs-params">cur_un_pts</span>, <span class="hljs-params">status</span>)</span>;<br>        reduce<span class="hljs-constructor">Vector(<span class="hljs-params">ids</span>, <span class="hljs-params">status</span>)</span>;<br>        reduce<span class="hljs-constructor">Vector(<span class="hljs-params">track_cnt</span>, <span class="hljs-params">status</span>)</span>;<br>        <span class="hljs-constructor">ROS_DEBUG(<span class="hljs-string">&quot;FM ransac: %d -&gt; %lu: %f&quot;</span>, <span class="hljs-params">size_a</span>, <span class="hljs-params">forw_pts</span>.<span class="hljs-params">size</span>()</span>, <span class="hljs-number">1.0</span><span class="hljs-operator"> * </span>forw_pts.size<span class="hljs-literal">()</span><span class="hljs-operator"> / </span>size_a);<br>        <span class="hljs-constructor">ROS_DEBUG(<span class="hljs-string">&quot;FM ransac costs: %fms&quot;</span>, <span class="hljs-params">t_f</span>.<span class="hljs-params">toc</span>()</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>cv::findFundamentalMat从两幅图像的多个对应点计算基本矩阵。可以输出一个mask (仅在 RANSAC 和LMedS方法中计算)，维度和点个数一样，表示点根据估计的F是否异常。</p></li><li><p>对跟踪点排序，选择出现次数多的点，去除密集点 setMask()</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FeatureTracker::setMask</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 如果是鱼眼镜头直接clone即可，否则创建空白mask</span><br>    <span class="hljs-keyword">if</span>(FISHEYE)<br>        mask = fisheye_mask.<span class="hljs-built_in">clone</span>();<br>    <span class="hljs-keyword">else</span><br>        mask = cv::<span class="hljs-built_in">Mat</span>(ROW, COL, CV_8UC1, cv::<span class="hljs-built_in">Scalar</span>(<span class="hljs-number">255</span>));<span class="hljs-comment">// 空白mask都是255</span><br>    <br>    <span class="hljs-comment">// 倾向于留下被追踪时间很长的特征点</span><br>    <span class="hljs-comment">// 构造(cnt，pts，id)序列，（追踪次数，当前特征点坐标，id）</span><br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, pair&lt;cv::Point2f, <span class="hljs-type">int</span>&gt;&gt;&gt; cnt_pts_id;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; forw_pts.<span class="hljs-built_in">size</span>(); i++)<br>        cnt_pts_id.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(track_cnt[i], <span class="hljs-built_in">make_pair</span>(forw_pts[i], ids[i])));<br><br>    <span class="hljs-comment">// 对光流跟踪到的特征点forw_pts，按照被跟踪到的次数cnt从大到小排序（lambda表达式）</span><br>    <span class="hljs-built_in">sort</span>(cnt_pts_id.<span class="hljs-built_in">begin</span>(), cnt_pts_id.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, pair&lt;cv::Point2f, <span class="hljs-type">int</span>&gt;&gt; &amp;a, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, pair&lt;cv::Point2f, <span class="hljs-type">int</span>&gt;&gt; &amp;b)<br>        &#123;<br>            <span class="hljs-keyword">return</span> a.first &gt; b.first;<span class="hljs-comment">// a.first指的追踪次数track_cnt</span><br>        &#125;);<br><br>    <span class="hljs-comment">//清空cnt，pts，id并重新存入</span><br>    forw_pts.<span class="hljs-built_in">clear</span>();<br>    ids.<span class="hljs-built_in">clear</span>();<br>    track_cnt.<span class="hljs-built_in">clear</span>();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;it : cnt_pts_id)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (mask.<span class="hljs-built_in">at</span>&lt;uchar&gt;(it.second.first) == <span class="hljs-number">255</span>)<span class="hljs-comment">// 这个特征点对应的mask值为255，表明该位置可以作为特征点</span><br>        &#123;<br>            <span class="hljs-comment">//将对应的特征点位置pts，id，被追踪次数cnt分别存入</span><br>            forw_pts.<span class="hljs-built_in">push_back</span>(it.second.first);<br>            ids.<span class="hljs-built_in">push_back</span>(it.second.second);<br>            track_cnt.<span class="hljs-built_in">push_back</span>(it.first);<br><br>            <span class="hljs-comment">//在mask中将当前特征点周围半径为MIN_DIST的区域设置为0，后面不再选取该区域内的点（使跟踪点不集中在一个区域上）</span><br>            cv::<span class="hljs-built_in">circle</span>(mask, it.second.first, MIN_DIST, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></p></li><li><p>角点检测</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cv::goodFeaturesToTrack</span><span class="hljs-params">(forw_img, n_pts, n_max_cnt, <span class="hljs-number">0.01</span>, MIN_DIST, mask)</span></span>;<br></code></pre></td></tr></table></figure></p><ul><li>forw_img(cv::InputArray image): 输入图像</li><li>n_pts(vector<cv::Point2f>): 输出角点</li><li>n_max_cnt(int): 检测角点数量</li><li>0.01: 质量水平系数</li><li>MIN_DIST: 特征点之间的最小距离</li><li>mask: mask的点忽略，因此不会再找到已经跟踪的点</li></ul></li><li><p>去畸变undistortedPoints()</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FeatureTracker::undistortedPoints</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cur_un_pts.<span class="hljs-built_in">clear</span>();<br>    cur_un_pts_map.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-comment">//cv::undistortPoints(cur_pts, un_pts, K, cv::Mat());</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cur_pts.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-function">Eigen::Vector2d <span class="hljs-title">a</span><span class="hljs-params">(cur_pts[i].x, cur_pts[i].y)</span></span>;<br>        Eigen::Vector3d b;<br>        m_camera-&gt;<span class="hljs-built_in">liftProjective</span>(a, b); <span class="hljs-comment">// 把点从图形平面去除畸变移到归一化平面</span><br>        cur_un_pts.<span class="hljs-built_in">push_back</span>(cv::<span class="hljs-built_in">Point2f</span>(b.<span class="hljs-built_in">x</span>() / b.<span class="hljs-built_in">z</span>(), b.<span class="hljs-built_in">y</span>() / b.<span class="hljs-built_in">z</span>()));<br>        cur_un_pts_map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(ids[i], cv::<span class="hljs-built_in">Point2f</span>(b.<span class="hljs-built_in">x</span>() / b.<span class="hljs-built_in">z</span>(), b.<span class="hljs-built_in">y</span>() / b.<span class="hljs-built_in">z</span>())));<br>        <span class="hljs-comment">//printf(&quot;cur pts id %d %f %f&quot;, ids[i], cur_un_pts[i].x, cur_un_pts[i].y);</span><br>    &#125;<br>    <span class="hljs-comment">// pts_velocity 计算每个像素点的速度</span><br>    <span class="hljs-keyword">if</span> (!prev_un_pts_map.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">double</span> dt = cur_time - prev_time;<br>        pts_velocity.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cur_un_pts.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (ids[i] != <span class="hljs-number">-1</span>)<br>            &#123;<br>                std::map&lt;<span class="hljs-type">int</span>, cv::Point2f&gt;::iterator it;<br>                it = prev_un_pts_map.<span class="hljs-built_in">find</span>(ids[i]);<br>                <span class="hljs-keyword">if</span> (it != prev_un_pts_map.<span class="hljs-built_in">end</span>())<br>                &#123;<br>                    <span class="hljs-type">double</span> v_x = (cur_un_pts[i].x - it-&gt;second.x) / dt;<br>                    <span class="hljs-type">double</span> v_y = (cur_un_pts[i].y - it-&gt;second.y) / dt;<br>                    pts_velocity.<span class="hljs-built_in">push_back</span>(cv::<span class="hljs-built_in">Point2f</span>(v_x, v_y));<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                    pts_velocity.<span class="hljs-built_in">push_back</span>(cv::<span class="hljs-built_in">Point2f</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                pts_velocity.<span class="hljs-built_in">push_back</span>(cv::<span class="hljs-built_in">Point2f</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cur_pts.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            pts_velocity.<span class="hljs-built_in">push_back</span>(cv::<span class="hljs-built_in">Point2f</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>        &#125;<br>    &#125;<br>    prev_un_pts_map = cur_un_pts_map;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>listProjective() 把像素坐标转换为无畸变的归一化坐标：</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Eigen::Vector2d <span class="hljs-title">a</span><span class="hljs-params">(cur_pts[i].x, cur_pts[i].y)</span></span>;<br>Eigen::Vector3d b;<br>m_camera-&gt;<span class="hljs-built_in">liftProjective</span>(a, b);<br></code></pre></td></tr></table></figure> 参考https://blog.csdn.net/hltt3838/article/details/119428558</p><p>相当于从图形坐标系，用内参和畸变系数转换到归一化相机投影平面上，由于畸变的计算公式，这个去畸变是一个不断迭代的过程。opencv中undistPoints()也是实现同样功能。</p></li><li><p>发布信息</p></li></ol><p>输出三个topic</p><p>feature_img: 用于rviz显示跟踪到的特征点</p><p>feature: 跟踪到的特征信息</p><p>restart: 跟踪失败的复位信号</p>]]></content>
    
    
    <categories>
      
      <category>SLAM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2024秋招速腾聚创笔试记录(2023.9.4)</title>
    <link href="/2023/09/28/%E9%80%9F%E8%85%BE%E8%81%9A%E5%88%9B%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/09/28/%E9%80%9F%E8%85%BE%E8%81%9A%E5%88%9B%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="编程题">编程题</h3><h4 id="跳跃游戏">跳跃游戏</h4><p>https://leetcode.cn/problems/jump-game/</p><h4 id="迷宫找最短路径">迷宫找最短路径</h4><p>https://blog.csdn.net/weixin_46846304/article/details/116125437</p><h3 id="问答题">问答题</h3><h4 id="手写点云欧式聚类">1 手写点云欧式聚类</h4><p>写一个函数实现点云欧式聚类，类内最大距离为ClusterTolerance，类内最少点数为MinClusterSize</p><p>点和点云的结构： <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>&#123;<br>    <span class="hljs-type">double</span> x;<br>    <span class="hljs-type">double</span> y;<br>    <span class="hljs-type">double</span> z;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PointCloud</span>&#123;<br>    std::vector&lt;Point&gt; points;<br>    <span class="hljs-type">int</span> size;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>参考pcl中欧式聚类的方法：</p><p>(1)先把点云存成kd-tree</p><p>(2)初始化一个空类cluster，和一个空队列Q</p><p>(3)取一个未分类的点加入队列。</p><p>(4)推出队列的第一个点加入类，找所有离这个点距离小于d且未处理过的点加入队列。重复直到队列为空</p><p>(5)判断cluster的点数是否足够。足够则保留这个类。返回第（2）步</p><p>(6)直到所有点都处理过后结束。</p><h4 id="求两个坐标系的旋转矩阵">2 求两个坐标系的旋转矩阵</h4><p>A坐标系x轴朝上，y轴向前，z轴朝左。B坐标系x轴向前，y轴向左，z轴朝上。求A坐标系到B坐标系的旋转矩阵。</p><img src="/2023/09/28/%E9%80%9F%E8%85%BE%E8%81%9A%E5%88%9B%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/1.png" class="" title="fig:1"><p>首先注意到坐标系是左手坐标系，因此旋转的正方向可以用左手判断。从A到B相当于绕z轴转90度，再绕x轴转90度</p><p><span class="math display">\[R = R(Z)R(Y)R(X) = \left[ \begin{matrix}0&amp; 1&amp; 0 \\ -1&amp; 0 &amp; 0 \\ 0&amp; 0&amp; 1\end{matrix}\right] \left[ \begin{matrix} 1&amp; 0&amp; 0 \\ 0&amp; 0&amp; 1 \\ 0&amp; -1&amp; 0\ \end{matrix}\right] \]</span></p><h4 id="拟合平面方程">3 拟合平面方程</h4><p>已知n个点<spanclass="math inline">\(P_i,i=0,1,...,n-1\)</span>，坐标为<spanclass="math inline">\((x_i, y_i,z_i)\)</span>。拟合成平面Ax+By+Cz+D=0.</p><p>（1）求最小二乘解的函数形式</p><p><spanclass="math display">\[f=\sum_{i=0}^n(Ax_i+By_i+Cz_i+D)^2\]</span></p><p>（2）求平面的最小二乘解</p><p>令<span class="math inline">\(f&#39;_A=0, f&#39;_B=0, f&#39;_C=0,f&#39;_D=0\)</span>，解方程，具体形式在此处不推导了</p><p>（3）若求出平面为Ax+By+Cz+D=0，如何计算该平面与z=(0,0,1)方向的旋转</p><p>平面法向量为<span class="math inline">\(\vec{p}=(A,B,C)\)</span></p><p><span class="math display">\[\vec{n} = \vec{z} \times\vec{p}  \]</span> <span class="math display">\[R = cos\theta +(1-cos(\theta)\vec{n}\vec{n}^T)+sin\theta n^\wedge\]</span></p>]]></content>
    
    
    <categories>
      
      <category>2024秋招</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LOAM论文与代码阅读（三）IMU运动补偿相关代码</title>
    <link href="/2023/09/23/LOAM%E8%AE%BA%E6%96%87%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB3/"/>
    <url>/2023/09/23/LOAM%E8%AE%BA%E6%96%87%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB3/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>LOAM代码中使用的是IMU进行运动补偿。这部分在思想上比较简单，即用IMU积分得到各个点相对开始时刻的位姿。但实际上涉及一些坐标系转换，积分，时间戳问题，因此对代码进一步阅读。</p>          </div><h3 id="imu数据处理">IMU数据处理</h3><p>对于发布的IMU消息，首先还原加速度，然后利用加速度积分得到当前imu的速度，位置，而姿态可以直接使用，存成IMUState，加入队列。</p><p><font color=gray>IMU设置后一般可以直接输出四元数，由加速度积分得到。但不会输出速度，因为加速度不准，积分很容易发散。</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 传入IMU消息</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ScanRegistration::handleIMUMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> sensor_msgs::Imu::ConstPtr&amp; imuIn)</span> <span class="hljs-comment">// imuIn的结构--1</span></span><br><span class="hljs-function"></span>&#123;<br>  tf::Quaternion orientation;<br>  tf::<span class="hljs-built_in">quaternionMsgToTF</span>(imuIn-&gt;orientation, orientation);<br>  <span class="hljs-type">double</span> roll, pitch, yaw;<br>  tf::<span class="hljs-built_in">Matrix3x3</span>(orientation).<span class="hljs-built_in">getRPY</span>(roll, pitch, yaw); <span class="hljs-comment">//将IMU的姿态转roll,pitch,yaw</span><br><br>  Vector3 acc;<br>  acc.<span class="hljs-built_in">x</span>() = <span class="hljs-built_in">float</span>(imuIn-&gt;linear_acceleration.y - <span class="hljs-built_in">sin</span>(roll) * <span class="hljs-built_in">cos</span>(pitch) * <span class="hljs-number">9.81</span>);<br>  acc.<span class="hljs-built_in">y</span>() = <span class="hljs-built_in">float</span>(imuIn-&gt;linear_acceleration.z - <span class="hljs-built_in">cos</span>(roll) * <span class="hljs-built_in">cos</span>(pitch) * <span class="hljs-number">9.81</span>);<br>  acc.<span class="hljs-built_in">z</span>() = <span class="hljs-built_in">float</span>(imuIn-&gt;linear_acceleration.x + <span class="hljs-built_in">sin</span>(pitch)             * <span class="hljs-number">9.81</span>); <span class="hljs-comment">//减去重力得到真实的加速度--2</span><br><br>  IMUState newState; <span class="hljs-comment">// IMUState的结构--3</span><br>  newState.stamp = <span class="hljs-built_in">fromROSTime</span>( imuIn-&gt;header.stamp);<br>  newState.roll = roll;<br>  newState.pitch = pitch;<br>  newState.yaw = yaw;<br>  newState.acceleration = acc;<br><br>  <span class="hljs-built_in">updateIMUData</span>(acc, newState); <span class="hljs-comment">// 将新的IMU状态更新到全局信息中--4</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="imu消息的结构">1 imu消息的结构</h4><p>ROS中<code>sensor_msgs::Imu</code>的定义：包含一个四元数表示姿态，角速度和加速度为三维向量</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-type">Header</span> header<br><br>geometry_msgs/<span class="hljs-type">Quaternion</span> orientation<br><span class="hljs-type">float64</span>[<span class="hljs-number">9</span>] orientation_covariance <span class="hljs-comment"># Row major about x, y, z axes</span><br><br>geometry_msgs/<span class="hljs-type">Vector3</span> angular_velocity<br><span class="hljs-type">float64</span>[<span class="hljs-number">9</span>] angular_velocity_covariance <span class="hljs-comment"># Row major about x, y, z axes</span><br><br>geometry_msgs/<span class="hljs-type">Vector3</span> linear_acceleration<br><span class="hljs-type">float64</span>[<span class="hljs-number">9</span>] linear_acceleration_covariance<br></code></pre></td></tr></table></figure><h4 id="减去重力得到真实的加速度">2 减去重力得到真实的加速度</h4><p>由于IMU测量的是比力，在物体静止时会测量到一个垂直向上，大小为g的加速度，因此测量值需要减去<strong>g</strong>。但由于IMU在车辆运动中跟随车辆旋转，我们需要先将世界坐标系下的<span class="math inline">\(\textbf{g}=[0,0,9.8]\)</span>用orientation转换到当前IMU坐标系下，即：</p><p><span class="math display">\[ a_ {true} &#39;=a &#39;_ {measure}-  R_ {ZYX}  *\textbf{g} = \left [\begin{matrix}a_{x}&#39;\\ a_{y}&#39;\\ a_{z}&#39; \end{matrix} \right ] - \left [\begin{matrix}-sin(p)g \\sin(r)cos(p)g \\ cos(r)cos(p)g \end{matrix} \right ]\]</span></p><h4 id="imustate的结构">3 IMUState的结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">IMUState</span><br>  &#123;<br>    Time stamp;<br>    Angle roll;<br>    Angle pitch;<br>    Angle yaw;<br><br>    Vector3 position; <span class="hljs-comment">// IMU在世界坐标系的位置</span><br><br>    Vector3 velocity; <span class="hljs-comment">// IMU相对于世界坐标系的速度</span><br><br>    Vector3 acceleration; <br><br>    <span class="hljs-comment">// 一个插值函数，输入一个IMU开始状态，一个结束状态，一个插值的位置比例，输出插值得到的IMU状态</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">interpolate</span><span class="hljs-params">(<span class="hljs-type">const</span> IMUState&amp; start,</span></span><br><span class="hljs-params"><span class="hljs-function">      <span class="hljs-type">const</span> IMUState&amp; end,</span></span><br><span class="hljs-params"><span class="hljs-function">      <span class="hljs-type">const</span> <span class="hljs-type">float</span>&amp; ratio,</span></span><br><span class="hljs-params"><span class="hljs-function">      IMUState&amp; result)</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-type">float</span> invRatio = <span class="hljs-number">1</span> - ratio;<br><br>      result.roll = start.roll.<span class="hljs-built_in">rad</span>() * invRatio + end.roll.<span class="hljs-built_in">rad</span>() * ratio;<br>      result.pitch = start.pitch.<span class="hljs-built_in">rad</span>() * invRatio + end.pitch.<span class="hljs-built_in">rad</span>() * ratio;<br>      <span class="hljs-keyword">if</span> (start.yaw.<span class="hljs-built_in">rad</span>() - end.yaw.<span class="hljs-built_in">rad</span>() &gt; M_PI)<br>      &#123;<br>        result.yaw = start.yaw.<span class="hljs-built_in">rad</span>() * invRatio + (end.yaw.<span class="hljs-built_in">rad</span>() + <span class="hljs-number">2</span> * M_PI) * ratio;<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (start.yaw.<span class="hljs-built_in">rad</span>() - end.yaw.<span class="hljs-built_in">rad</span>() &lt; -M_PI)<br>      &#123;<br>        result.yaw = start.yaw.<span class="hljs-built_in">rad</span>() * invRatio + (end.yaw.<span class="hljs-built_in">rad</span>() - <span class="hljs-number">2</span> * M_PI) * ratio;<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        result.yaw = start.yaw.<span class="hljs-built_in">rad</span>() * invRatio + end.yaw.<span class="hljs-built_in">rad</span>() * ratio;<br>      &#125;<br><br>      result.velocity = start.velocity * invRatio + end.velocity * ratio;<br>      result.position = start.position * invRatio + end.position * ratio;<br>    &#125;;<br>  &#125; IMUState;<br></code></pre></td></tr></table></figure><h4 id="将新的imu状态更新到全局信息中">4将新的IMU状态更新到全局信息中</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BasicScanRegistration::updateIMUData</span><span class="hljs-params">(Vector3&amp; acc, IMUState&amp; newState)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (_imuHistory.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 把加速度转到世界坐标系下</span><br>    <span class="hljs-built_in">rotateZXY</span>(acc, newState.roll, newState.pitch, newState.yaw);<br><br>    <span class="hljs-comment">// 对位置和速度进行积分</span><br>    <span class="hljs-type">const</span> IMUState&amp; prevState = _imuHistory.<span class="hljs-built_in">last</span>();<br>    <span class="hljs-type">float</span> timeDiff = <span class="hljs-built_in">toSec</span>(newState.stamp - prevState.stamp);<br>    newState.position = prevState.position<br>                        + (prevState.velocity * timeDiff)<br>                        + (<span class="hljs-number">0.5</span> * acc * timeDiff * timeDiff);<br>    newState.velocity = prevState.velocity<br>                        + acc * timeDiff;<br>  &#125;<br><br>  _imuHistory.<span class="hljs-built_in">push</span>(newState); <span class="hljs-comment">// 推入_imuHistory队列</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里根据当前的加速度，前一个时刻的速度对位置和时间做了积分</p><p><span class="math display">\[p_{new} = p_{pre} + v_{prev} * \Delta t+ \frac{1}{2} a (\Delta t)^2\]</span></p><p><span class="math display">\[v_{new} = v_{pre} + a \Deltat\]</span></p><div class="note note-danger">            <p>问题1：对加速度做2次积分应该不太准吧，代码中有用反馈信息来纠正吗？</p>          </div><h3 id="运动补偿">运动补偿</h3><p>把点云投影到这一帧开始时刻:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BasicScanRegistration::projectPointToStartOfSweep</span><span class="hljs-params">(pcl::PointXYZI&amp; point, <span class="hljs-type">float</span> relTime)</span> <span class="hljs-comment">//relTime: 该点相对于这个scan初始时刻的时间</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">hasIMUData</span>()) <span class="hljs-comment">// hasIMUData: _imuHistory.size() &gt; 0</span><br>  &#123;<br>    <span class="hljs-built_in">setIMUTransformFor</span>(relTime); <span class="hljs-comment">// 计算该点相对于这一sweep初始时刻的位姿--1</span><br>    <span class="hljs-built_in">transformToStartIMU</span>(point); <span class="hljs-comment">// 把该点投影到这一sweep初始时刻--2</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="计算该点相对于这一sweep初始时刻的位姿">1计算该点相对于这一sweep初始时刻的位姿</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BasicScanRegistration::setIMUTransformFor</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">float</span>&amp; relTime)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">interpolateIMUStateFor</span>(relTime, _imuCur); <span class="hljs-comment">// 获得relTime时间的IMU状态</span><br><br>  <span class="hljs-type">float</span> relSweepTime = <span class="hljs-built_in">toSec</span>(_scanTime - _sweepStart) + relTime; <span class="hljs-comment">//在代码中_sweepStart设为_scanTime,所以这里就是relTime</span><br>  _imuPositionShift = _imuCur.position - _imuStart.position - _imuStart.velocity * relSweepTime; <span class="hljs-comment">// ??</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>获得relTime时间的IMU状态</strong></p><p>找到当前时刻之后最近的一帧IMU，用这一帧IMU和前一帧插值得到relTime时间的IMU状态：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BasicScanRegistration::interpolateIMUStateFor</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">float</span> &amp;relTime, IMUState &amp;outputState)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">double</span> timeDiff = <span class="hljs-built_in">toSec</span>(_scanTime - _imuHistory[_imuIdx].stamp) + relTime; <span class="hljs-comment">// 要补偿的点和当前的IMU帧（IMU根据用的需要idx不断往后加）的时间差</span><br>  <span class="hljs-keyword">while</span> (_imuIdx &lt; _imuHistory.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &amp;&amp; timeDiff &gt; <span class="hljs-number">0</span>) &#123;<br>    _imuIdx++;<br>    timeDiff = <span class="hljs-built_in">toSec</span>(_scanTime - _imuHistory[_imuIdx].stamp) + relTime;<br>  &#125; <span class="hljs-comment">// 当这个IMU时间戳超过我们要补偿的点的时间时，停止</span><br><br>  <span class="hljs-keyword">if</span> (_imuIdx == <span class="hljs-number">0</span> || timeDiff &gt; <span class="hljs-number">0</span>) &#123;<br>    outputState = _imuHistory[_imuIdx];<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-type">float</span> ratio = -timeDiff / <span class="hljs-built_in">toSec</span>(_imuHistory[_imuIdx].stamp - _imuHistory[_imuIdx - <span class="hljs-number">1</span>].stamp);<br>    IMUState::<span class="hljs-built_in">interpolate</span>(_imuHistory[_imuIdx], _imuHistory[_imuIdx - <span class="hljs-number">1</span>], ratio, outputState);<br>  &#125; <span class="hljs-comment">// 用这一帧IMU和上一帧IMU插值得到这个时刻的IMU状态</span><br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-danger">            <p>问题2：_imuPositionShift为什么是当前位置-(scan开始位置+开始速度*relTime)。_imuStart看代码scan开始时的imu状态。那_imuPositionShift就是由加速运动导致的点的位置偏移？</p>          </div><h4 id="把该点投影到scan初始时刻">2 把该点投影到scan初始时刻</h4><p>先把点转换到全局坐标系，只加入由加速度得到的偏移？再旋转回初始时刻的imu局部坐标系</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BasicScanRegistration::transformToStartIMU</span><span class="hljs-params">(pcl::PointXYZI&amp; point)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 把点旋转到全局坐标系</span><br>  <span class="hljs-built_in">rotateZXY</span>(point, _imuCur.roll, _imuCur.pitch, _imuCur.yaw);<br><br>  <span class="hljs-comment">// 加入平移？</span><br>  point.x += _imuPositionShift.<span class="hljs-built_in">x</span>();<br>  point.y += _imuPositionShift.<span class="hljs-built_in">y</span>();<br>  point.z += _imuPositionShift.<span class="hljs-built_in">z</span>();<br><br>  <span class="hljs-comment">// rotate point back to local IMU system relative to the start IMU state</span><br>  <span class="hljs-built_in">rotateYXZ</span>(point, -_imuStart.yaw, -_imuStart.pitch, -_imuStart.roll);<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-danger">            <p>问题3：这里两次旋转相对于对姿态做了补偿，但是平移方向是只对加速度产生偏差做补偿？</p>          </div>]]></content>
    
    
    <categories>
      
      <category>SLAM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LEGO-LOAM论文与代码阅读</title>
    <link href="/2023/09/23/LEGOLOAM%E8%AE%BA%E6%96%87%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <url>/2023/09/23/LEGOLOAM%E8%AE%BA%E6%96%87%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>LeGO-LOAM 是对LOAM的一个改进。正如论文题目中Lightweight andGround-optimized,它的特点在于相比LOAM更加轻量，加了地面优化。尽管它在实际应用中出现较少，但其中的一些思想都是值得学习的。本文主要关注它相对于LOAM改进的地方，以及存在的不足之处。</p>          </div><p>LeGO-LOAM主要解决的问题：原始LOAM对计算资源的需求大，在运动剧烈时不够鲁棒，特征不够稳定。</p><h3 id="整体框架">整体框架</h3><p>系统流程图如下：</p><center><img src="1.png" width="50%" height="50%" /></center><p>与LOAM是基本一致的，只是前面加了点云分割的步骤。但每一步实现的细节与LOAM也有差别，接下来我们具体看这些差别。</p><h3 id="对loam的改进">对LOAM的改进</h3><h4id="点云分割提取地面对非地面点云聚类">点云分割（提取地面，对非地面点云聚类）</h4><p>首先把一帧点云投影成深度图，深度图的像素为1800*16。深度图每个位置的值是该点到lidar的距离。</p><p><font color=gray>Velodyne16lidar，垂直方向是16线，水平方向是360/0.2=1800.</font></p><p>论文里只是简单提到使用了一个按列评估的地面提取，来看一下代码里是怎么做的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; _horizontal_scans; ++j) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; _ground_scan_index; ++i) &#123;           <span class="hljs-comment">// 仅遍历方向朝下的scan</span><br>    <span class="hljs-type">size_t</span> lowerInd = j + (i)*_horizontal_scans;<br>    <span class="hljs-type">size_t</span> upperInd = j + (i + <span class="hljs-number">1</span>) * _horizontal_scans; <span class="hljs-comment">//相邻两个laser在同一列的点，也就是深度图的同一列的点</span><br><br>    <span class="hljs-keyword">if</span> (_full_cloud-&gt;points[lowerInd].intensity == <span class="hljs-number">-1</span> ||<br>        _full_cloud-&gt;points[upperInd].intensity == <span class="hljs-number">-1</span>) &#123;<br>      <span class="hljs-comment">// no info to check, invalid points</span><br>      _ground_mat(i, j) = <span class="hljs-number">-1</span>;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    <span class="hljs-type">float</span> dX =<br>        _full_cloud-&gt;points[upperInd].x - _full_cloud-&gt;points[lowerInd].x;<br>    <span class="hljs-type">float</span> dY =<br>        _full_cloud-&gt;points[upperInd].y - _full_cloud-&gt;points[lowerInd].y;<br>    <span class="hljs-type">float</span> dZ =<br>        _full_cloud-&gt;points[upperInd].z - _full_cloud-&gt;points[lowerInd].z;<br><br>    <span class="hljs-type">float</span> vertical_angle = std::<span class="hljs-built_in">atan2</span>(dZ , <span class="hljs-built_in">sqrt</span>(dX * dX + dY * dY + dZ * dZ));<br><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> review this change, 判断前后两点的角度变化在10度内</span><br><br>    <span class="hljs-keyword">if</span> ( (vertical_angle - _sensor_mount_angle) &lt;= <span class="hljs-number">10</span> * DEG_TO_RAD) &#123;<br>      _ground_mat(i, j) = <span class="hljs-number">1</span>;<br>      _ground_mat(i + <span class="hljs-number">1</span>, j) = <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol type="1"><li>假设激光雷达在一定高度水平安装，只有下面几条laser可能扫描到地面点。因此只遍历这几条线。</li><li>取相邻两线在同一水平位置的点（也就是论文所说的按列评估），如下A,B两点</li></ol><center><img src="2.png" width="50%" height="50%" /></center><ol start="3" type="1"><li>如果两个点连线的垂直角度与lidar安装角度之差在10度以内，就认为是地面点。</li></ol><div class="note note-warning">            <p>这种判断方式过于简单，如果是低于激光雷达的其他平面也会被认为是地面。而且假设了雷达水平安装。但如果用RANSAC之类的提地面方法，耗时就太长了？</p>          </div><p>然后对非地面点云做聚类。这里论文也没有详细介绍，大致思想是从深度图上一个点出发，找上下左右四个点，如果点之间距离足够接近就聚为一类。直到所有点都有类别。看一下代码（这里是从一个点出发搜索完一类的过程）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">labelComponents</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span></span>&#123;<br>    <span class="hljs-comment">// use std::queue std::vector std::deque will slow the program down greatly</span><br>    <span class="hljs-type">float</span> d1, d2, alpha, angle;<br>    <span class="hljs-type">int</span> fromIndX, fromIndY, thisIndX, thisIndY; <br>    <span class="hljs-type">bool</span> lineCountFlag[N_SCAN] = &#123;<span class="hljs-literal">false</span>&#125;;<br><br>    queueIndX[<span class="hljs-number">0</span>] = row;<br>    queueIndY[<span class="hljs-number">0</span>] = col;<br>    <span class="hljs-type">int</span> queueSize = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> queueStartInd = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> queueEndInd = <span class="hljs-number">1</span>;<br><br>    allPushedIndX[<span class="hljs-number">0</span>] = row;<br>    allPushedIndY[<span class="hljs-number">0</span>] = col;<br>    <span class="hljs-type">int</span> allPushedIndSize = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span>(queueSize &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// Pop point</span><br>        fromIndX = queueIndX[queueStartInd];<br>        fromIndY = queueIndY[queueStartInd];<br>        --queueSize;<br>        ++queueStartInd;<br>        <span class="hljs-comment">// 标记要pop的点的label</span><br>        labelMat.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">int</span>&gt;(fromIndX, fromIndY) = labelCount;<br>        <span class="hljs-comment">// Loop through all the neighboring grids of popped grid</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = neighborIterator.<span class="hljs-built_in">begin</span>(); iter != neighborIterator.<span class="hljs-built_in">end</span>(); ++iter)&#123;<br>            <span class="hljs-comment">// new index</span><br>            thisIndX = fromIndX + (*iter).first;<br>            thisIndY = fromIndY + (*iter).second;<br>            <span class="hljs-comment">// index should be within the boundary</span><br>            <span class="hljs-keyword">if</span> (thisIndX &lt; <span class="hljs-number">0</span> || thisIndX &gt;= N_SCAN)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// at range image margin (left or right side)</span><br>            <span class="hljs-keyword">if</span> (thisIndY &lt; <span class="hljs-number">0</span>)<br>                thisIndY = Horizon_SCAN - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (thisIndY &gt;= Horizon_SCAN)<br>                thisIndY = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// prevent infinite loop (caused by put already examined point back)</span><br>            <span class="hljs-keyword">if</span> (labelMat.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">int</span>&gt;(thisIndX, thisIndY) != <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">continue</span>;<br><br>            d1 = std::<span class="hljs-built_in">max</span>(rangeMat.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">float</span>&gt;(fromIndX, fromIndY), <br>                            rangeMat.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">float</span>&gt;(thisIndX, thisIndY));<br>            d2 = std::<span class="hljs-built_in">min</span>(rangeMat.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">float</span>&gt;(fromIndX, fromIndY), <br>                            rangeMat.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">float</span>&gt;(thisIndX, thisIndY));<br><br>            <span class="hljs-keyword">if</span> ((*iter).first == <span class="hljs-number">0</span>)<br>                alpha = segmentAlphaX;<br>            <span class="hljs-keyword">else</span><br>                alpha = segmentAlphaY;<br><br>            angle = <span class="hljs-built_in">atan2</span>(d2*<span class="hljs-built_in">sin</span>(alpha), (d1 -d2*<span class="hljs-built_in">cos</span>(alpha)));<br><br>            <span class="hljs-keyword">if</span> (angle &gt; segmentTheta)&#123;<br><br>                queueIndX[queueEndInd] = thisIndX;<br>                queueIndY[queueEndInd] = thisIndY;<br>                ++queueSize;<br>                ++queueEndInd;<br><br>                labelMat.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">int</span>&gt;(thisIndX, thisIndY) = labelCount;<br>                lineCountFlag[thisIndX] = <span class="hljs-literal">true</span>;<br><br>                allPushedIndX[allPushedIndSize] = thisIndX;<br>                allPushedIndY[allPushedIndSize] = thisIndY;<br>                ++allPushedIndSize;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 点数少于30的类被认为无效</span><br>    <span class="hljs-type">bool</span> feasibleSegment = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (allPushedIndSize &gt;= <span class="hljs-number">30</span>)<br>        feasibleSegment = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (allPushedIndSize &gt;= segmentValidPointNum)&#123;<br>        <span class="hljs-type">int</span> lineCount = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N_SCAN; ++i)<br>            <span class="hljs-keyword">if</span> (lineCountFlag[i] == <span class="hljs-literal">true</span>)<br>                ++lineCount;<br>        <span class="hljs-keyword">if</span> (lineCount &gt;= segmentValidLineNum)<br>            feasibleSegment = <span class="hljs-literal">true</span>;            <br>    &#125;<br>    <span class="hljs-comment">// segment is valid, mark these points</span><br>    <span class="hljs-keyword">if</span> (feasibleSegment == <span class="hljs-literal">true</span>)&#123;<br>        ++labelCount;<br>    &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// segment is invalid, mark these points</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; allPushedIndSize; ++i)&#123;<br>            labelMat.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">int</span>&gt;(allPushedIndX[i], allPushedIndY[i]) = <span class="hljs-number">999999</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>聚类时相当于一种广度优先搜索。由于queue,vector结构会导致速度严重变慢，这里用静态数组queueIndX，queueIndY记录，然后用queueStartInd做标记</li><li>点数少于30的类被认为无效。这里是为了去除像树叶等不稳定的点，防止被提取为特征点</li><li>同一类原理：其中tang的角度越大，表明相邻的两个point越接近在一个平面上，故可认为是同一类</li></ul><center><img src="3.png" width="50%" height="50%" /></center><h4 id="特征提取">特征提取</h4><p>在特征提取阶段，LeGO-LOAM计算曲率的方式从LOAM的计算点的欧式距离改为只用深度：</p><p><span class="math display">\[c=\frac{1}{|S|\cdot \|r_i\|} \|\sum _ {j \in s, j\neq i}( r_ {j}-r_ {i}) \| \]</span></p><p>edge点只从非地面点中提取，在设置阈值c后，可以得到边缘点集<spanclass="math inline">\(\mathbb{F}_e\)</span>，这些点中c值最大的n(n=2)个点构成<spanclass="math inline">\(F_e\)</span>。平面点从地面和非地面点中提取，在设置阈值后得到点集<spanclass="math inline">\(\mathbb{F}_p\)</span>，这些点中c值最小的m（m=4）个点构成<spanclass="math inline">\(F_p\)</span></p><h4 id="特征匹配">特征匹配</h4><p>在特征匹配时，我们对这一帧的<spanclass="math inline">\(F^t_e,F^t_p\)</span>，在上一帧<spanclass="math inline">\(\mathbb{F}^{t-1}_e,\mathbb{F}^{t-1}_p\)</span>中找匹配点，而不是在所有点中找。同时平面点只在地面点类别中找，边缘点只在非地面点类别中找。计算残差的方式和LOAM类似，也是点到线的距离和点到面的距离</p><h4 id="帧间位姿估计两步lm优化">帧间位姿估计：两步LM优化</h4><center><img src="4.png" width="50%" height="50%" /></center><p>先用平面特征估计<spanclass="math inline">\([roll,pitch,z]\)</span>，再用边缘特征估计另外三个维度。因为平面主要以地面为主，而地面就约束了这三个维度。这种优化方法由于分解了问题，减少了每次优化时的变量维度，减少了迭代的次数。且在地面提取比较准确时，可以较好地估计前3个维度，提高算法的鲁棒性。</p><p>但也就导致算法非常依赖准确的地面提取，在斜坡，地面不平，lidar安装角度不水平时效果都会变差，且分布优化应该会降低准确率。</p><h4 id="建图">建图</h4><p>建图主要是把当前帧的特征<spanclass="math inline">\(F^t_e,F^t_p\)</span>和局部地图做匹配。此外，LeGO-LOAM使用每一个关键帧特征点云单独存储的方式，加入了回环检测，如果当前特征集与之前的特征集通过ICP得到匹配，就把这个约束加入位姿图优化。</p><h3 id="lego-loam的局限性">LeGo-LOAM的局限性</h3><ol type="1"><li>需要lidar水平安装或已知lidar安装的角度</li><li>需要有平坦的地面</li><li>LeGO-LOAM仅保存特征点，因此点云地图很稀疏。</li></ol>]]></content>
    
    
    <categories>
      
      <category>SLAM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LOAM论文与代码阅读（二）建图</title>
    <link href="/2023/09/23/LOAM%E8%AE%BA%E6%96%87%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB2/"/>
    <url>/2023/09/23/LOAM%E8%AE%BA%E6%96%87%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB2/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>上一篇学习了LOAM的里程计。里程计输入原始点云，得到了去畸变的点云和帧间位姿。但帧间位姿不断递推会导致误差不断积累，因此我们需要将帧（单帧或多帧）与地图进行匹配来优化位姿，同时建立全局地图。本篇就来学习LOAM中后端优化建图的过程。</p>          </div><h3 id="整体流程">整体流程</h3><p>建图的整体流程如下：</p><p>建图的算法对每个sweep运行一次。</p><p>输入：在第k+1个sweep结束时，我们得到了去畸变的点云 <spanclass="math inline">\(\overline{P}_{k+1}\)</span>,和这一帧相对于上一帧的变换 <spanclass="math inline">\(T^L_{k+1}\)</span>。同时我们有一个地图<spanclass="math inline">\(Q_k\)</span>，是由前k帧建立的全局地图点云，和上一帧建图时估计的位姿<spanclass="math inline">\(T_k^W\)</span>，即<spanclass="math inline">\(t_k\)</span>时刻lidar相对于世界坐标系的位姿。（世界坐标系即为<spanclass="math inline">\(Q_k\)</span>建立的坐标系，常使用第一帧的坐标系作为世界坐标系）</p><p>输出：<span class="math inline">\(T_{k+1}^W\)</span></p><p>方法：根据<span class="math inline">\(T_k^W\)</span>和<spanclass="math inline">\(T^L_{k+1}\)</span>，我们可以得到<spanclass="math inline">\(T_{k+1}^W\)</span>的一个估计值。用这个值我们将<spanclass="math inline">\(\overline{P}_{k+1}\)</span>投影到世界坐标系，用<spanclass="math inline">\(\overline{Q}_{k+1}\)</span>表示。把<spanclass="math inline">\(\overline{Q}_{k+1}\)</span>与地图<spanclass="math inline">\(Q_k\)</span>匹配，就可以优化位姿<spanclass="math inline">\(T_{k+1}^W\)</span>了。</p><h3 id="具体细节">具体细节</h3><ol type="1"><li>提取特征点的方式与里程计相同，但是提取更多的特征点（10倍）。</li></ol><div class="note note-success">            <p>由于地图更稠密，而且建图运行频率低，所以可以提取更多特征点？而且建图需要得到一个更准确的位姿估计。</p>          </div><ol start="2" type="1"><li><p>对于地图中大量的点云如果全部存储成kd-tree，树的深度很大，不易存储。地图首先被划分成10m的体素格，再将与当前<spanclass="math inline">\(\overline{Q}_{k+1}\)</span>有重叠区域的体素格中的点存成kd-tree.</p></li><li><p>对于<spanclass="math inline">\(\overline{Q}_{k+1}\)</span>中的一个特征点i，我们先找在<spanclass="math inline">\(Q_k\)</span>中在i附近一定区域内的点，设这些点构成集合S'。如果i是边缘点，我们只保留S'中的边缘点。如果i是平面点，我们只保留S中的平面点。</p></li><li><p>然后我们计算S'的协方差矩阵为M。计算M的特征值和特征向量得到V和E。如果i是边缘点，S'应对应一条边缘线，它的特征值应该有1个显著大于另外两个，对应的特征向量代表了这条边缘线的方向。如果i是平面点，S'应对应一个平面，它的特征值应该有2个显著大于另外1个，对应的两个特征向量代表了这个平面的方向。</p></li><li><p>然后我们取边缘线上的两个点，平面上的三个点，用和里程计里同样的方式计算距离。得到有关外参<spanclass="math inline">\(T^W_{k+1}\)</span>的损失函数。同样用鲁棒拟合（bisquareweight）和LM方法来优化。</p></li><li><p>优化完成后，我们把第k+1帧点云加入地图。为了使得地图上的点均匀分布，对地图做5cm的体素降采样。</p></li></ol><h3 id="loam的不足之处">LOAM的不足之处</h3><ol type="1"><li>LOAM整体流程比较繁琐，计算消耗大。每一帧都存入地图，在后期内存需求很大</li><li>没有后端优化，没有回环检测</li></ol>]]></content>
    
    
    <categories>
      
      <category>SLAM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LOAM论文与代码阅读（一）激光里程计</title>
    <link href="/2023/09/19/LOAM%E8%AE%BA%E6%96%87%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB1/"/>
    <url>/2023/09/19/LOAM%E8%AE%BA%E6%96%87%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB1/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>LOAM 是LiDAR SLAM早期的奠基之作，后续的LeGO-LOAM,lio-sam，ALOAM等方法都以这种高频里程计，低频建图为基础框架。我在最初接触SLAM时学习过这一系列算法，但理解的不深，后来因为没有做lidarSLAM相关，很久不接触已经生疏了。近期考虑到面试需求和未来的职业方向，计划重新学一遍，同时把重点记录下来，以便后续回顾。</p>          </div><p>LOAM的基本流程如下：</p><img src="/2023/09/19/LOAM%E8%AE%BA%E6%96%87%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB1/1.png" class="" title="fig:1"><p>每一帧lidar通过特征提取，运动补偿，特征匹配得到帧与帧之间的位姿（高频）。将几帧拼在一起与地图进行匹配，优化这几帧相对于地图的位姿（低频）。</p><h3 id="硬件">硬件</h3><p>这里发现之前忽略的一个点。LOAM中使用的激光雷达与现在的多线机械式激光雷达（如velodyne-32）不同。作者是用一个单线激光雷达加上垂直旋转的电机实现3维的扫描。</p><center><img src="2.png" width="60%" height="60%" /></center><p>论文中的介绍如上图所示，我的理解是：</p><p>单线激光雷达自身水平旋转，水平视场角为180度，分辨率为0.25度。每次旋转180得到的数据称为一个scan，需要25ms。同时电机使得激光雷达整体在垂直方向上旋转，从-90到90，水平为0（因此垂直视场角是180）。这样垂直转180度需要1s，1s内得到的数据是一个sweep。这一秒内会扫描40个scan。相当于在垂直方向上是40线,角分辨率是4.5度。</p><p>这也解释了这里scan的指代和其他论文不对应的问题。当前较多使用的多线激光雷达，可近似认为垂直方向的多条laser是同时发射的（实际上不同时，但相隔时间非常接近），因此把多线在水平方向一个周期内的扫描称为一个scan，用于特征提取。</p><h3 id="特征提取">特征提取</h3><p>如上所述，由于垂直角分辨率是4.5度，角度较大，因此提取特征是对每个scan进行单独操作。希望提取的特征点是边缘（edge）和平面（planarsurface）上的点。</p><p><font color=gray>边缘和平面特征显著，容易提取，反应了环境的结构，在帧与帧之间保持不变，更有利于匹配。</font></p><p>为了提取边缘点和平面点，我们首先要计算每个点的曲率。一个scan是单线激光按顺时针或逆时针扫描得到的点，如下图所示，为计算点i的曲率，我们取它前后N个点，组成集合S。</p><img src="/2023/09/19/LOAM%E8%AE%BA%E6%96%87%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB1/3.png" class="" title="fig:3"><p>则曲率c为：</p><p><span class="math display">\[c=  \frac{1}{|S| \cdot \|X_{(k,i)|}  \|}\|\sum_{j \in S,j \neq i} ( X_ {(k,i)}^ {L}  -  X_{(k,j)}^ {L} ) \|\]</span></p><p><spanclass="math inline">\(X_{(k,i)}^L\)</span>是第k个sweep中第i个点在LiDAR坐标系下的坐标。对集合中的每个点计算其与相邻点的距离，用来近似这个点所在位置的曲率。可以想象在平面处相邻点的距离比较接近，曲率会较小，而边缘处点的距离会较远，曲率较大。</p><p>对应ALOAM中的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 取每个点前后5个点，算x,y,z方向的差</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">5</span>; i &lt; cloudSize - <span class="hljs-number">5</span>; i++)<br>&#123; <br>    <span class="hljs-type">float</span> diffX = laserCloud-&gt;points[i - <span class="hljs-number">5</span>].x + laserCloud-&gt;points[i - <span class="hljs-number">4</span>].x + laserCloud-&gt;points[i - <span class="hljs-number">3</span>].x + laserCloud-&gt;points[i - <span class="hljs-number">2</span>].x + laserCloud-&gt;points[i - <span class="hljs-number">1</span>].x - <span class="hljs-number">10</span> * laserCloud-&gt;points[i].x + laserCloud-&gt;points[i + <span class="hljs-number">1</span>].x + laserCloud-&gt;points[i + <span class="hljs-number">2</span>].x + laserCloud-&gt;points[i + <span class="hljs-number">3</span>].x + laserCloud-&gt;points[i + <span class="hljs-number">4</span>].x + laserCloud-&gt;points[i + <span class="hljs-number">5</span>].x;<br>    <span class="hljs-type">float</span> diffY = laserCloud-&gt;points[i - <span class="hljs-number">5</span>].y + laserCloud-&gt;points[i - <span class="hljs-number">4</span>].y + laserCloud-&gt;points[i - <span class="hljs-number">3</span>].y + laserCloud-&gt;points[i - <span class="hljs-number">2</span>].y + laserCloud-&gt;points[i - <span class="hljs-number">1</span>].y - <span class="hljs-number">10</span> * laserCloud-&gt;points[i].y + laserCloud-&gt;points[i + <span class="hljs-number">1</span>].y + laserCloud-&gt;points[i + <span class="hljs-number">2</span>].y + laserCloud-&gt;points[i + <span class="hljs-number">3</span>].y + laserCloud-&gt;points[i + <span class="hljs-number">4</span>].y + laserCloud-&gt;points[i + <span class="hljs-number">5</span>].y;<br>    <span class="hljs-type">float</span> diffZ = laserCloud-&gt;points[i - <span class="hljs-number">5</span>].z + laserCloud-&gt;points[i - <span class="hljs-number">4</span>].z + laserCloud-&gt;points[i - <span class="hljs-number">3</span>].z + laserCloud-&gt;points[i - <span class="hljs-number">2</span>].z + laserCloud-&gt;points[i - <span class="hljs-number">1</span>].z - <span class="hljs-number">10</span> * laserCloud-&gt;points[i].z + laserCloud-&gt;points[i + <span class="hljs-number">1</span>].z + laserCloud-&gt;points[i + <span class="hljs-number">2</span>].z + laserCloud-&gt;points[i + <span class="hljs-number">3</span>].z + laserCloud-&gt;points[i + <span class="hljs-number">4</span>].z + laserCloud-&gt;points[i + <span class="hljs-number">5</span>].z;<br><br>    cloudCurvature[i] = diffX * diffX + diffY * diffY + diffZ * diffZ;<br>    cloudSortInd[i] = i;<br>    cloudNeighborPicked[i] = <span class="hljs-number">0</span>;<br>    cloudLabel[i] = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对一个scan的曲率按照c值排序，其中最大的n个点选择为edge点，最小的m个点为平面点。为了使得特征点分布更均匀，论文把一个scan平分为4个子区域，每个子区域最多选2个边缘点，4个平面点，边缘和平面有设定一个阈值（只有超过阈值才可能选为边缘点）。</p><p>此外，还要去掉一些不可信赖的点： (1)附近已经有点选中了（避免特征点太集中） (2)局部平面和laser光束平行，如下图（a） (3)在被遮挡的区域边缘的点，如下图（b）</p><img src="/2023/09/19/LOAM%E8%AE%BA%E6%96%87%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB1/4.png" class="" title="fig:4"><p>这些点的删除方式是：当根据曲率得到特征点后，重新去看这些点用于计算曲率的点集S，需要保证S中的点没有被选中为特征点，点集构成的平面不与激光线平行，且点集中相邻点没有在激光方向上的出现距离的不连续。</p><h3 id="特征匹配">特征匹配</h3><h4 id="符号">符号</h4><p>第k个sweep的原始点云表示为<spanclass="math inline">\(P_k\)</span>，<spanclass="math inline">\(P_k\)</span>开始的时间为<spanclass="math inline">\(t_k\)</span>。经过运动补偿（统一到这一帧结束时刻）的点云为<spanclass="math inline">\(\overline{P}_k\)</span>。</p><h4 id="整体流程">整体流程</h4><p>为了对流程有整体的认知，明白每一步的原因，我们先看大致的lidarodometry的流程，细节留到后面分析：</p><center><img src="5.png" width="70%" height="70%" /></center><ul><li><p>输入：前一帧去畸变的点云<spanclass="math inline">\(\overline{P}_k\)</span>，当前帧不断增加的点云<spanclass="math inline">\(P_k\)</span>（由于程序是实时运行的），</p></li><li><p>输出：<spanclass="math inline">\(T^L_{k+1}\)</span>,是lidar在<spanclass="math inline">\((t_{k+1}\)</span>，<spanclass="math inline">\(t_{k+2})\)</span>之间的变换，即点云 <spanclass="math inline">\(\overline{P}_{k+1}\)</span> 相对于 <spanclass="math inline">\(\overline{P}_{k}\)</span> 变换</p></li></ul><p><spanclass="math inline">\(T^L_{k+1}\)</span>是通过不断迭代获得的。在k+1帧起始时刻<spanclass="math inline">\(t_{k+1}\)</span>，<spanclass="math inline">\(T^L_{k+1}\)</span>为单位矩阵。我们现在假设上一次迭代得到的位姿为<spanclass="math inline">\(T^{L}_{k+1}\)</span>，来推导一次迭代过程：</p><ol type="1"><li>特征提取：首先从<spanclass="math inline">\(P_{k+1}\)</span>中提取edge和plane特征点，用<spanclass="math inline">\(\varepsilon_{k+1},H_{k+1}\)</span>表示。</li><li>运动补偿：为了和上一帧做匹配，我们可以用<spanclass="math inline">\(T^L_{k+1}\)</span>和匀速运动模型将<spanclass="math inline">\(\varepsilon_{k+1},H_{k+1}\)</span>投影到这一帧开始时刻，表示为<spanclass="math inline">\(\widetilde{\varepsilon}_{k+1},\widetilde{H}_{k+1}\)</span><font color=red>（细节1）</font>。</li><li>特征匹配：将<spanclass="math inline">\(\widetilde{\varepsilon}_{k+1},\widetilde{H}_{k+1}\)</span>与上一帧<spanclass="math inline">\(\overline{P}_k\)</span>匹配。对边缘点，我们找到上一帧对应的线，计算点到线的距离。对平面点，我们找到上一帧对应的平面，计算点到平面的距离。<font color=red>（细节2）</font>。</li><li>位姿优化：这些距离是<spanclass="math inline">\(T^L_{k+1}\)</span>的一个非线性函数，每个距离根据特征点会分配一个权重。构成了对T一个非线性优化问题，应用LM优化求解。将上一次的<spanclass="math inline">\(T^L_{k+1}\)</span>作为初值，当迭代一定次数或者函数收敛后，返回新的<spanclass="math inline">\(T^L_{k+1}\)</span>。<font color=red>（细节3）</font>。</li></ol><p>这个迭代在sweep内不停地进行，直到sweep结束，并把<spanclass="math inline">\(P_{k+1}\)</span>所有点用<spanclass="math inline">\(T^L_{k+1}\)</span>投影到这一帧结束（运动补偿），得到<spanclass="math inline">\(\overline{P}_{k+1}\)</span>作为下一帧的输入。</p><p>接下来我们看这里面每一步的细节：</p><h4 id="细节1运动补偿">细节1：运动补偿</h4><p>由于机械式lidar所有点获得的时间戳不同，在lidar运动时，每个点的lidar坐标系实际位置不同。我们要对一个sweep的lidar做运动补偿，把所有(x,y,z)的坐标系统一到一个时刻，作为一帧点云。原始的LOAM没有用IMU，而是假设在一个sweep内角速度和线速度是恒定的。整个过程中涉及运动补偿的流程有两个，一是为了与上一帧进行特征匹配，把所有点投影到这一帧开始时刻，二是在迭代结束之后，把所有点投影到这一帧结束时刻作为下一帧输入。</p><p><strong>把<spanclass="math inline">\(P_{k+1}\)</span>的点投影到开始时刻：</strong>为了把各个时刻的点投影到这一帧开始，我们需要知道每个点相对于这一帧初始时刻的位姿，这个位姿可以通过对<spanclass="math inline">\(T^L_{k+1}\)</span>插值得到。<spanclass="math inline">\(T^L_{k+1}\)</span>是当前时刻t下，我们估计的<spanclass="math inline">\((t_{k+1}, t)\)</span>变化的位姿。</p><p>对于i时刻的点，我们求得的位姿变换如下：</p><p><spanclass="math display">\[  T_{(k+1,i)}^{L}  =  \frac{t_{i}-t_{k+1}}{t-t_{k+1}}  T_{k+1}^{L} \]</span></p><p>从<spanclass="math inline">\(T_{(k+1,i)}^{L}\)</span>中拆解出R,t，可以得到补偿后的特征点坐标<spanclass="math inline">\(\widetilde {X}_ {(k+1,i)}^L\)</span></p><p><span class="math display">\[ X_{(k+1,i)}^L=R  \widetilde {X}_ {(k+1,i)}^L  +  t \]</span></p><p><strong>把<spanclass="math inline">\(P_{k+1}\)</span>的点投影到结束时刻：</strong></p><p>在这一帧结束后，我们得到了<spanclass="math inline">\((t_{k+1}\)</span>，<spanclass="math inline">\(t_{k+2})\)</span>之间的位姿变换<spanclass="math inline">\(T_{k+1}^{L}\)</span>。我们先把所有点按照上述方法投影到这一帧的开始时刻，然后用<spanclass="math inline">\(T_{k+1}^{L}\)</span>反变换，将所有点投影到这一帧结束时刻。</p><p><strong>对应ALOAM的代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//（TransformToStart：将当前帧Lidar坐标系下的点云变换到这一帧开始</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TransformToStart</span><span class="hljs-params">(PointType <span class="hljs-type">const</span> *<span class="hljs-type">const</span> pi, PointType *<span class="hljs-type">const</span> po)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//interpolation ratio</span><br>    <span class="hljs-type">double</span> s;            <span class="hljs-comment">//插值比，根据时间，在这一帧里占的比率</span><br>    <span class="hljs-keyword">if</span> (DISTORTION)      <span class="hljs-comment">//是否需要去畸变</span><br>    <span class="hljs-comment">// intensity 实数部分存的是scan上点的id，小数部分存的这一点相对这一帧起始点的时间差</span><br>    <span class="hljs-comment">// intensity的整体减去整数部分,就是时间差,除以周期,就是时间占比了</span><br>        s = (pi-&gt;intensity - <span class="hljs-built_in">int</span>(pi-&gt;intensity)) / SCAN_PERIOD;<br>    <span class="hljs-keyword">else</span><br>        s = <span class="hljs-number">1.0</span>;<br><br>    <span class="hljs-comment">// 所有点的操作方式都是一致的，相当于从结束时刻补偿到起始时刻，相当于是一个匀速模型的假设</span><br><br>    Eigen::Quaterniond q_point_last = Eigen::Quaterniond::<span class="hljs-built_in">Identity</span>().<span class="hljs-built_in">slerp</span>(s, q_last_curr); <span class="hljs-comment">//slerp函数(球面线性插值)</span><br>    Eigen::Vector3d t_point_last = s * t_last_curr;<br>    <span class="hljs-function">Eigen::Vector3d <span class="hljs-title">point</span><span class="hljs-params">(pi-&gt;x, pi-&gt;y, pi-&gt;z)</span></span>;         <span class="hljs-comment">//把当前点的坐标取出</span><br>    Eigen::Vector3d un_point = q_point_last * point + t_point_last; <span class="hljs-comment">//通过旋转和平移将 当前点转到帧起始时刻坐标系下的坐标</span><br><br>    <span class="hljs-comment">//将求得的转换后的坐标赋值给输出点</span><br>    po-&gt;x = un_point.<span class="hljs-built_in">x</span>();<br>    po-&gt;y = un_point.<span class="hljs-built_in">y</span>();<br>    po-&gt;z = un_point.<span class="hljs-built_in">z</span>();<br>    po-&gt;intensity = pi-&gt;intensity;<br>&#125;<br><br><br><span class="hljs-comment">// 首先把点统一到起始时刻坐标系下,再通过反变换,得到结束时刻坐标系下的点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TransformToEnd</span><span class="hljs-params">(PointType <span class="hljs-type">const</span> *<span class="hljs-type">const</span> pi, PointType *<span class="hljs-type">const</span> po)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// undistort point first</span><br>    pcl::PointXYZI un_point_tmp;<br>    <span class="hljs-built_in">TransformToStart</span>(pi, &amp;un_point_tmp);        <span class="hljs-comment">//转到帧起始时刻坐标系下的点</span><br><br>    <span class="hljs-function">Eigen::Vector3d <span class="hljs-title">un_point</span><span class="hljs-params">(un_point_tmp.x, un_point_tmp.y, un_point_tmp.z)</span></span>;       <span class="hljs-comment">//取出起始时刻坐标系下的点的x,y,z</span><br>    Eigen::Vector3d point_end = q_last_curr.<span class="hljs-built_in">inverse</span>() * (un_point - t_last_curr);   <span class="hljs-comment">//通过反变换,求得转到 结束时刻坐标系下 的点坐标</span><br><br>    <span class="hljs-comment">//将求得的转换后的坐标赋值给输出点</span><br>    po-&gt;x = point_end.<span class="hljs-built_in">x</span>();<br>    po-&gt;y = point_end.<span class="hljs-built_in">y</span>();<br>    po-&gt;z = point_end.<span class="hljs-built_in">z</span>();<br><br>    <span class="hljs-comment">//Remove distortion time info  去完畸变可以删除每个点的时间信息</span><br>    po-&gt;intensity = <span class="hljs-built_in">int</span>(pi-&gt;intensity);<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="细节2特征匹配">细节2：特征匹配</h4><p>用<span class="math inline">\(\widetilde{\varepsilon}_{k+1},\widetilde{H}_{k+1}\)</span>表示投影到开始时刻的特征点。特征匹配的方式如下：</p><center><img src="6.png" width="50%" height="50%" /></center><p><strong>边缘点（图a)：</strong></p><p>对于<spanclass="math inline">\(\widetilde{\varepsilon}_{k+1}\)</span>中的点i，我们要找到它在k帧中对应的边缘线，为了确定这条线，我们需要找到两个点。一个点j为离i距离最近的点。一个点l是在点j所在scan（橙线）的相邻两个scan（蓝线）中找到离i最近的点。为了确认j,l是边缘点，会确认它们的曲率c（根据特征提取时的公式）。</p><div class="note note-info">            <p>原因：因为一条边缘线不可能包含一个scan内的多个点。如果这条边缘线由一个scan内的两个点组成，那么这个边缘线与scan所在平面平行，此时这条边缘线在这个scan中的点是一条直线，不会计算出高的曲率，因此不可能被提取为特征点。</p>          </div><p>得到j,l后，我们计算点到直线的距离来衡量匹配的程度：</p><p><span class="math display">\[ d_\varepsilon=  \frac{|(\widetilde{X}^L_{(k+1,i)}-\overline{X}^L_{(k,j)})\times(\widetilde{X}^L_{(k+1,i)}-\overline{X}^L_{(k,l)})|}{|\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,l)}|}\]</span></p><p><strong>平面点（图b):</strong></p><p>对于<span class="math inline">\(\overline{H}_{k+1}\)</span>中的点<spanclass="math inline">\(i\)</span>，我们要找到它在k帧中对应的平面，为了确定这个平面，我们需要找到三个点。同样，一个点j为离i距离最近的点。然后我们找到另外两个距离i最近的点<spanclass="math inline">\(l,m\)</span>。其中<spanclass="math inline">\(l\)</span>需要与点<spanclass="math inline">\(j\)</span>在同一个scan（橙线），点<spanclass="math inline">\(m\)</span>在相邻两个scan（蓝线）。为了确认j,l是平面点，会确认它们的曲率c</p><div class="note note-info">            <p>原因：为了防止三点共线？</p>          </div><p>得到j,l,m后，我们计算点到平面的距离来衡量匹配的程度：</p><p><span class="math display">\[ d_H =  \frac{\left| \begin{matrix}(\widetilde{X}^L_{(k+1,i)}-\overline{X}^L_{(k,j)}) \\((\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,l)})\times(\overline{X}^L_{(k,l)}-\overline {X}^L_{(k,m)})) \end{matrix} \right|}{|(\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,l)})\times(\overline{X}^L_{(k,l)}-\overline {X}^L_{(k,m)})|} \]</span></p><p><font color=gray>为了更快找最近邻，<spanclass="math inline">\(\overline{P}_k\)</span>是以3Dkd-tree存储的</font></p><h4 id="位姿优化">位姿优化</h4><p>对于边缘点，我们可以得到损失函数：</p><p><span class="math display">\[ f _\varepsilon  (  X_ {(k+1,i)}^{L}  ,  T_ {k+1}^ {L} )=d_\varepsilon ,i \in \varepsilon_ {k+1}\]</span></p><p>对于平面点，我们可以得到损失函数：</p><p><span class="math display">\[ f_H  (  X_{(k+1,i)}^ {L}  ,  T_ {k+1}^{L} )=d_H ,i \in H_ {k+1} \]</span></p><p>把这些损失放在一起，可以得到：</p><p><span class="math display">\[ \textbf{f}(T_{k+1}^L) = \textbf{d}\]</span></p><p>其中 <span class="math inline">\(\textbf{d}\)</span>的每一行都是一个特征点的损失。我们可以计算f相对于T的雅可比矩阵J，然后用LM算法来优化。在优化时每行损失分配了不同的权重，匹配距离大的点权重更小，匹配距离大于一定值的点权重为0（被认为是误匹配）。也就是Bisquareweights,根据每一项损失当前的大小分配权重，优先去降低小的损失项，减轻大的损失项的影响。这种方式更加鲁棒。</p><p>这部分在代码中是用ceres来实现的，每一个残差项通过AddResidualBlock加入损失函数，调用优化器求解。</p>]]></content>
    
    
    <categories>
      
      <category>SLAM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pyside6使用问题记录（一）</title>
    <link href="/2023/09/19/pyside6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%951/"/>
    <url>/2023/09/19/pyside6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%951/</url>
    
    <content type="html"><![CDATA[<p>近期在做的任务要把交通路网结构用PySide6可视化，并添加一些选择车道，拖拽车辆之类的交互操作。以下是在应用过程中出现的一些问题和解决方案。</p><h3id="问题1qgraphicsview画polyline">问题1：qgraphicsview画polyline</h3><p>由于希望界面上的部件都可以交互（点击，拖拽），因此我尝试在<code>QGrahicsView</code>类里画，但发现<code>QGraphicsScene</code>没有可直接调用的画polyline的函数，可行的方法是先画出QPainterPath，再用QGraphicsPath。如下面的程序，drawPolyline函数可输入2Dpoints, color, width，画出这些点的折线段。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainWidget</span>(QtWidgets.QGraphicsView)<br>&#123;<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.initUI()<br>        self.scaleFactor = <span class="hljs-number">1</span><br>        self.resize(<span class="hljs-number">800</span>, <span class="hljs-number">800</span>) <br><br>        self.scene_map = QtWidgets.QGraphicsScene()<br>        self.scene_map.setSceneRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">700</span>, <span class="hljs-number">700</span>)<br>        self.scene_map.setBackgroundBrush(Qt.white)<br>        self.setScene(self.scene_map)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">drawPolyline</span>(<span class="hljs-params">self, points:<span class="hljs-built_in">list</span>[<span class="hljs-built_in">tuple</span>], color:QtGui.QColor, width:<span class="hljs-built_in">int</span> = <span class="hljs-number">1.0</span></span>):<br>        points = [QPointF(x,y) <span class="hljs-keyword">for</span> x,y <span class="hljs-keyword">in</span> points]<br>        path = QtGui.QPainterPath()<br>        polygon = QtGui.QPolygonF(points)<br>        path.addPolygon(polygon)<br>        <br>        pen = QtGui.QPen(color)<br>        pen.setWidth(width)<br>        new_item = QtWidgets.QGraphicsPathItem(path, <span class="hljs-literal">None</span>)<br>        new_item.setPath(path)<br>        new_item.setPen(pen)<br>        self.scene_map.addItem(new_item)<br><br>&#125;<br></code></pre></td></tr></table></figure><h3id="问题2画出来的polyline不够平滑有锯齿">问题2：画出来的polyline不够平滑，有锯齿</h3><p>用上述方式画出的图如下图左图所示：斜线会有锯齿，只有完全水平或竖直或45度的线才是粗细均匀的。</p><img src="/2023/09/19/pyside6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%951/1.png" class="" title="fig:1"><p>为了平滑线段，可以给<code>QGraphicsview</code>设置渲染的参数<code>setRenderHint</code>为antialiasing（抗锯齿）。在<code>__init__</code>函数里加入下面一行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.setRenderHint(QtGui.QPainter.Antialiasing, <span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>得到的结果如上面右图所示，可以看到没有锯齿了。</p><h3id="问题3拖拽时view无法超过scene的大小">问题3：拖拽时view无法超过scene的大小</h3><p>设置滚轮放大缩小功能需要重写wheelEvent函数，如下： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">wheelEvent</span>(<span class="hljs-params">self, event: QtGui.QWheelEvent</span>) -&amp;gt; <span class="hljs-literal">None</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.scene().items()) == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span><br><br>    curPoint = event.position()<br>    scenePos = self.mapToScene(QPoint(curPoint.x(), curPoint.y()))<br><br>    viewWidth = self.viewport().width()<br>    viewHeight = self.viewport().height()<br><br>    hScale = curPoint.x() / viewWidth<br>    vScale = curPoint.y() / viewHeight<br><br>    wheelDeltaValue = event.angleDelta().y()<br>    self.scaleFactor = self.transform().m11()<br>    <span class="hljs-keyword">if</span> (self.scaleFactor &amp;lt; <span class="hljs-number">0.05</span> <span class="hljs-keyword">and</span> wheelDeltaValue&amp;lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">or</span> (self.scaleFactor&amp;gt;<span class="hljs-number">50</span> <span class="hljs-keyword">and</span> wheelDeltaValue&amp;gt;<span class="hljs-number">0</span>):<br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">if</span> wheelDeltaValue &amp;gt; <span class="hljs-number">0</span>:<br>        self.scale(<span class="hljs-number">1.1</span>, <span class="hljs-number">1.1</span>)<br>    <span class="hljs-keyword">else</span>:<br>        self.scale(<span class="hljs-number">1.0</span>/<span class="hljs-number">1.1</span>, <span class="hljs-number">1.0</span>/<span class="hljs-number">1.1</span>)<br>    <br>    viewPoint = self.transform().<span class="hljs-built_in">map</span>(scenePos)<br>    self.horizontalScrollBar().setValue(<span class="hljs-built_in">int</span>(viewPoint.x() - viewWidth * hScale ))<br>    self.verticalScrollBar().setValue(<span class="hljs-built_in">int</span>(viewPoint.y() - viewHeight * vScale ))<br><br>    self.update()<br></code></pre></td></tr></table></figure></p><p>设置鼠标拖拽功能只需要给QGraphicsView设置setDragMode，在window类初始化时加入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)<br></code></pre></td></tr></table></figure><p>但在显示底图时由于图比较大，我并不想一开始显示全部，而只是显示一部分，如下图（1）。此时我的拖拽功能只在相比原始scene放大时才有用（在图（2）时可以拖拽）。当地图缩小后尽管还未显示地图全貌，但无法拖动（图（3）无法拖动）。</p><img src="/2023/09/19/pyside6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%951/2.png" class="" title="fig:2"><p>参考这个回答：https://stackoverflow.com/questions/55007339/allow-qgraphicsview-to-move-outside-scene</p><p>一个简单粗暴的解决方法是给scene设置足够大的初始大小。在我的例子中我将大小改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.scene_map.setSceneRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">2000</span>)<br></code></pre></td></tr></table></figure><p>这样就可以在上图（3）仍然可以拖动。不过修改scene_map的大小后要注意原本点的位置的按照scene_map的大小改变。由于<code>QGraphicsScene</code>默认是中心和<code>QGraphicsView</code>对齐的，如scene_map大小设为(2000,2000)，那么此时scene中心点的坐标(1000,1000)会显示在view的中心。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pyside6使用问题记录（二）</title>
    <link href="/2023/09/19/pyside6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%952/"/>
    <url>/2023/09/19/pyside6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%952/</url>
    
    <content type="html"><![CDATA[<h3id="问题1自定义qgraphicsitem的选中效果">问题1：自定义QGraphicsItem的选中效果</h3><p>当把某个QGraphicsItem设置为<code>ItemIsSelectable</code>时，鼠标选中会有效果：<strong>item显示一个矩形的虚线边框</strong></p><p>由于我的item本身不是矩形，且虚线不够明显，我希望修改成点击后改变填充的颜色。</p><p><strong>解决方法：</strong></p><p>重新定义一个自己的QGraphicsItem类，继承自原来的item类，并重写paint()函数。在函数中加入判断是否点击，并改变笔刷颜色。</p><p>先看一下虚线的由来(C++版本的):</p><p>参考 https://developer.aliyun.com/article/119812</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QGraphicsPathItem::paint</span><span class="hljs-params">(QPainter *painter, <span class="hljs-type">const</span> QStyleOptionGraphicsItem *option,</span></span><br><span class="hljs-params"><span class="hljs-function">                              QWidget *widget)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">Q_D</span>(QGraphicsPathItem);<br>    <span class="hljs-built_in">Q_UNUSED</span>(widget);<br>    painter-&gt;<span class="hljs-built_in">setPen</span>(d-&gt;pen);<br>    painter-&gt;<span class="hljs-built_in">setBrush</span>(d-&gt;brush);<br>    painter-&gt;<span class="hljs-built_in">drawPath</span>(d-&gt;path);<br><br>    <span class="hljs-keyword">if</span> (option-&gt;state &amp; QStyle::State_Selected)<br>        <span class="hljs-built_in">qt_graphicsItem_highlightSelected</span>(<span class="hljs-keyword">this</span>, painter, option);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到在paint函数中调用了<code>qt_graphicsItem_highlightSelected</code>函数来实现点击后显示效果的功能。那么我们重写的paint函数只要完成（1）把内容画出来，（2）判断selected并修改painter样式</p><p>最终代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> PySide6 <span class="hljs-keyword">import</span> QtWidgets<br><span class="hljs-keyword">from</span> PySide6.QtGui <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> PySide6.QtWidgets <span class="hljs-keyword">import</span>*<br><span class="hljs-keyword">from</span> PySide6.QtCore <span class="hljs-keyword">import</span> Qt, QPointF, QPoint<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myQGraphicsPolygonItem</span>(QtWidgets.QGraphicsPolygonItem):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, polygon</span>):<br>        <span class="hljs-built_in">super</span>().__init__(polygon)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">paint</span>(<span class="hljs-params">self, painter: QPainter, option: QStyleOptionGraphicsItem, widget</span>):<br>        painter.setPen(self.pen())<br>        painter.setBrush(self.brush())<br>        selected = option.state &amp;amp; QStyle.StateFlag.State_Selected<br>        <span class="hljs-keyword">if</span> selected:<br>            brush = QBrush(QColor(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>            painter.setBrush(brush)<br>        painter.drawPolygon(self.polygon())<br>        <br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>(<span class="hljs-title class_ inherited__">QGraphicsView</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(Demo, self).__init__()<br>        self.resize(<span class="hljs-number">600</span>, <span class="hljs-number">600</span>)<br> <br>        self.scene1 = QGraphicsScene()<br>        self.scene1.setSceneRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">300</span>, <span class="hljs-number">300</span>)<br><br>        points = [(<span class="hljs-number">200</span>,<span class="hljs-number">100</span>), (<span class="hljs-number">180</span>, <span class="hljs-number">150</span>), (<span class="hljs-number">200</span>, <span class="hljs-number">200</span>), (<span class="hljs-number">250</span>, <span class="hljs-number">200</span>), (<span class="hljs-number">270</span>, <span class="hljs-number">150</span>), (<span class="hljs-number">250</span>, <span class="hljs-number">100</span>)]<br><br>        points = [QPointF(x,y) <span class="hljs-keyword">for</span> x,y <span class="hljs-keyword">in</span> points]<br>        polygon = QPolygonF(points)<br>        self.polygon1 = myQGraphicsPolygonItem(polygon)<br>        pen = QPen(QColor(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>))<br>        brush = QBrush(QColor(<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))<br>        self.polygon1.setPen(pen)<br>        self.polygon1.setBrush(brush)<br>        self.scene1.addItem(self.polygon1)<br><br>        self.polygon1.setFlags(QGraphicsItem.ItemIsSelectable | QGraphicsItem.ItemIsMovable)<br> <br>        self.setScene(self.scene1)<br> <br> <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app = QApplication(sys.argv)<br>    demo = Demo()<br>    demo.show()<br>    sys.exit(app.<span class="hljs-built_in">exec</span>())<br><br></code></pre></td></tr></table></figure><p>可以实现点击后改变颜色，点击其他位置恢复颜色。</p><h3id="点击qgraphicsitem后触发mainwindow窗口的函数">点击QGraphicsItem后触发MainWindow窗口的函数</h3><p>在应用中，我希望点击一个QGraphicsItem后（如下面的一条车道），在MainWindow的statusbar部件中显示选择的车道的Id.</p><center><img src="1.jpg" width="70%" height="70%" /></center><p>我可以设置全局变量choosedLane，在每选择一个item时修改该全局变量的值。但我希望在修改后MainWindow的Statusbar更新信息。即每点击一次车道，向主窗口发送一次信号。</p><p>解决方案：</p><p>参考 https://cloud.tencent.com/developer/ask/sof/114657898</p><p>可以自定义一个QGraphicsScene类，加入一个Signal变量。并修改需要点击的QGraphicsItem的函数<code>mousePressEvent()</code>，使其所在scene的Signal变量发射信号，再在主窗口将该变量与需要发生事件函数连接。</p><p>部分代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">myQGraphicsPolygonItem</span>(<span class="hljs-title class_ inherited__">QGraphicsPolygonItem</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, polygon</span>):<br>        <span class="hljs-built_in">super</span>().__init__(polygon)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">paint</span>(<span class="hljs-params">self, painter: QPainter, option: QStyleOptionGraphicsItem, widget</span>):<br>        <span class="hljs-comment"># ...</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mousePressEvent</span>(<span class="hljs-params">self, event</span>):<br>        self.scene().itemClicked.emit(self)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myQGraphicsScene</span>(<span class="hljs-title class_ inherited__">QGraphicsScene</span>):<br>    itemClicked = Signal(<span class="hljs-built_in">object</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GUI</span>(<span class="hljs-title class_ inherited__">QGraphicsView</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.scene_map = myQGraphicsScene()<br>        self.setScene(self.scene_map)<br>        self.scene_map.itemClicked.connect(self.showMessage)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">showMessage</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># ...</span><br><br></code></pre></td></tr></table></figure><h3id="gui运行耗时程序时用多线程防止窗口卡住">GUI运行耗时程序时用多线程防止窗口卡住</h3><p>在项目中，我有一个交通流仿真程序，按帧得到各个时刻要显示的polyline，polygon等。我希望随着仿真程序的运行，图形化界面能实时刷新。</p><p>但如果仿真和可视化在单线程中顺序进行，在运行仿真函数时，虽然实时调用了绘画的函数，界面却不会马上更新，只有当仿真程序运行完成后，才会一次性显示当前的结果。</p><p>参考： https://realpython.com/python-pyqt-qthread/</p><p>我使用的解决方案是在主线程中跑GUI基于事件循环的显示，另外开一个线程跑仿真，然后通过signal和slot机制来在两个线程之间通讯（仿真线程将要画的几何信息用signal发送给主线程）。</p><p>这里还遇到一个小问题：每一帧仿真时，我会清除界面原来的内容，再重新加上新的几何图形（向QGraphicsScene中addItem）。由于widget在每次清除和加入时都会自动刷新，导致程序跑起来界面一直闪烁。</p><p>解决方法：运用<code>setUpdateEnabled()</code>，在每一帧开始改变前为主窗口设置<code>setUpdateEnabled(False)</code>，这样虽然子线程向主线程发送了clear,additem等signal，窗口不会马上更新。等到一帧全部画完后，再设置<code>setUpdateEnabled(True)</code>，此时窗口会一下把之前所有的改变更新完成，就不会出现画面卡顿闪烁的情况了。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++多线程学习笔记-3</title>
    <link href="/2023/09/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3/"/>
    <url>/2023/09/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3/</url>
    
    <content type="html"><![CDATA[<h3 id="获取线程返回值">获取线程返回值</h3><p>我们希望执行线程后获得线程执行结果的返回值。</p><p>解决方法：</p><ol type="1"><li>直接在线程函数参数中加入作为返回值的引用或指针参数</li><li>使用std::future和std::promise</li></ol><p>std::future，它表示存储着一个未来会被初始化的变量。这个变量可以通过std::future提供的成员函数std::future::get()来得到。如果在这个变量被赋值之前就有别的线程试图通过std::future::get()获取这个变量，那么这个线程将会被阻塞到这个变量可以获取为止。</p><p>std::promise同样也是一个类模板，这个对象承诺在未来一定会初始化一个变量(这个变量也就是std::future中的变量)。</p><p>每一个std::promise对象都有一个与之关联的std::future对象。当std::promise设置值的时候，这个值就会赋给std::future中的对象了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br> <br><span class="hljs-comment">// 函数计算vector的和，并需要返回sum</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">accumulate</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator first,</span></span><br><span class="hljs-params"><span class="hljs-function">                std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator last,</span></span><br><span class="hljs-params"><span class="hljs-function">                std::promise&lt;<span class="hljs-type">int</span>&gt; accumulate_promise)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> sum = std::<span class="hljs-built_in">accumulate</span>(first, last, <span class="hljs-number">0</span>);<br>    accumulate_promise.<span class="hljs-built_in">set_value</span>(sum);  <span class="hljs-comment">// Notify future</span><br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 用promise&lt;int&gt;来在线程之间传递数据</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; numbers = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> &#125;;<br>    std::promise&lt;<span class="hljs-type">int</span>&gt; accumulate_promise;<br>    std::future&lt;<span class="hljs-type">int</span>&gt; accumulate_future = accumulate_promise.<span class="hljs-built_in">get_future</span>();<br>    <span class="hljs-function">std::thread <span class="hljs-title">work_thread</span><span class="hljs-params">(accumulate, numbers.begin(), numbers.end(),</span></span><br><span class="hljs-params"><span class="hljs-function">                            std::move(accumulate_promise))</span></span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;result=&quot;</span> &lt;&lt; accumulate_future.<span class="hljs-built_in">get</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-comment">// get()函数会一直阻塞直到accumulate_promise被赋予了有效值</span><br>    work_thread.<span class="hljs-built_in">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>用这种方式相比指针或引用的好处在于不需要等待此线程运行完了才返回值，一旦有了需要的值，另一个线程就可以得到信号并获取值。这种功能本来需要设置信号条件变量来实现。</p><h3 id="cout输出乱码">cout输出乱码</h3><p>当多个线程都有cout输出时，控制台上输出内容可能会交错混乱，这是因为cout不是线程安全的.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">cout &lt;&lt; <span class="hljs-string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>它把传入的数据依次存入缓冲区。这中间是有可能有其他线程插入的。</p><p>解决方法：</p><ol type="1"><li>使用printf代替cout <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%d\n&quot;</span>,a);<br></code></pre></td></tr></table></figure></li><li>加锁</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h3 id="多个线程存入vector">多个线程存入vector</h3><p>希望程序根据输入决定调用线程的数量，此时用一个vector存储线程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::vector&lt;std::thread&gt; threads;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_thread; i++)<br>    &#123;<br>        threads.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">thread</span>(&amp;Calibrator::RandomSearch, <span class="hljs-keyword">this</span>, <span class="hljs-built_in">int</span>(search_count / num_thread), xyz_range, rpy_range, i));<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_thread; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(threads[i].<span class="hljs-built_in">joinable</span>())&#123;<br>            threads[i].<span class="hljs-built_in">join</span>();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>此时不能先声明thread，再把它push_back，否则就会报错 <figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">error: </span>use of deleted function &#x27;std::thread::thread(const std::thread&amp;)&#x27;<br></code></pre></td></tr></table></figure></p><p>这是因为vector::push_back会先拷贝再推入，而thread是禁止拷贝构造的。可以如上面的直接构造一个临时变量，推入vector.或者用std::move把左值引用转为右值引用。</p><div class="note note-success">            <p>左值是表达式结束后依然存在的持久对象(代表一个在内存中占有确定位置的对象)，能够取到地址</p><p>右值是表达式结束时不再存在的临时对象(不在内存中占有确定位置的表达式）</p>          </div><h3 id="多线程随机数生成重复">多线程随机数生成重复</h3><p>如果只在主线程里用srand，那么其他子线程随机数一定是相同的。生成随机数的每个线程都需要重新设置时间种子。</p><p>但如果用时间做随机种子 <figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">srand</span>((<span class="hljs-variable">unsigned</span> <span class="hljs-variable">int</span>)<span class="hljs-title"><span class="hljs-built_in">time</span></span>(<span class="hljs-variable"><span class="hljs-literal">NULL</span></span>));</span><br></code></pre></td></tr></table></figure>由于时间以秒为单位，如果多个线程调用时间接近，还是可能随机种子相同导致随机数重复。</p><p>解决方法：</p><p>把线程编号传入，使用（时间+编号）生成随机种子。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>非静态类成员函数作为回调函数</title>
    <link href="/2023/09/14/%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    <url>/2023/09/14/%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3><p>当非静态类成员函数作为回调函数时，如果不做任何处理会报错。如下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>()&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; i &lt;&lt; std::endl;<br>&#125;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetValue</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>v = i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintValue</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; v &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> v = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callback</span><span class="hljs-params">(<span class="hljs-type">void</span>(*f)(<span class="hljs-type">int</span>))</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Test test;<br>test.<span class="hljs-built_in">PrintValue</span>();<br><span class="hljs-built_in">callback</span>(&amp;Test::Print);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译时会报错：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">error: </span>cannot convert &#x27;void (Test::*)(int)&#x27; to &#x27;void (*)(int)&#x27;<br></code></pre></td></tr></table></figure><p>如果这个函数不使用其他类成员变量和非静态成员函数，那么可以把它声明为静态。这样调用是没问题的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>()&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; i &lt;&lt; std::endl;<br>&#125;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetValue</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>v = i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintValue</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; v &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> v = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callback</span><span class="hljs-params">(<span class="hljs-type">void</span>(*f)(<span class="hljs-type">int</span>))</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Test test;<br>test.<span class="hljs-built_in">PrintValue</span>();<br><span class="hljs-built_in">callback</span>(&amp;Test::Print);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但很多时候我们都需要使用类成员变量，例如类中的另一个<code>SetValue</code>函数，必须保留为非静态函数。</p><p>此时问题根源在于非静态成员函数调用时有一个隐藏参数this,表示它与一个类实例相对应。我们在调用时必须把类实例的地址也传给callback函数。</p><h3id="解决方法一将其硬设成静态函数">解决方法一：将其硬设成静态函数</h3><p>设成静态函数后我们无法直接使用类内非静态成员变量，但如果我们把类地址传给这个静态函数，就可以读取，改变这个类的成员变量。因此我们需要给<code>setValue</code>函数加上<code>Test *</code>类型的变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>()&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; i &lt;&lt; std::endl;<br>&#125;<br><br>        <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">SetValue</span><span class="hljs-params">(Test *test, <span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>test-&gt;v = i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintValue</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; v &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> v = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callback</span><span class="hljs-params">(<span class="hljs-type">void</span>(*f)(Test *, <span class="hljs-type">int</span>), Test *test)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">f</span>(test, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Test test;<br>test.<span class="hljs-built_in">PrintValue</span>();<br><span class="hljs-built_in">callback</span>(&amp;Test::SetValue, &amp;test);<br>test.<span class="hljs-built_in">PrintValue</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们实现了用类内静态函数调用类内非静态成员变量的功能。</p><h3 id="解决方法二bind">解决方法二：bind</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>()&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; i &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetValue</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>v = i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintValue</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; v &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> v = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Test test;<br>test.<span class="hljs-built_in">PrintValue</span>();<br><span class="hljs-keyword">auto</span> _callback = std::<span class="hljs-built_in">bind</span>(&amp;Test::SetValue, &amp;test, std::placeholders::_1);<br>_callback(<span class="hljs-number">1</span>);<br>test.<span class="hljs-built_in">PrintValue</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="thread可以直接用af-a-params的形式">thread可以直接用(&amp;A::f,&amp;a, params)的形式</h4><p>如下面的例子：当thread线程的回调函数是非静态类成员函数时，由于print函数有隐藏参数this，而thread可以直接传入各个参数，这样就能够正确调用实例a的函数print</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> num)&#123;num_ = num&#125;;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; num_ + a &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> num_ = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">thread <span class="hljs-title">t</span><span class="hljs-params">(&amp;A::print, &amp;a, <span class="hljs-number">1</span>)</span></span>;<br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当这个函数调用发生在类内时，只需要用this取代&amp;a</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// static void *callback(void *arg, int a);</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> num)&#123;num_ = num&#125;;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callback</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">thread <span class="hljs-title">t</span><span class="hljs-params">(&amp;A::print, <span class="hljs-keyword">this</span>, <span class="hljs-number">1</span>)</span></span>;<br>        t.<span class="hljs-built_in">join</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; num_ + a &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> num_ = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>    a.<span class="hljs-built_in">callback</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解决方法三设置中转函数">解决方法三：设置中转函数</h3><p>如果需要回调函数的接口不方便自由修改，只能传入一个函数指针，比如是某个编写好的库，那我们可以加一个中转函数，此时需要test实例为全局变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>()&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; i &lt;&lt; std::endl;<br>&#125;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetValue</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>v = i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintValue</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; v &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> v = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callback</span><span class="hljs-params">(<span class="hljs-type">void</span>(*f)(<span class="hljs-type">int</span>))</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br>Test test;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">newSetValue</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    test.<span class="hljs-built_in">SetValue</span>(a);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>test.<span class="hljs-built_in">PrintValue</span>();<br><span class="hljs-built_in">callback</span>(newSetValue);<br>test.<span class="hljs-built_in">PrintValue</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PCL对大规模点云进行体素降采样</title>
    <link href="/2023/09/14/pcl%E5%A4%A7%E8%A7%84%E6%A8%A1%E7%82%B9%E4%BA%91%E9%99%8D%E9%87%87%E6%A0%B7/"/>
    <url>/2023/09/14/pcl%E5%A4%A7%E8%A7%84%E6%A8%A1%E7%82%B9%E4%BA%91%E9%99%8D%E9%87%87%E6%A0%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="普通体素降采样"><a href="#普通体素降采样" class="headerlink" title="普通体素降采样"></a>普通体素降采样</h3><p>直接调用voxel_grid库，参考<a href="https://pcl.readthedocs.io/projects/tutorials/en/latest/voxel_grid.html">官方教程</a>，只需要设置体素的大小<code>setLeafSize(x, y, z)</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pcl/io/pcd_io.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pcl/point_types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pcl/filters/voxel_grid.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    pcl::<span class="hljs-function">PCLPointCloud2::Ptr <span class="hljs-title">cloud</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> pcl::PCLPointCloud2 ())</span></span>;<br>    pcl::<span class="hljs-function">PCLPointCloud2::Ptr <span class="hljs-title">cloud_filtered</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> pcl::PCLPointCloud2 ())</span></span>;<br><br>    <span class="hljs-comment">// 读入点云</span><br>    pcl::PCDReader reader;<br>    reader.<span class="hljs-built_in">read</span> (<span class="hljs-string">&quot;table_scene_lms400.pcd&quot;</span>, *cloud); <br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;PointCloud before filtering: &quot;</span> &lt;&lt; cloud-&gt;width * cloud-&gt;height  &lt;&lt; <span class="hljs-string">&quot; data points (&quot;</span> &lt;&lt; pcl::<span class="hljs-built_in">getFieldsList</span> (*cloud) &lt;&lt; <span class="hljs-string">&quot;).&quot;</span> &lt;&lt; std::endl;<br>    <br>    <span class="hljs-comment">// 过滤</span><br>    pcl::VoxelGrid&lt;pcl::PCLPointCloud2&gt; sor;<br>    sor.<span class="hljs-built_in">setInputCloud</span> (cloud); <span class="hljs-comment">// 输入点云</span><br>    sor.<span class="hljs-built_in">setLeafSize</span> (<span class="hljs-number">0.01f</span>, <span class="hljs-number">0.01f</span>, <span class="hljs-number">0.01f</span>); <span class="hljs-comment">// 设置体素大小</span><br>    sor.<span class="hljs-built_in">filter</span> (*cloud_filtered);<br><br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;PointCloud after filtering: &quot;</span> &lt;&lt; cloud_filtered-&gt;width * cloud_filtered-&gt;height &lt;&lt; <span class="hljs-string">&quot; data points (&quot;</span> &lt;&lt; pcl::<span class="hljs-built_in">getFieldsList</span> (*cloud_filtered) &lt;&lt; <span class="hljs-string">&quot;).&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>然而，对于大规模的点云（如点个数超过100000），就会导致格点数超过整型最大值，报错：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Leaf size <span class="hljs-keyword">is</span> too small <span class="hljs-keyword">for</span> the <span class="hljs-keyword">input</span> dataset. <span class="hljs-type">Integer</span> indices would overflow.<br></code></pre></td></tr></table></figure><p>此时可以采用八叉树结构，将整个点云分成有大小限制的若干个叶节点，对每个叶节点分别做体素过滤，再合起来</p><h3 id="octree体素过滤"><a href="#octree体素过滤" class="headerlink" title="octree体素过滤"></a>octree体素过滤</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 原大规模点云</span><br>pcl::PointCloud&lt;pcl::PointXYZI&gt;::<span class="hljs-function">Ptr <span class="hljs-title">cloud_in</span><span class="hljs-params">(<span class="hljs-keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZI&gt;())</span></span>;<br><br><span class="hljs-comment">// 输出的降采样点云</span><br>pcl::PointCloud&lt;pcl::PointXYZI&gt;::<span class="hljs-function">Ptr <span class="hljs-title">cloud_out</span><span class="hljs-params">(<span class="hljs-keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZI&gt;())</span></span>;<br><br>pcl::PointCloud&lt;pcl::PointXYZI&gt;::<span class="hljs-function">Ptr <span class="hljs-title">cloud_tmp</span><span class="hljs-params">(<span class="hljs-keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZI&gt;())</span></span>;<br>pcl::PointCloud&lt;pcl::PointXYZI&gt;::<span class="hljs-function">Ptr <span class="hljs-title">cloud_tmp_ds</span><span class="hljs-params">(<span class="hljs-keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZI&gt;())</span></span>;<br><br><span class="hljs-comment">// 同样的体素过滤器VoxelGrid</span><br><span class="hljs-type">static</span> <span class="hljs-type">float</span> kLeafSize = <span class="hljs-number">0.2</span>;<br>pcl::VoxelGrid&lt;pcl::PointXYZI&gt; filter_map;<br>filter_map.<span class="hljs-built_in">setLeafSize</span>(kLeafSize, kLeafSize, kLeafSize);<br><br><span class="hljs-comment">// 将点云存入octree,设置子区域大小为1250*leaf_size（1250^3&lt;2^31，这样点数不会超过整型范围）</span><br><br>cloud_out-&gt;<span class="hljs-built_in">clear</span>();<br>pcl::octree::OctreePointCloud&lt;pcl::PointXYZI&gt; octree&#123;<span class="hljs-number">1250</span> * kLeafSize&#125;;<br>octree.<span class="hljs-built_in">setInputCloud</span>(cloud_map);<br>octree.<span class="hljs-built_in">addPointsFromInputCloud</span>();<br><br><span class="hljs-comment">// 遍历每个区域降采样</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = octree.<span class="hljs-built_in">leaf_depth_begin</span>(); it != octree.<span class="hljs-built_in">leaf_depth_end</span>(); ++it) &#123;<br>  <span class="hljs-keyword">auto</span> ids = it.<span class="hljs-built_in">getLeafContainer</span>().<span class="hljs-built_in">getPointIndicesVector</span>();<br>  cloud_tmp-&gt;<span class="hljs-built_in">clear</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> id : ids) &#123;<br>    cloud_tmp-&gt;<span class="hljs-built_in">push_back</span>(octree.<span class="hljs-built_in">getInputCloud</span>()-&gt;points[id]);<br>  &#125;<br>  filter_map.<span class="hljs-built_in">setInputCloud</span>(cloud_tmp);<br>  filter_map.<span class="hljs-built_in">filter</span>(*cloud_tmp_ds);<br>  *cloud_out += *cloud_tmp_ds;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SLAM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2024秋招华为机试题目记录(2023.8.30)</title>
    <link href="/2023/08/31/2024%E7%A7%8B%E6%8B%9B%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/08/31/2024%E7%A7%8B%E6%8B%9B%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="第一题100分">第一题（100分）</h3><p>设计一个自动计算打卡时间的程序。输入：员工一天多次进出公司的时间点。输出：总有效工作时间。</p><ul><li>如果离开公司在15分钟以内，不从总时长中扣除</li><li>12:00-14:00,18:00-19:30是午休和晚餐时间，不算工作时间</li></ul><p><strong>输入描述：</strong></p><p>第一行:员工当天进门禁的次数n。</p><p>第二行:员工当天进门禁的所有时间，以空格分隔。（24小时制，格式为xx:xx）</p><p>第三行:员工当天出门禁的次数m。</p><p>第四行:员工当天出门禁的所有时间，以空格分隔。</p><p>注: 0 &lt; n,m &lt;100，不存在相同的出入门禁时间，也不存在连续的出门禁或入门禁的情况。</p><p><strong>输出描述：</strong> 当日的工作时长。</p><p><strong>样例输入</strong>： <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">5</span><br><span class="hljs-attribute">07</span>:<span class="hljs-number">50</span> <span class="hljs-number">08</span>:<span class="hljs-number">50</span> <span class="hljs-number">12</span>:<span class="hljs-number">30</span> <span class="hljs-number">13</span>:<span class="hljs-number">40</span> <span class="hljs-number">19</span>:<span class="hljs-number">50</span><br><span class="hljs-attribute">5</span><br><span class="hljs-attribute">08</span>:<span class="hljs-number">45</span> <span class="hljs-number">12</span>:<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">20</span> <span class="hljs-number">18</span>:<span class="hljs-number">30</span> <span class="hljs-number">20</span>:<span class="hljs-number">30</span><br></code></pre></td></tr></table></figure> <strong>输出：</strong><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">530<br></code></pre></td></tr></table></figure></p><p><strong>My answer:</strong> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> in,out;<br>    cin &gt;&gt; in;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">in_time</span><span class="hljs-params">(in)</span></span>;<br>    string str;<br>    <span class="hljs-type">int</span> time;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; in; i++)<br>    &#123;<br>        cin &gt;&gt; str;<br>        time = <span class="hljs-built_in">stoi</span>(str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)) * <span class="hljs-number">60</span> + <span class="hljs-built_in">stoi</span>(str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">3</span>));<br>        <span class="hljs-keyword">if</span>(time&gt;<span class="hljs-number">12</span>*<span class="hljs-number">60</span> &amp;&amp; time&lt;=<span class="hljs-number">14</span>*<span class="hljs-number">60</span>)time=<span class="hljs-number">14</span>*<span class="hljs-number">60</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(time&gt;<span class="hljs-number">18</span>*<span class="hljs-number">60</span> &amp;&amp; time&lt;=<span class="hljs-number">195</span>*<span class="hljs-number">6</span>)time=<span class="hljs-number">195</span>*<span class="hljs-number">6</span>;<br>        in_time[i] = time;<br>    &#125;<br>    cin &gt;&gt; out;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">out_time</span><span class="hljs-params">(out)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; out; i++)<br>    &#123;<br>        cin &gt;&gt; str;<br>        time = <span class="hljs-built_in">stoi</span>(str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)) * <span class="hljs-number">60</span> + <span class="hljs-built_in">stoi</span>(str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">3</span>));<br>        <span class="hljs-keyword">if</span>(time&gt;=<span class="hljs-number">12</span>*<span class="hljs-number">60</span> &amp;&amp; time&lt;<span class="hljs-number">14</span>*<span class="hljs-number">60</span>)time=<span class="hljs-number">12</span>*<span class="hljs-number">60</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(time&gt;=<span class="hljs-number">18</span>*<span class="hljs-number">60</span> &amp;&amp; time&lt;<span class="hljs-number">195</span>*<span class="hljs-number">6</span>)time=<span class="hljs-number">18</span>*<span class="hljs-number">60</span>;<br>        out_time[i] = time;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> time_sum = out_time[out<span class="hljs-number">-1</span>] - in_time[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span>(out_time[out<span class="hljs-number">-1</span>]&gt;=<span class="hljs-number">195</span>*<span class="hljs-number">6</span> &amp;&amp; in_time[<span class="hljs-number">0</span>]&lt;=<span class="hljs-number">18</span>*<span class="hljs-number">60</span>)time_sum -= <span class="hljs-number">90</span>;<br>    <span class="hljs-keyword">if</span>(out_time[out<span class="hljs-number">-1</span>]&gt;=<span class="hljs-number">14</span>*<span class="hljs-number">60</span> &amp;&amp; in_time[<span class="hljs-number">0</span>]&lt;=<span class="hljs-number">12</span>*<span class="hljs-number">60</span>)time_sum -= <span class="hljs-number">120</span>;<br>        <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; in; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> back = in_time[i];<br>        <span class="hljs-type">int</span> leave = out_time[i<span class="hljs-number">-1</span>];<br>        <span class="hljs-type">int</span> leave_time = back - leave;<br>        <span class="hljs-keyword">if</span>(leave_time &lt;= <span class="hljs-number">15</span>)<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(back&gt;=<span class="hljs-number">195</span>*<span class="hljs-number">6</span> &amp;&amp; leave&lt;=<span class="hljs-number">18</span>*<span class="hljs-number">60</span>)leave_time -= <span class="hljs-number">90</span>;<br>        <span class="hljs-keyword">if</span>(back&gt;=<span class="hljs-number">14</span>*<span class="hljs-number">60</span> &amp;&amp; leave&lt;=<span class="hljs-number">12</span>*<span class="hljs-number">60</span>)leave_time -= <span class="hljs-number">120</span>;<br>        <span class="hljs-keyword">if</span>(leave_time &gt; <span class="hljs-number">0</span>)<br>            time_sum -= leave_time;      <br>    &#125;<br>    <span class="hljs-keyword">if</span>(time_sum &lt;<span class="hljs-number">0</span>)<br>        time_sum = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; time_sum &lt;&lt;endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></p><p><strong>思路：</strong> (1)读入时间的时候，进入的时间如果在休息时间内，就设成休息时间的结束。如果离开时间在休息时间内，就设成休息时间的开始。(2)总时间首先是最后离开的时间减去一开始进入的时间。再根据起止时间的范围，判断是否减去午休和晚餐的时间。(3) 再考虑中间每次离开，如果大于15分钟，就从总时长中减去</p><h3 id="第二题200分">第二题（200分）</h3><p>已知一棵完全二叉树，满足每个结点的值是它的叶结点频率的最大值加最小值除以2减去它的父节点的值之和。给定叶节点的个数和频率，求这个完全二叉树。</p><p>如：</p><img src="/2023/08/31/2024%E7%A7%8B%E6%8B%9B%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/1.png" class="" title="fig:1"><p>输入节点数4，输入四个节点的频率。根节点的叶节点为4个节点，四个节点的最大值加最小值除以2，再减去其根节点（没有根节点），得到13。其他节点同理，可以看到计算完成后，每一个根节点到叶节点的值之和是该叶节点的频率。</p><p><strong>输入描述：</strong></p><p>第一行：叶节点个数。一定是2的n次。</p><p>第二行：每个叶节点的频率，0 &lt; x &lt; 1000000</p><p><strong>输出描述：</strong></p><p>二叉树的层序遍历，注意最后不能有空格</p><p><strong>样例输入：</strong> <figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">18 </span><span class="hljs-number">24</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure> <strong>输出：</strong><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">13 </span><span class="hljs-number">8</span> -<span class="hljs-number">10</span> -<span class="hljs-number">3</span> <span class="hljs-number">3</span> -<span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></p><p><strong>My answer:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_max_min</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; leaf, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> num, <span class="hljs-type">int</span>&amp; max, <span class="hljs-type">int</span> &amp;min)</span></span><br><span class="hljs-function"></span>&#123;<br>    min = leaf[left];<br>    max = leaf[left];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = left+<span class="hljs-number">1</span>; i &lt; left+num; i++)<br>    &#123;<br>        min = min &lt; leaf[i] ? min : leaf[i];<br>        max = max &gt; leaf[i] ? max : leaf[i];<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leaf</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>, min = <span class="hljs-number">1000000</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin &gt;&gt; leaf[i];<br>    &#125;<br>    <span class="hljs-type">int</span> layers = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">log</span>(n)/<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>)) + <span class="hljs-number">1</span>;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; fathers, fathers_tmp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; layers; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> num = n / <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,i);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,i);j++)<br>        &#123;<br>            <span class="hljs-type">int</span> value;<br>            <span class="hljs-keyword">if</span>(i != layers - <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-type">int</span> min,max;<br>                <span class="hljs-built_in">get_max_min</span>(leaf, num*(j), num, max, min);<br>                value  = (max+min)/<span class="hljs-number">2</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                value = leaf[j];<br>            fathers_tmp.<span class="hljs-built_in">push_back</span>(value);<br>            <span class="hljs-keyword">if</span>(fathers.<span class="hljs-built_in">size</span>()!=<span class="hljs-number">0</span>) value -= fathers[j/<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span>(j==n<span class="hljs-number">-1</span>)cout &lt;&lt; value &lt;&lt; endl;<br>            <span class="hljs-keyword">else</span><br>                cout &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        fathers.<span class="hljs-built_in">assign</span>(fathers_tmp.<span class="hljs-built_in">begin</span>(),fathers_tmp.<span class="hljs-built_in">end</span>());<br>        fathers_tmp.<span class="hljs-built_in">clear</span>();<br>    &#125;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路：</strong>从根节点开始按层计算。对每个节点，确定节点对应的叶节点，找到最大值最小值。同时保存上一层所有节点的父节点值加上本节点的值之和。</p><h3 id="第三题300分">第三题（300分）</h3><p>有n个任务，任务之间有依赖关系（只有做完任务A，才能做任务B），每个任务需要不同内存，在尽快完成所有任务的情况下需要的最小内存是多少</p><p><strong>输入描述：</strong></p><p>第一行：任务个数</p><p>第二行：每个任务占用内存量</p><p>第3~3+n行：任务之间的依赖关系</p><p><strong>输出描述：</strong></p><p>需要的最小内存</p><p><em>这题没做完，案例也没有记录下来。拓扑排序相关之前做的比较少，如果有时间需要刷一刷这类题。</em></p>]]></content>
    
    
    <categories>
      
      <category>2024秋招</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>c++多线程学习笔记-2</title>
    <link href="/2023/08/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/"/>
    <url>/2023/08/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/</url>
    
    <content type="html"><![CDATA[<p>单纯的mutex需要手动进行加锁和解锁，如果加锁解锁不匹配，程序就会出现bug无法运行。此外，因为抛出异常或return等操作可能导致没有解锁就退出的问题。更好的办法是采用”资源分配时初始化”(RAII)方法来加锁、解锁。此时主要会用到lock_guard和unique_lock两个类。</p><h3 id="std-lock-guard"><a href="#std-lock-guard" class="headerlink" title="std::lock_guard"></a>std::lock_guard</h3><ul><li>当构造函数被调用时，该互斥量会被自动锁定</li><li>当析构函数被调用时，该互斥量会自动解锁</li><li>lock_guard对象不能复制或移动，因此只能在局部作用域中使用</li></ul><p>例子如下，两个线程都对一个全局变量进行累加，如果不加锁线程就可能同时对a进行操作，产生矛盾。使用lock_guard，我们不需要手动解锁，在lock_guard被析构时自动解锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>std::mutex mtx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br>    &#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(mtx)</span></span>;<br>        a++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; a &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">20000</span><br></code></pre></td></tr></table></figure><p>从lock_guard的源码分析（除了构造函数和析构函数以外，没有其他函数）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Mutex</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">lock_guard</span><br>&#123;<span class="hljs-comment">// class with destructor that unlocks a mutex</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">using</span> mutex_type = _Mutex;<br><br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">lock_guard</span><span class="hljs-params">(_Mutex&amp; _Mtx)</span></span><br><span class="hljs-function">: _MyMutex(_Mtx)</span><br><span class="hljs-function">&#123;</span><span class="hljs-comment">// 构造函数中对mtx加锁</span><br>_MyMutex.<span class="hljs-built_in">lock</span>();<br>&#125;<br><br><span class="hljs-built_in">lock_guard</span>(_Mutex&amp; _Mtx, <span class="hljs-type">adopt_lock_t</span>)<br>: _MyMutex(_Mtx)<br>&#123;<span class="hljs-comment">// 当前mtx已获得变量所有权时，调用lock_guard需要加一个常数，此时不用再次加锁</span><br>&#125;<br><br>~<span class="hljs-built_in">lock_guard</span>() <span class="hljs-keyword">noexcept</span><br>&#123;<span class="hljs-comment">// 在析构函数中对mtx解锁</span><br>_MyMutex.<span class="hljs-built_in">unlock</span>();<br>&#125;<br><br>    <span class="hljs-comment">// 禁用拷贝构造和等于（不能复制和移动）</span><br><span class="hljs-built_in">lock_guard</span>(<span class="hljs-type">const</span> lock_guard&amp;) = <span class="hljs-keyword">delete</span>;<br>lock_guard&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> lock_guard&amp;) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-keyword">private</span>:<br>_Mutex&amp; _MyMutex;<br>&#125;;<br><br></code></pre></td></tr></table></figure><div class="note note-success">            <p>explicit: 构造类时不支持隐式转换。也就是必须是一个已被定义为_Mutex类的变量才能用于构造lock_guard</p>          </div><h3 id="std-unique-lock"><a href="#std-unique-lock" class="headerlink" title="std::unique_lock"></a>std::unique_lock</h3><p>相比lock_guard，unique_lock可以对互斥量做更丰富的操作，因此使用更加广泛，但同时占用的资源也会更多。</p><h4 id="操作一：自动加锁解锁"><a href="#操作一：自动加锁解锁" class="headerlink" title="操作一：自动加锁解锁"></a>操作一：自动加锁解锁</h4><p>用上述例子，将lock_guard换成unique_lock可以实现同样功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>std::mutex mtx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br>    &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(mtx)</span></span>;<br>        a++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; a &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="操作二：延迟锁定"><a href="#操作二：延迟锁定" class="headerlink" title="操作二：延迟锁定"></a>操作二：延迟锁定</h4><p>当调用函数时传入std::defer_lock，构造函数不会自动加锁，而由程序员在后续代码中决定什么时候加锁，加什么样的锁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(mtx,std::defer_lock)</span></span>;<br></code></pre></td></tr></table></figure><p>查看源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">unique_lock</span>&#123;<br>    <span class="hljs-function">xxx</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">unique_lock</span><span class="hljs-params">(_Mutex&amp; _Mtx, <span class="hljs-type">defer_lock_t</span>)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">: _Pmtx(_STD addressof(_Mtx)), _Owns(false)</span><br><span class="hljs-function">&#123;</span><span class="hljs-comment">// 构造函数什么都不做，没有加锁</span><br>&#125;<br><br>    xxx<br>&#125;<br></code></pre></td></tr></table></figure><p>之后可以进行手动加锁：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">lg.lock()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>查看源码：是调用mutex的lock函数</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sqf">  void <span class="hljs-built_in">lock</span>()<br>&#123;<span class="hljs-comment">// lock the mutex</span><br><span class="hljs-variable">_Validate</span>();<br><span class="hljs-variable">_Pmtx</span>-&gt;<span class="hljs-built_in">lock</span>();<br><span class="hljs-variable">_Owns</span> = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="操作三：尝试加锁并返回是否加锁成功-try-lock"><a href="#操作三：尝试加锁并返回是否加锁成功-try-lock" class="headerlink" title="操作三：尝试加锁并返回是否加锁成功-try_lock"></a>操作三：尝试加锁并返回是否加锁成功-try_lock</h4><p>try_lock尝试获得mutex所有权，如果可以就加锁返回true，否则返回false，程序继续往下运行。</p><p>如下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>std::mutex mtx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(mtx, std::defer_lock)</span></span>;<br>    <span class="hljs-keyword">if</span>(lg.<span class="hljs-built_in">try_lock</span>())&#123;<br>        a++;<br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">3</span>));<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        b++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>t1获得mtx所有权后，会对a加1，等待2s，此时t2尝试获取mtx所有权，但无法获取，返回false，执行b加1.</p><p>也可以写成这样：在构造函数中加入try_to_lock的参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(mtx, std::try_to_lock)</span></span>;<br>    <span class="hljs-keyword">if</span>(lock.<span class="hljs-built_in">owns_lock</span>())&#123;<br>        a++;<br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">3</span>));<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        b++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="操作四：在一段时间内尝试加锁-try-lock-for"><a href="#操作四：在一段时间内尝试加锁-try-lock-for" class="headerlink" title="操作四：在一段时间内尝试加锁-try_lock_for"></a>操作四：在一段时间内尝试加锁-try_lock_for</h4><p>try_lock_for尝试在一定时间内获得mutex所有权，如果可以就加锁返回true，否则返回false，程序继续往下运行。</p><p>如下面的例子：(此时mutex要选用timed_mutex)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>std::timed_mutex mtx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-function">std::unique_lock&lt;timed_mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(mtx, std::defer_lock)</span></span>;<br>    <span class="hljs-keyword">if</span>(lg.<span class="hljs-built_in">try_lock_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>)))&#123;<br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">2</span>));<br>        a++;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        b++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>t1获得mtx所有权后，会对a加1，等待2s，此时t2尝试在5s内获取mtx所有权。在等待过程中t1休眠完毕，释放mtx所有权，t2就可以加锁，再对a加1。最终a&#x3D;2,b&#x3D;0</p><h4 id="特性：所有权可以移动但是不能复制"><a href="#特性：所有权可以移动但是不能复制" class="headerlink" title="特性：所有权可以移动但是不能复制"></a>特性：所有权可以移动但是不能复制</h4><p>查看源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++">    <span class="hljs-built_in">unique_lock</span>(unique_lock&amp;&amp; _Other) <span class="hljs-keyword">noexcept</span><br>: _Pmtx(_Other._Pmtx), _Owns(_Other._Owns)<br>&#123;<span class="hljs-comment">// 可以移动另一个mutex的所有权</span><br>_Other._Pmtx = <span class="hljs-literal">nullptr</span>;<br>_Other._Owns = <span class="hljs-literal">false</span>;<br>&#125;<br><br>unique_lock&amp; <span class="hljs-keyword">operator</span>=(unique_lock&amp;&amp; _Other)<br>&#123;<span class="hljs-comment">// 等号可以用于移动另一个mutex的所有权</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != _STD <span class="hljs-built_in">addressof</span>(_Other))<br>&#123;<br><span class="hljs-keyword">if</span> (_Owns)<br>_Pmtx-&gt;<span class="hljs-built_in">unlock</span>();<br>_Pmtx = _Other._Pmtx;<br>_Owns = _Other._Owns;<br>_Other._Pmtx = <span class="hljs-literal">nullptr</span>;<br>_Other._Owns = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> (*<span class="hljs-keyword">this</span>);<br>&#125;<br><br>    <span class="hljs-built_in">unique_lock</span>(<span class="hljs-type">const</span> unique_lock&amp;) = <span class="hljs-keyword">delete</span>;<br>    unique_lock&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> unique_lock&amp;) = <span class="hljs-keyword">delete</span>;<br>```  <br><br>### <span class="hljs-built_in">call_once</span>()<br><br>使用场景：某些类是单例模式，在整个程序中只能创建一个实例，此时多线程调用可能有问题。<br><br>如下面的例子，该类使用了一个静态成员函数 <span class="hljs-built_in">getInstance</span>() 来获取单例实例，用了一个静态局部变量 instance 来存储单例实例。由于静态局部变量只会被初始化一次，因此该实现可以确保单例实例只会被创建一次。<br><br>```C++<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>         <span class="hljs-type">static</span> Singleton instance;<br>         <span class="hljs-keyword">return</span> instance;<br>    &#125;    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setData</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>         m_data = data;<br>    &#125;    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>         <span class="hljs-keyword">return</span> m_data;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125; <span class="hljs-comment">//构造函数为private</span><br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;    <span class="hljs-comment">// 禁用拷贝构造和等号</span><br>    <span class="hljs-type">int</span> m_data = <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>但如果多个线程同时调用 getInstance() 函数，可能会导致多个对象被创建，从而违反了单例模式的要求。并且可能会出现多个线程同时调用 setData() 函数来修改m_data，可能会导致数据不一致或不正确的结果。</p><p>此时可以用call_once函数，call_once函数将输入一个std::once_flag类型的变量，用于标记该函数是否已经被调用过。将该类改写为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>            std::<span class="hljs-built_in">call_once</span>(m_onceFlag, &amp;Singleton::init);<br>            <span class="hljs-keyword">return</span> *m_instance;<br>    &#125;    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setData</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>        m_data = data;<br>    &#125;    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;        <br>    <span class="hljs-keyword">return</span> m_data;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;    <br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        m_instance.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> Singleton);<br>    &#125;    <br>    <span class="hljs-type">static</span> std::unique_ptr&lt;Singleton&gt; m_instance;    <br>    <span class="hljs-type">static</span> std::once_flag m_onceFlag;    <br>    <span class="hljs-type">int</span> m_data = <span class="hljs-number">0</span>;<br>&#125;;<br><br>std::unique_ptr&lt;Singleton&gt; Singleton::m_instance;<br>std::once_flag Singleton::m_onceFlag;<br></code></pre></td></tr></table></figure><p>此时，我们创建了一个静态成员变量 m_onceFlag 来标记初始化是否已经完成。在 getInstance() 函数中，我们使用 std::call_once 来调用 init() 函数，仅当第一次调用时m_onceFlag有效，可以调用init()。后续再有线程运行到此处无法调用init()，直接返回该实例。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="http://www.seestudy.cn/?list_9/">陈子青C++公开课:C++11 跨平台多线程编程与线程池</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++多线程学习笔记-1</title>
    <link href="/2023/08/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
    <url>/2023/08/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>进程与线程：</p><p>进程是运行中的程序。</p><p>线程是进程中可并行的一个子程序，主要目的是提高程序运行效率。最大线程个数是CPU核数。</p>          </div><h3 id="Thread线程库的基本使用"><a href="#Thread线程库的基本使用" class="headerlink" title="Thread线程库的基本使用"></a>Thread线程库的基本使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printMessage</span><span class="hljs-params">(std::string msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; msg &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(printMessage, <span class="hljs-string">&quot;Hello thread!&quot;</span>)</span></span>;<br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li><p>定义一个线程：</p> <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-title">std::</span><span class="hljs-keyword">thread</span>(function_name, args)<br></code></pre></td></tr></table></figure></li><li><p>等待线程完成</p> <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">t.<span class="hljs-keyword">join</span>()<br></code></pre></td></tr></table></figure><p> 等待线程完成后主程序才往下运行。如果没有这一句，上面的线程在没有打印完msg时主程序已结束，就会报错。</p></li><li><p>分离线程</p> <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">t.detach<span class="hljs-comment">()</span><br></code></pre></td></tr></table></figure><p> 分离线程，让它在后台运行。往往用于多进程的情况。</p></li><li><p>joinable</p> <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">bool isJoin <span class="hljs-operator">=</span> t.joinable()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p> joinable()方法返回一个布尔值，如果线程可以被join()或detach()，则返回true，否则返回false。防止直接使用join报错。</p></li></ol><h4 id="变量未定义问题"><a href="#变量未定义问题" class="headerlink" title="变量未定义问题"></a>变量未定义问题</h4><p>传递的函数需要引用，指针类型变量时容易出现的线程没运行完，变量已被释放的问题。</p><ol><li><p>函数参数是引用</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span></span>&#123;<br>    x += <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(foo, std::ref(a))</span></span>;<br>    t.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; a &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> std::ref用于取某个变量的引用，但要保证在线程函数执行期间，变量 <code>a</code> 的生命周期是有效的。</p></li><li><p>函数参数是指针</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>* x)</span></span>&#123;<br>    std::cout &lt;&lt; *x &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> *ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(foo, ptr)</span></span>;<br>    <span class="hljs-comment">// delete ptr;</span><br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 如果在注释处释放指针，线程还没执行完，foo函数根据地址取到的就是一个未知的数。</p></li><li><p>解决方法：用智能指针</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>&#123;<br>        std::cout&lt;&lt; <span class="hljs-string">&quot;Hello!&quot;</span> &lt;&lt; std::endl; <br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::shared_ptr&lt;A&gt; a = std::make_shared&lt;A&gt;;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(&amp;A::foo, a)</span></span>;<br><br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 用智能指针来定义需要传递的指针参数，这样该参数就能在不需要的时候自动析构。</p></li><li><p>入口函数为类的私有函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// friend void thread_foo();</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>&#123;<br>        std::cout&lt;&lt; <span class="hljs-string">&quot;Hello!&quot;</span> &lt;&lt; std::endl; <br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::shared_ptr&lt;A&gt; a = std::make_shared&lt;A&gt;;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(&amp;A::foo, a)</span></span>;<br><br>    t.<span class="hljs-built_in">join</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">thread_foo</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果直接运行，会报错，因为函数thread_foo无法访问类的私由函数。但用注释那行，将该函数设为友元，则可以访问。</p></li></ol><h3 id="互斥量mutex"><a href="#互斥量mutex" class="headerlink" title="互斥量mutex"></a>互斥量mutex</h3><p>多个线程访问一个变量，且对变量进行修改，此时会出现函数竞争问题，导致函数运行结果不确定。因此需要用到互斥锁，使得每次只能有一个程序访问变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>std::mutex mtx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br>    &#123;<br>        mtx.<span class="hljs-built_in">lock</span>();<br>        a += <span class="hljs-number">1</span>;<br>        mtx.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; a &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>倘若不加互斥锁，可能导致多个线程对a操作，此时操作重叠就可能出现问题。加了互斥锁，每次只能有一个线程访问a，使得最终<code>a=20000</code></p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>如下面程序中的情况，线程<code>t1</code>运行<code>func1</code>，获取了<code>mtx1</code>的所有权，如果此时正好线程<code>t2</code>运行<code>func2</code>获得了<code>mtx2</code>的所有权。那就会出现<code>t1</code>,<code>t2</code>都在等对方，都无法运行的死锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br>std::mutex mtx1, mtx2;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123;  <br>    mtx1.<span class="hljs-built_in">lock</span>();  <br>    mtx2.<span class="hljs-built_in">lock</span>();                  <br>    mtx2.<span class="hljs-built_in">unlock</span>();<br>    mtx1.<span class="hljs-built_in">unlock</span>();    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123;    <br>    mtx2.<span class="hljs-built_in">lock</span>();<br>    mtx1.<span class="hljs-built_in">lock</span>();        <br>    mtx1.<span class="hljs-built_in">unlock</span>();    <br>    mtx2.<span class="hljs-built_in">unlock</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func1)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func2)</span></span>;    <br>    t1.<span class="hljs-built_in">join</span>();    <br>    t2.<span class="hljs-built_in">join</span>();    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.seestudy.cn/?list_9/">http://www.seestudy.cn/?list_9/</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pyside6安装后报错及解决方法</title>
    <link href="/2023/08/24/pyside6%E5%AE%89%E8%A3%85%E5%90%8E%E4%BD%BF%E7%94%A8%E6%8A%A5%E9%94%99/"/>
    <url>/2023/08/24/pyside6%E5%AE%89%E8%A3%85%E5%90%8E%E4%BD%BF%E7%94%A8%E6%8A%A5%E9%94%99/</url>
    
    <content type="html"><![CDATA[<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>ubuntu 20.04</p><h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><p>通过pip安装完后pyside6，使用时报错</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">qt.qpa.plugin: Could <span class="hljs-keyword">not</span> <span class="hljs-built_in">load</span> <span class="hljs-keyword">the</span> Qt <span class="hljs-built_in">platform</span> plugin <span class="hljs-string">&quot;xcb&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;&quot;</span> even though <span class="hljs-keyword">it</span> was found.<br>This application failed <span class="hljs-built_in">to</span> <span class="hljs-built_in">start</span> because no Qt <span class="hljs-built_in">platform</span> plugin could be initialized. Reinstalling <span class="hljs-keyword">the</span> application may fix this problem.<br><br>Available <span class="hljs-built_in">platform</span> plugins are: offscreen, wayland-egl, linuxfb, vkkhrdisplay, minimalegl, minimal, wayland, xcb, eglfs, vnc.<br><br>Aborted (core dumped)<br></code></pre></td></tr></table></figure><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>参考<a href="https://blog.csdn.net/LOVEmy134611/article/details/107212845">https://blog.csdn.net/LOVEmy134611/article/details/107212845</a></p><ol><li><p>修改脚本文件<code>~/.bashrc</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">vim ~/.bashrc</span><br></code></pre></td></tr></table></figure></li><li><p>在最后加入</p> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">QT_DEBUG_PLUGINS</span>=1<br></code></pre></td></tr></table></figure></li><li><p>保存退出，使配置文件生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">source</span> ~/.bashrc</span><br></code></pre></td></tr></table></figure></li><li><p>再次调用pyside6函数，查看详细报错输出，在最下方找到</p> <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">xxx<br>libxcb-cursor.<span class="hljs-keyword">so</span>.0: cannot <span class="hljs-keyword">open</span> shared object <span class="hljs-keyword">file</span>: <span class="hljs-keyword">No</span> such <span class="hljs-keyword">file</span> or directory<br>xxx<br></code></pre></td></tr></table></figure></li><li><p>安装库libxcb-cursor0后，能够正常运行</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> libxcb-cursor0<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2024秋招美团笔试题目记录(2023.8.12, 2023.8.19)</title>
    <link href="/2023/08/12/2024%E7%A7%8B%E6%8B%9B%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95(2023.8.12,2023.8.19)/"/>
    <url>/2023/08/12/2024%E7%A7%8B%E6%8B%9B%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95(2023.8.12,2023.8.19)/</url>
    
    <content type="html"><![CDATA[<h2 id="section">8.12</h2><h3 id="第一题">第一题</h3><p><strong>题目描述：</strong></p><p>给定一个排列<span class="math inline">\(A = [a_1, a_2, ...,a_n]\)</span>，数字不重复。给定两个数x, y, 判断x, y在A中是否相邻，输出yes or no.</p><p><strong>例子：</strong> 输入第一行是A的长度，第二行A，第三行x y</p><p>Input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>Output: <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">No</span><br></code></pre></td></tr></table></figure></p><h3 id="第二题">第二题</h3><p><ahref="https://leetcode.cn/problems/distance-between-bus-stops/">Leetcode1184. 公交站间的距离</a></p><h3 id="第三题">第三题</h3><p><strong>题目描述：</strong></p><p>给一个矩阵<spanclass="math inline">\(A_{mxn}\)</span>，代表一块蛋糕，每个位置的值<spanclass="math inline">\(A_{i,j}\)</span>代表这部分蛋糕的美味度，横着或竖着切一刀，使得两部分蛋糕美味度之差尽可能小。输出最小的差。</p><p><strong>例子：</strong> 输入第一行是m，n，第二行开始是A</p><p>Input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span> <br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>Output: <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">0<br></code></pre></td></tr></table></figure></p><h3 id="第四题">第四题</h3><p><strong>题目描述：</strong>给定一棵树，开始时所有节点为白色。如果两个相连的节点的值相乘是完全平方数，且它们都是白色，可以将这两个节点染成红色。输出最多能染色几个节点。</p><p><strong>例子：</strong>输入第一行是节点数n，第二行是各个节点的值，接下来n-1行是节点的边</p><p>Input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">3</span> <span class="hljs-number">12</span> <br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>Output: <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure></p><p>My answer: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">issquare</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">sqrt</span>(n));<br>    <span class="hljs-keyword">if</span>(x * x == n)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Solution</span>(<span class="hljs-type">int</span> n)<br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>            edge.<span class="hljs-built_in">resize</span>(n, tmp);<br>            match.<span class="hljs-built_in">resize</span>(n, <span class="hljs-number">-1</span>);<br>            num = n;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">        </span>&#123;<br>            edge[i].<span class="hljs-built_in">push_back</span>(j);<br>            edge[j].<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search_max</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (match[i] != <span class="hljs-number">-1</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j:edge[i])<br>            &#123;<br>                <span class="hljs-keyword">if</span> (match[j] == <span class="hljs-number">-1</span> || <span class="hljs-built_in">search</span>(match[j]))<br>                &#123;<br>                    match[i] = j;<br>                    match[j] = i;<br>                    sum++;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : edge[i])<br>        &#123;<br>            <span class="hljs-keyword">if</span>(j == match[i])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(match[j] == <span class="hljs-number">-1</span> || <span class="hljs-built_in">search</span>(match[j]))<br>            &#123;<br>                match[i] = j;<br>                match[j] = i;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> num;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; edge;<br>        vector&lt;<span class="hljs-type">int</span>&gt; match;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n) &#123; <span class="hljs-comment">// 注意 while 处理多个 case</span><br>        <span class="hljs-function">Solution <span class="hljs-title">s</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">value</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            cin &gt;&gt; value[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> x, y;<br>            cin &gt;&gt; x &gt;&gt; y;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">issquare</span>(value[x<span class="hljs-number">-1</span>] * value[y<span class="hljs-number">-1</span>]))&#123;<br>                s.<span class="hljs-built_in">add_edge</span>(x - <span class="hljs-number">1</span>, y - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;        <br>        cout &lt;&lt; s.<span class="hljs-built_in">search_max</span>() * <span class="hljs-number">2</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="section-1">8.19</h2><h3 id="第一题-1">第一题</h3><p><strong>题目描述：</strong></p><p>给定一个整数x，一个上限m，当x超过上限m时从1开始重新计数（就是取余）</p><p><strong>例子：</strong></p><p>输入第一个数x，第二个m</p><p>Input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>Output: <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>2<br>4<br>2<br></code></pre></td></tr></table></figure></p><h3 id="第二题-1">第二题</h3><p>输入一个整数数组<spanclass="math inline">\(\{a_i\}\)</span>，总和<spanclass="math inline">\(sum=a_1 + a_2 + ... +a_n\)</span>，可以将其中一个加号换成乘号，也可以不换。求可能的sum的最大值</p><p><strong>例子：</strong></p><p>第一行是数组个数</p><p>第二行是数组元素</p><p>Input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>Output: <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">24<br></code></pre></td></tr></table></figure> 1 + 2 + 4 * 5 + 1 = 24</p><p>可以枚举乘号的位置，只需要注意<spanclass="math inline">\(a_i\)</span>变量类型设为long long int</p><h3 id="第三题-1">第三题</h3><p><strong>题目描述：</strong></p><p>对于一个只含0，1的字符串，对其某一位取反定义为操作一次，对一个字符串操作最少次数使其相邻两位不同，这个最少次数为字符串的权值。现给定一个字符串，求其所有字符串的权值之和。</p><p><strong>例子：</strong></p><p>Input:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">10001<br></code></pre></td></tr></table></figure><p>Output: <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">8<br></code></pre></td></tr></table></figure> 长度为2的子串：两个00，每个权重为1长度为3的子串：3个子串，每个权重为1 长度为4的子串：2个子串，每个权重为1长度为5的子串：1个，权重为1 总共 2 + 3 + 2 + 1 = 8</p><p>My answer:假设对长度为len,结束位置为i的子字符串，使其变为相邻两位不同且最后一位为0的最小变换次数为<spanclass="math inline">\(a_0[len][i]\)</span>,最后一位为1的最小变换次数为<spanclass="math inline">\(a_1[len][i]\)</span>。则递推公式为</p><p>若s[i] = 0：</p><p><span class="math display">\[a_0[len][i] = min(a_1[len - 1][i-1], len- 1)\]</span> <span class="math display">\[a_1[len][i] = min(a_0[len -1][i-1], len)\]</span></p><p>s[i] = 1同理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; s) &#123; <span class="hljs-comment">// 注意 while 处理多个 case</span><br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a0</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">a0_tmp</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a1</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">a1_tmp</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;0&#x27;</span>)<br>                a1[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                a0[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">2</span>; l &lt;= n; l++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>; i &lt; n; i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;0&#x27;</span>)<br>                &#123;<br>                    a0_tmp[i] = <span class="hljs-built_in">min</span>(a1[i<span class="hljs-number">-1</span>], l - <span class="hljs-number">1</span>);<br>                    a1_tmp[i] = <span class="hljs-built_in">min</span>(a0[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>, l);<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    a1_tmp[i] = <span class="hljs-built_in">min</span>(a0[i<span class="hljs-number">-1</span>], l - <span class="hljs-number">1</span>);<br>                    a0_tmp[i] = <span class="hljs-built_in">min</span>(a1[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>, l);<br>                &#125;<br>                sum += <span class="hljs-built_in">min</span>(a0_tmp[i],a1_tmp[i]);<br>            &#125;<br>            a0.<span class="hljs-built_in">swap</span>(a0_tmp);<br>            a1.<span class="hljs-built_in">swap</span>(a1_tmp);<br>        &#125;<br>        cout &lt;&lt; sum &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第四题-1">第四题</h3><p><strong>题目描述：</strong>给定n个正数，一次操作可以对一个数加1，一个数减1.问使其众数出现次数最多的最少操作数。</p><p><strong>例子：</strong></p><p>第一行是n</p><p>第二行是n个数</p><p>Input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span> <br><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>Output: <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>0<br></code></pre></td></tr></table></figure></p><p>这题没做出来，只想到</p><ul><li><p>如果<spanclass="math inline">\(a_i\)</span>的总和sum能整除n，那最小次数就是 <spanclass="math inline">\(\frac{1}{2}\sum \|a_i -\frac{sum}{n}\|\)</span></p></li><li><p>如果不整除，众数个数已等于n-1，答案就是0</p></li><li><p>其他情况：n个数，将其中n-1个变为值v，要次数最少那剩余的一个一定是最大值或最小值。应该要枚举v的可能取值？</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>2024秋招</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/08/10/hello-world/"/>
    <url>/2023/08/10/hello-world/</url>
    
    <content type="html"><![CDATA[<h2 id="写博客的初衷"><a href="#写博客的初衷" class="headerlink" title="写博客的初衷"></a>写博客的初衷</h2><p>有一个毛病困扰了我很久，也是近几年阻碍我向前走的主要原因———我消极的完美主义。</p><p>追溯它的源头，大概是我从小在与世界交互时，收到一些负反馈（比如难以建立良好的人际关系，感觉到他人的疏远，排斥，不喜），我没有勇敢地去面对问题，而是更封闭自己，开始在虚假的幻想中获得安慰。看那些虚无缥缈的小说，假设自己是一个完美的被所有人爱的主角，每晚在这样幻想中沉沉睡去。我变得逃避现实，不敢面对问题；我追求一个完美的虚假的形象；我极度渴望得到他人的认可与爱。</p><p>这些病态的心理导致了我严重的拖延症，行动力差，自我封闭。我在工作时经常陷入无关紧要的细节，在多人场合中保持沉默，甚至连朋友圈都不敢发。我得想办法解决或者改善这个毛病。</p><p>我尝试通过看书找到药方，或者用道理说服自己。从心理上来说，我要改变的底层认知是：接受不完美的自己；意识到微小的进步有巨大的意义。但从小扎根在心底的认知似乎很难改变。我想应该直接从行动出发，或许写博客是一个很好的治愈方法。</p><p>在博客中尽量把我真实的所思所想，我的学习过程写出来，一段粗糙的读书笔记也好，一个简单的技术问题总结也好，尽管不完美也可以直接发出来，被素不相识的人们看到。浅薄无知，笨拙粗糙都没有关系，在一点点的进步中，或许我也会得到肯定和鼓励，而这将带给我莫大的欢喜。</p><h2 id="关于西西弗斯的石头"><a href="#关于西西弗斯的石头" class="headerlink" title="关于西西弗斯的石头"></a>关于西西弗斯的石头</h2><p>西西弗斯的神话里，他绑架了死神，让世间没有死亡，因此受到惩罚，要将一块巨石推上山顶，石头快到山顶就滚落，西西弗斯因此永无止境地重复这样毫无意义的事。</p><p>在加缪对这个故事的解释里，人生就和推石块一样，一样的荒谬，一样的无意义。但当西西弗斯去在意脚下的泥土，去观察巨石的颗粒，当他勇敢无畏地，坚定地选择一次一次推上石块，与虚无进行抗争时，他就为自己创造了意义。我读到这个故事时深为触动，后来看了一些对存在主义哲学的介绍，这些观念塑造了我基础的人生观：</p><p><strong>人生没有既定的意义，需要自己去赋予。但存在本身是有意义的，只有存在才能观察，才能感受。</strong> 因此这个博客也以此为名，这是我的石头，是我认为或许没意义但是要做的事，而我将在这个过程去体验，去观察，去感受。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
