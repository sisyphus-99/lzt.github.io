<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>图片消失点，地平线标定相机</title>
    <link href="/2023/09/29/%E5%9B%BE%E7%89%87%E6%B6%88%E5%A4%B1%E7%82%B9%E5%9C%B0%E5%B9%B3%E7%BA%BF%E6%A0%87%E5%AE%9A%E7%9B%B8%E6%9C%BA/"/>
    <url>/2023/09/29/%E5%9B%BE%E7%89%87%E6%B6%88%E5%A4%B1%E7%82%B9%E5%9C%B0%E5%B9%B3%E7%BA%BF%E6%A0%87%E5%AE%9A%E7%9B%B8%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>用消失点和地平线标定相机是我的一项工作中的内容，其中涉及的一些多视图几何原理，在此做一个整理和回顾。</p>          </div><h3id="用道路消失点标定相机与道路的roll和pitch">用道路消失点标定相机与道路的roll和pitch</h3><p>从直观定义上来说，消失点是空间中的平行线投影到图像平面后产生的交点，可以认为三维空间中的平行线在无穷远处相交。那么从数学上，空间中一个方向与图像中消失点坐标的关系是怎样的呢？</p><p>空间点投影到2D平面的方程如下：</p><p><span class="math display">\[\lambda \left[ \begin{matrix}    u \\ v \\ 1\end{matrix}\right] = K [R | t] \left[ \begin{matrix}    x \\ y \\ z \\ 1\end{matrix}\right]\]</span></p><p>空间中一条直线可以由一个方向向量为<spanclass="math inline">\(\vec{v}\)</span>，一个点为<spanclass="math inline">\(P_0\)</span>来定义。这条直线上的点可以表示为：</p><p><span class="math display">\[P = P_0 + k \vec{v} \]</span></p><p>取不同的<spanclass="math inline">\(P_0\)</span>可以得到一组平行的直线</p><p>把P代入投影方程，得到：</p><p><span class="math display">\[\lambda \left[ \begin{matrix}    u \\ v \\ 1\end{matrix}\right] = K [R | t] \left[ \begin{matrix}    P_0 + k\vec{v} \\ 1\end{matrix}\right]\]</span></p><p>消失点可以理解为空间直线无穷远处的点，即<spanclass="math inline">\(k\to \infty\)</span>，此时<spanclass="math inline">\(P_0\)</span>和下面的1都约等于0. 那么公式转为：</p><p><span class="math display">\[ \lambda \left[ \begin{matrix}    u \\ v \\ 1\end{matrix}\right] = K [R | t] \left[ \begin{matrix}    \vec{v} \\ 0\end{matrix}\right] = KR \vec{v}\]</span></p><p>现在来看如何进行标定。假设我们的世界坐标系建立在道路方向上，绕z,x,y的角分别为roll，pitch,yaw</p><center><img src="1.png" width="100%" height="100%" /></center><p>那么道路的方向<span class="math inline">\(\vec{v}\)</span>即为<spanclass="math inline">\((0,0,1)\)</span></p><p>得到</p><p><span class="math display">\[\lambda p = K R \left[ \begin{matrix}    0 \\ 0 \\ 1\end{matrix}\right] = KR_3 = K \left[ \begin{matrix}    -cos(pitch)sin(yaw) \\ sin(pitch) \\ cos(pitch)cos(yaw)\end{matrix}\right] \]</span></p><p>可以看到只留下了pitch,yaw角。说明消失点对于roll角是不可观的。</p><p>我们可以利用旋转矩阵正交性（列向量模为1）消去<spanclass="math inline">\(\lambda\)</span></p><p><span class="math display">\[\frac{K^{-1}p}{\|K^{-1}p\|} = \left[\begin{matrix}    -cos(pitch)sin(yaw) \\ sin(pitch) \\ cos(pitch)cos(yaw)\end{matrix}\right] \]</span></p><p>左边已知，可求出pitch和yaw</p><h3 id="用地平线估计roll角">用地平线估计roll角</h3><p>这里所指的地平线可以认为是地平面和与其平行的平面在无穷远处的交线。</p><p>一个简单的推导如下：假设相机坐标系下的三维消失线为<spanclass="math inline">\(l_\infty\)</span>,消失点为<spanclass="math inline">\(P_\infty\)</span>(都是齐次坐标系表示），那么有</p><p><span class="math display">\[P_\infty^T l_\infty = 0\]</span></p><p><span class="math display">\[P_\infty^T K^T K^{-T} l_\infty =0\]</span></p><p><span class="math display">\[(KP_\infty)^T K^{-T} l_\infty =0\]</span></p><p>而<span class="math inline">\(p_\infty = KP_\infty\)</span></p><p><span class="math display">\[(p_\infty)^T (K^{-T} l_\infty) =0\]</span></p><p>则<span class="math inline">\(l_{horizon} = K^{-T}l_\infty\)</span></p><p>因此有以下等式，其中g为重力向量，R为世界坐标系到相机坐标系的旋转，K为内参，h是地平线在图像上投影的直线的齐次坐标。</p><p><span class="math display">\[h\propto K^{-T}Rg\]</span></p><p>在上图的道路坐标系下，重力向量可以表示为<spanclass="math inline">\([0,1,0]\)</span>，</p><p><span class="math display">\[\left[\begin{matrix}    h_1 \\ h_2 \\ h_3\end{matrix}\right]=h\propto K^{-T}R_2\]</span></p><p>图像平面上地平线的倾斜角<span class="math inline">\(\theta =arctan(-\frac{h_1}{h_2})\)</span></p><h3 id="用多个消失点估计相机内外参">用多个消失点估计相机内外参</h3><h4id="用三个正交方向的消失点标定相机内外参">用三个正交方向的消失点标定相机内外参</h4><p><strong>求解内参：</strong></p><p>在符合Manhattan假设的环境中（通常是人造建筑物），画面中存在三个正交的方向，如下图所示：</p><center><img src="2.png" width="100%" height="100%" /></center><p>此时我们可以用图像上的三个消失点求解完整的相机内外侧。</p><p>我们把世界坐标系建在这个方向，那么这三个方向在世界坐标系下的方向可以定义为</p><p><span class="math display">\[e_1=\left[\begin{matrix}1 \\ 0 \\ 0\end{matrix}\right], e_2=\left[\begin{matrix}0 \\ 1 \\ 0\end{matrix}\right], e_3=\left[\begin{matrix}0 \\ 0 \\ 1\end{matrix}\right],\]</span></p><p>可以得到：</p><p><span class="math display">\[\lambda_i p_i = K R e_i\]</span></p><p><span class="math display">\[ e_i = \lambda R^T K^{-1}p_i\]</span></p><p>由 <span class="math inline">\(e_i^Te_j = 0\)</span>，可以得到：</p><p><span class="math display">\[ p_i^TK^{-T} R R^T K^{-1} p_j =p_i^TK^{-T} K^{-1} p_j = 0\]</span></p><p>这样两个消失点可以构建一个内参K的方程。</p><p>相机内参矩阵K可以表示为</p><p><span class="math display">\[ \left[ \begin{matrix}    f &amp; 0 &amp; c_x \\ 0 &amp; f &amp; c_y \\ 0 &amp; 0 &amp; 1\end{matrix}\right] \]</span></p><p>这样有3个参数，三个消失点两两配对有三组，可以建立3个方程，求出K</p><p>然而具体求解时消失点在图像平面上也可能是无穷远：</p><center><img src="3.png" width="100%" height="100%" /></center><p>第一种情况下相机坐标系和世界坐标系轴方向一致，两个消失点在图像平面上为无穷远，此时我们得到图像平面上一个有限的消失点，两个无穷远的消失点。此时只能标定光心距——有限的消失点位置<spanclass="math inline">\((u_0, v_0)\)</span>即为内参<spanclass="math inline">\(u_0, v_0\)</span>。</p><p><strong>求解外参旋转：</strong></p><p><span class="math display">\[\lambda_i p_i = K R e_i =KR_i\]</span></p><p>根据<span class="math inline">\(\|R_i\|=1\)</span>可以求出<spanclass="math inline">\(\lambda_i=\frac{1}{\|K^{-1}p_i\|}\)</span></p><p><span class="math display">\[ \left [ \begin{matrix}    \lambda_1 p_1 &amp; \lambda_2 p_2 &amp; \lambda_3 p_3\end{matrix} \right] = KR\]</span></p><p><span class="math display">\[ R = K^{-1}  \left [ \begin{matrix}    \lambda_1 p_1 &amp; \lambda_2 p_2 &amp; \lambda_3 p_3\end{matrix} \right] \]</span></p><h3 id="参考文献">参考文献</h3><p>[1] Temporally Consistent Horizon Lines</p><p>[2]https://www.cs.princeton.edu/courses/archive/fall13/cos429/lectures/11-epipolar</p>]]></content>
    
    
    <categories>
      
      <category>SLAM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2024秋招速腾聚创笔试记录(2023.9.4)</title>
    <link href="/2023/09/28/%E9%80%9F%E8%85%BE%E8%81%9A%E5%88%9B%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/09/28/%E9%80%9F%E8%85%BE%E8%81%9A%E5%88%9B%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="编程题">编程题</h3><h4 id="跳跃游戏">跳跃游戏</h4><p>https://leetcode.cn/problems/jump-game/</p><h4 id="迷宫找最短路径">迷宫找最短路径</h4><p>https://blog.csdn.net/weixin_46846304/article/details/116125437</p><h3 id="问答题">问答题</h3><h4 id="手写点云欧式聚类">1 手写点云欧式聚类</h4><p>写一个函数实现点云欧式聚类，类内最大距离为ClusterTolerance，类内最少点数为MinClusterSize</p><p>点和点云的结构： <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>&#123;<br>    <span class="hljs-type">double</span> x;<br>    <span class="hljs-type">double</span> y;<br>    <span class="hljs-type">double</span> z;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PointCloud</span>&#123;<br>    std::vector&lt;Point&gt; points;<br>    <span class="hljs-type">int</span> size;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>参考pcl中欧式聚类的方法：</p><p>(1)先把点云存成kd-tree</p><p>(2)初始化一个空类cluster，和一个空队列Q</p><p>(3)取一个未分类的点加入队列。</p><p>(4)推出队列的第一个点加入类，找所有离这个点距离小于d且未处理过的点加入队列。重复直到队列为空</p><p>(5)判断cluster的点数是否足够。足够则保留这个类。返回第（2）步</p><p>(6)直到所有点都处理过后结束。</p><h4 id="求两个坐标系的旋转矩阵">2 求两个坐标系的旋转矩阵</h4><p>A坐标系x轴朝上，y轴向前，z轴朝左。B坐标系x轴向前，y轴向左，z轴朝上。求A坐标系到B坐标系的旋转矩阵。</p><img src="/2023/09/28/%E9%80%9F%E8%85%BE%E8%81%9A%E5%88%9B%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/1.png" class="" title="fig:1"><p>首先注意到坐标系是左手坐标系，因此旋转的正方向可以用左手判断。从A到B相当于绕z轴转90度，再绕x轴转90度</p><p><span class="math display">\[R = R(Z)R(Y)R(X) = \left[ \begin{matrix}0&amp; 1&amp; 0 \\ -1&amp; 0 &amp; 0 \\ 0&amp; 0&amp; 1\end{matrix}\right] \left[ \begin{matrix} 1&amp; 0&amp; 0 \\ 0&amp; 0&amp; 1 \\ 0&amp; -1&amp; 0\ \end{matrix}\right] \]</span></p><h4 id="拟合平面方程">3 拟合平面方程</h4><p>已知n个点<spanclass="math inline">\(P_i,i=0,1,...,n-1\)</span>，坐标为<spanclass="math inline">\((x_i, y_i,z_i)\)</span>。拟合成平面Ax+By+Cz+D=0.</p><p>（1）求最小二乘解的函数形式</p><p><spanclass="math display">\[f=\sum_{i=0}^n(Ax_i+By_i+Cz_i+D)^2\]</span></p><p>（2）求平面的最小二乘解</p><p>令<span class="math inline">\(f&#39;_A=0, f&#39;_B=0, f&#39;_C=0,f&#39;_D=0\)</span>，解方程，具体形式在此处不推导了</p><p>（3）若求出平面为Ax+By+Cz+D=0，如何计算该平面与z=(0,0,1)方向的旋转</p><p>平面法向量为<span class="math inline">\(\vec{p}=(A,B,C)\)</span></p><p><span class="math display">\[\vec{n} = \vec{z} \times\vec{p}  \]</span> <span class="math display">\[R = cos\theta +(1-cos(\theta)\vec{n}\vec{n}^T)+sin\theta n^\wedge\]</span></p>]]></content>
    
    
    <categories>
      
      <category>2024秋招记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LOAM论文与代码阅读（三）IMU运动补偿相关代码</title>
    <link href="/2023/09/23/LOAM%E8%AE%BA%E6%96%87%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB3/"/>
    <url>/2023/09/23/LOAM%E8%AE%BA%E6%96%87%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB3/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>LOAM代码中使用的是IMU进行运动补偿。这部分在思想上比较简单，即用IMU积分得到各个点相对开始时刻的位姿。但实际上涉及一些坐标系转换，积分，时间戳问题，因此对代码进一步阅读。</p>          </div><h3 id="imu数据处理">IMU数据处理</h3><p>对于发布的IMU消息，首先还原加速度，然后利用加速度积分得到当前imu的速度，位置，而姿态可以直接使用，存成IMUState，加入队列。</p><p><font color=gray>IMU设置后一般可以直接输出四元数，由加速度积分得到。但不会输出速度，因为加速度不准，积分很容易发散。</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 传入IMU消息</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ScanRegistration::handleIMUMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> sensor_msgs::Imu::ConstPtr&amp; imuIn)</span> <span class="hljs-comment">// imuIn的结构--1</span></span><br><span class="hljs-function"></span>&#123;<br>  tf::Quaternion orientation;<br>  tf::<span class="hljs-built_in">quaternionMsgToTF</span>(imuIn-&gt;orientation, orientation);<br>  <span class="hljs-type">double</span> roll, pitch, yaw;<br>  tf::<span class="hljs-built_in">Matrix3x3</span>(orientation).<span class="hljs-built_in">getRPY</span>(roll, pitch, yaw); <span class="hljs-comment">//将IMU的姿态转roll,pitch,yaw</span><br><br>  Vector3 acc;<br>  acc.<span class="hljs-built_in">x</span>() = <span class="hljs-built_in">float</span>(imuIn-&gt;linear_acceleration.y - <span class="hljs-built_in">sin</span>(roll) * <span class="hljs-built_in">cos</span>(pitch) * <span class="hljs-number">9.81</span>);<br>  acc.<span class="hljs-built_in">y</span>() = <span class="hljs-built_in">float</span>(imuIn-&gt;linear_acceleration.z - <span class="hljs-built_in">cos</span>(roll) * <span class="hljs-built_in">cos</span>(pitch) * <span class="hljs-number">9.81</span>);<br>  acc.<span class="hljs-built_in">z</span>() = <span class="hljs-built_in">float</span>(imuIn-&gt;linear_acceleration.x + <span class="hljs-built_in">sin</span>(pitch)             * <span class="hljs-number">9.81</span>); <span class="hljs-comment">//减去重力得到真实的加速度--2</span><br><br>  IMUState newState; <span class="hljs-comment">// IMUState的结构--3</span><br>  newState.stamp = <span class="hljs-built_in">fromROSTime</span>( imuIn-&gt;header.stamp);<br>  newState.roll = roll;<br>  newState.pitch = pitch;<br>  newState.yaw = yaw;<br>  newState.acceleration = acc;<br><br>  <span class="hljs-built_in">updateIMUData</span>(acc, newState); <span class="hljs-comment">// 将新的IMU状态更新到全局信息中--4</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="imu消息的结构">1 imu消息的结构</h4><p>ROS中<code>sensor_msgs::Imu</code>的定义：包含一个四元数表示姿态，角速度和加速度为三维向量</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-type">Header</span> header<br><br>geometry_msgs/<span class="hljs-type">Quaternion</span> orientation<br><span class="hljs-type">float64</span>[<span class="hljs-number">9</span>] orientation_covariance <span class="hljs-comment"># Row major about x, y, z axes</span><br><br>geometry_msgs/<span class="hljs-type">Vector3</span> angular_velocity<br><span class="hljs-type">float64</span>[<span class="hljs-number">9</span>] angular_velocity_covariance <span class="hljs-comment"># Row major about x, y, z axes</span><br><br>geometry_msgs/<span class="hljs-type">Vector3</span> linear_acceleration<br><span class="hljs-type">float64</span>[<span class="hljs-number">9</span>] linear_acceleration_covariance<br></code></pre></td></tr></table></figure><h4 id="减去重力得到真实的加速度">2 减去重力得到真实的加速度</h4><p>由于IMU测量的是比力，在物体静止时会测量到一个垂直向上，大小为g的加速度，因此测量值需要减去<strong>g</strong>。但由于IMU在车辆运动中跟随车辆旋转，我们需要先将世界坐标系下的<span class="math inline">\(\textbf{g}=[0,0,9.8]\)</span>用orientation转换到当前IMU坐标系下，即：</p><p><span class="math display">\[ a_ {true} &#39;=a &#39;_ {measure}-  R_ {ZYX}  *\textbf{g} = \left [\begin{matrix}a_{x}&#39;\\ a_{y}&#39;\\ a_{z}&#39; \end{matrix} \right ] - \left [\begin{matrix}-sin(p)g \\sin(r)cos(p)g \\ cos(r)cos(p)g \end{matrix} \right ]\]</span></p><h4 id="imustate的结构">3 IMUState的结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">IMUState</span><br>  &#123;<br>    Time stamp;<br>    Angle roll;<br>    Angle pitch;<br>    Angle yaw;<br><br>    Vector3 position; <span class="hljs-comment">// IMU在世界坐标系的位置</span><br><br>    Vector3 velocity; <span class="hljs-comment">// IMU相对于世界坐标系的速度</span><br><br>    Vector3 acceleration; <br><br>    <span class="hljs-comment">// 一个插值函数，输入一个IMU开始状态，一个结束状态，一个插值的位置比例，输出插值得到的IMU状态</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">interpolate</span><span class="hljs-params">(<span class="hljs-type">const</span> IMUState&amp; start,</span></span><br><span class="hljs-params"><span class="hljs-function">      <span class="hljs-type">const</span> IMUState&amp; end,</span></span><br><span class="hljs-params"><span class="hljs-function">      <span class="hljs-type">const</span> <span class="hljs-type">float</span>&amp; ratio,</span></span><br><span class="hljs-params"><span class="hljs-function">      IMUState&amp; result)</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-type">float</span> invRatio = <span class="hljs-number">1</span> - ratio;<br><br>      result.roll = start.roll.<span class="hljs-built_in">rad</span>() * invRatio + end.roll.<span class="hljs-built_in">rad</span>() * ratio;<br>      result.pitch = start.pitch.<span class="hljs-built_in">rad</span>() * invRatio + end.pitch.<span class="hljs-built_in">rad</span>() * ratio;<br>      <span class="hljs-keyword">if</span> (start.yaw.<span class="hljs-built_in">rad</span>() - end.yaw.<span class="hljs-built_in">rad</span>() &gt; M_PI)<br>      &#123;<br>        result.yaw = start.yaw.<span class="hljs-built_in">rad</span>() * invRatio + (end.yaw.<span class="hljs-built_in">rad</span>() + <span class="hljs-number">2</span> * M_PI) * ratio;<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (start.yaw.<span class="hljs-built_in">rad</span>() - end.yaw.<span class="hljs-built_in">rad</span>() &lt; -M_PI)<br>      &#123;<br>        result.yaw = start.yaw.<span class="hljs-built_in">rad</span>() * invRatio + (end.yaw.<span class="hljs-built_in">rad</span>() - <span class="hljs-number">2</span> * M_PI) * ratio;<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        result.yaw = start.yaw.<span class="hljs-built_in">rad</span>() * invRatio + end.yaw.<span class="hljs-built_in">rad</span>() * ratio;<br>      &#125;<br><br>      result.velocity = start.velocity * invRatio + end.velocity * ratio;<br>      result.position = start.position * invRatio + end.position * ratio;<br>    &#125;;<br>  &#125; IMUState;<br></code></pre></td></tr></table></figure><h4 id="将新的imu状态更新到全局信息中">4将新的IMU状态更新到全局信息中</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BasicScanRegistration::updateIMUData</span><span class="hljs-params">(Vector3&amp; acc, IMUState&amp; newState)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (_imuHistory.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 把加速度转到世界坐标系下</span><br>    <span class="hljs-built_in">rotateZXY</span>(acc, newState.roll, newState.pitch, newState.yaw);<br><br>    <span class="hljs-comment">// 对位置和速度进行积分</span><br>    <span class="hljs-type">const</span> IMUState&amp; prevState = _imuHistory.<span class="hljs-built_in">last</span>();<br>    <span class="hljs-type">float</span> timeDiff = <span class="hljs-built_in">toSec</span>(newState.stamp - prevState.stamp);<br>    newState.position = prevState.position<br>                        + (prevState.velocity * timeDiff)<br>                        + (<span class="hljs-number">0.5</span> * acc * timeDiff * timeDiff);<br>    newState.velocity = prevState.velocity<br>                        + acc * timeDiff;<br>  &#125;<br><br>  _imuHistory.<span class="hljs-built_in">push</span>(newState); <span class="hljs-comment">// 推入_imuHistory队列</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里根据当前的加速度，前一个时刻的速度对位置和时间做了积分</p><p><span class="math display">\[p_{new} = p_{pre} + v_{prev} * \Delta t+ \frac{1}{2} a (\Delta t)^2\]</span></p><p><span class="math display">\[v_{new} = v_{pre} + a \Deltat\]</span></p><div class="note note-danger">            <p>问题1：对加速度做2次积分应该不太准吧，代码中有用反馈信息来纠正吗？</p>          </div><h3 id="运动补偿">运动补偿</h3><p>把点云投影到这一帧开始时刻:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BasicScanRegistration::projectPointToStartOfSweep</span><span class="hljs-params">(pcl::PointXYZI&amp; point, <span class="hljs-type">float</span> relTime)</span> <span class="hljs-comment">//relTime: 该点相对于这个scan初始时刻的时间</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">hasIMUData</span>()) <span class="hljs-comment">// hasIMUData: _imuHistory.size() &gt; 0</span><br>  &#123;<br>    <span class="hljs-built_in">setIMUTransformFor</span>(relTime); <span class="hljs-comment">// 计算该点相对于这一sweep初始时刻的位姿--1</span><br>    <span class="hljs-built_in">transformToStartIMU</span>(point); <span class="hljs-comment">// 把该点投影到这一sweep初始时刻--2</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="计算该点相对于这一sweep初始时刻的位姿">1计算该点相对于这一sweep初始时刻的位姿</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BasicScanRegistration::setIMUTransformFor</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">float</span>&amp; relTime)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">interpolateIMUStateFor</span>(relTime, _imuCur); <span class="hljs-comment">// 获得relTime时间的IMU状态</span><br><br>  <span class="hljs-type">float</span> relSweepTime = <span class="hljs-built_in">toSec</span>(_scanTime - _sweepStart) + relTime; <span class="hljs-comment">//在代码中_sweepStart设为_scanTime,所以这里就是relTime</span><br>  _imuPositionShift = _imuCur.position - _imuStart.position - _imuStart.velocity * relSweepTime; <span class="hljs-comment">// ??</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>获得relTime时间的IMU状态</strong></p><p>找到当前时刻之后最近的一帧IMU，用这一帧IMU和前一帧插值得到relTime时间的IMU状态：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BasicScanRegistration::interpolateIMUStateFor</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">float</span> &amp;relTime, IMUState &amp;outputState)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">double</span> timeDiff = <span class="hljs-built_in">toSec</span>(_scanTime - _imuHistory[_imuIdx].stamp) + relTime; <span class="hljs-comment">// 要补偿的点和当前的IMU帧（IMU根据用的需要idx不断往后加）的时间差</span><br>  <span class="hljs-keyword">while</span> (_imuIdx &lt; _imuHistory.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &amp;&amp; timeDiff &gt; <span class="hljs-number">0</span>) &#123;<br>    _imuIdx++;<br>    timeDiff = <span class="hljs-built_in">toSec</span>(_scanTime - _imuHistory[_imuIdx].stamp) + relTime;<br>  &#125; <span class="hljs-comment">// 当这个IMU时间戳超过我们要补偿的点的时间时，停止</span><br><br>  <span class="hljs-keyword">if</span> (_imuIdx == <span class="hljs-number">0</span> || timeDiff &gt; <span class="hljs-number">0</span>) &#123;<br>    outputState = _imuHistory[_imuIdx];<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-type">float</span> ratio = -timeDiff / <span class="hljs-built_in">toSec</span>(_imuHistory[_imuIdx].stamp - _imuHistory[_imuIdx - <span class="hljs-number">1</span>].stamp);<br>    IMUState::<span class="hljs-built_in">interpolate</span>(_imuHistory[_imuIdx], _imuHistory[_imuIdx - <span class="hljs-number">1</span>], ratio, outputState);<br>  &#125; <span class="hljs-comment">// 用这一帧IMU和上一帧IMU插值得到这个时刻的IMU状态</span><br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-danger">            <p>问题2：_imuPositionShift为什么是当前位置-(scan开始位置+开始速度*relTime)。_imuStart看代码scan开始时的imu状态。那_imuPositionShift就是由加速运动导致的点的位置偏移？</p>          </div><h4 id="把该点投影到scan初始时刻">2 把该点投影到scan初始时刻</h4><p>先把点转换到全局坐标系，只加入由加速度得到的偏移？再旋转回初始时刻的imu局部坐标系</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BasicScanRegistration::transformToStartIMU</span><span class="hljs-params">(pcl::PointXYZI&amp; point)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 把点旋转到全局坐标系</span><br>  <span class="hljs-built_in">rotateZXY</span>(point, _imuCur.roll, _imuCur.pitch, _imuCur.yaw);<br><br>  <span class="hljs-comment">// 加入平移？</span><br>  point.x += _imuPositionShift.<span class="hljs-built_in">x</span>();<br>  point.y += _imuPositionShift.<span class="hljs-built_in">y</span>();<br>  point.z += _imuPositionShift.<span class="hljs-built_in">z</span>();<br><br>  <span class="hljs-comment">// rotate point back to local IMU system relative to the start IMU state</span><br>  <span class="hljs-built_in">rotateYXZ</span>(point, -_imuStart.yaw, -_imuStart.pitch, -_imuStart.roll);<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-danger">            <p>问题3：这里两次旋转相对于对姿态做了补偿，但是平移方向是只对加速度产生偏差做补偿？</p>          </div>]]></content>
    
    
    <categories>
      
      <category>SLAM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LEGO-LOAM论文与代码阅读</title>
    <link href="/2023/09/23/LEGOLOAM%E8%AE%BA%E6%96%87%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <url>/2023/09/23/LEGOLOAM%E8%AE%BA%E6%96%87%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>LeGO-LOAM 是对LOAM的一个改进。正如论文题目中Lightweight andGround-optimized,它的特点在于相比LOAM更加轻量，加了地面优化。尽管它在实际应用中出现较少，但其中的一些思想都是值得学习的。本文主要关注它相对于LOAM改进的地方，以及存在的不足之处。</p>          </div><p>LeGO-LOAM主要解决的问题：原始LOAM对计算资源的需求大，在运动剧烈时不够鲁棒，特征不够稳定。</p><h3 id="整体框架">整体框架</h3><p>系统流程图如下：</p><center><img src="1.png" width="50%" height="50%" /></center><p>与LOAM是基本一致的，只是前面加了点云分割的步骤。但每一步实现的细节与LOAM也有差别，接下来我们具体看这些差别。</p><h3 id="对loam的改进">对LOAM的改进</h3><h4id="点云分割提取地面对非地面点云聚类">点云分割（提取地面，对非地面点云聚类）</h4><p>首先把一帧点云投影成深度图，深度图的像素为1800*16。深度图每个位置的值是该点到lidar的距离。</p><p><font color=gray>Velodyne16lidar，垂直方向是16线，水平方向是360/0.2=1800.</font></p><p>论文里只是简单提到使用了一个按列评估的地面提取，来看一下代码里是怎么做的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; _horizontal_scans; ++j) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; _ground_scan_index; ++i) &#123;           <span class="hljs-comment">// 仅遍历方向朝下的scan</span><br>    <span class="hljs-type">size_t</span> lowerInd = j + (i)*_horizontal_scans;<br>    <span class="hljs-type">size_t</span> upperInd = j + (i + <span class="hljs-number">1</span>) * _horizontal_scans; <span class="hljs-comment">//相邻两个laser在同一列的点，也就是深度图的同一列的点</span><br><br>    <span class="hljs-keyword">if</span> (_full_cloud-&gt;points[lowerInd].intensity == <span class="hljs-number">-1</span> ||<br>        _full_cloud-&gt;points[upperInd].intensity == <span class="hljs-number">-1</span>) &#123;<br>      <span class="hljs-comment">// no info to check, invalid points</span><br>      _ground_mat(i, j) = <span class="hljs-number">-1</span>;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    <span class="hljs-type">float</span> dX =<br>        _full_cloud-&gt;points[upperInd].x - _full_cloud-&gt;points[lowerInd].x;<br>    <span class="hljs-type">float</span> dY =<br>        _full_cloud-&gt;points[upperInd].y - _full_cloud-&gt;points[lowerInd].y;<br>    <span class="hljs-type">float</span> dZ =<br>        _full_cloud-&gt;points[upperInd].z - _full_cloud-&gt;points[lowerInd].z;<br><br>    <span class="hljs-type">float</span> vertical_angle = std::<span class="hljs-built_in">atan2</span>(dZ , <span class="hljs-built_in">sqrt</span>(dX * dX + dY * dY + dZ * dZ));<br><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> review this change, 判断前后两点的角度变化在10度内</span><br><br>    <span class="hljs-keyword">if</span> ( (vertical_angle - _sensor_mount_angle) &lt;= <span class="hljs-number">10</span> * DEG_TO_RAD) &#123;<br>      _ground_mat(i, j) = <span class="hljs-number">1</span>;<br>      _ground_mat(i + <span class="hljs-number">1</span>, j) = <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol type="1"><li>假设激光雷达在一定高度水平安装，只有下面几条laser可能扫描到地面点。因此只遍历这几条线。</li><li>取相邻两线在同一水平位置的点（也就是论文所说的按列评估），如下A,B两点</li></ol><center><img src="2.png" width="50%" height="50%" /></center><ol start="3" type="1"><li>如果两个点连线的垂直角度与lidar安装角度之差在10度以内，就认为是地面点。</li></ol><div class="note note-warning">            <p>这种判断方式过于简单，如果是低于激光雷达的其他平面也会被认为是地面。而且假设了雷达水平安装。但如果用RANSAC之类的提地面方法，耗时就太长了？</p>          </div><p>然后对非地面点云做聚类。这里论文也没有详细介绍，大致思想是从深度图上一个点出发，找上下左右四个点，如果点之间距离足够接近就聚为一类。直到所有点都有类别。看一下代码（这里是从一个点出发搜索完一类的过程）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">labelComponents</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span></span>&#123;<br>    <span class="hljs-comment">// use std::queue std::vector std::deque will slow the program down greatly</span><br>    <span class="hljs-type">float</span> d1, d2, alpha, angle;<br>    <span class="hljs-type">int</span> fromIndX, fromIndY, thisIndX, thisIndY; <br>    <span class="hljs-type">bool</span> lineCountFlag[N_SCAN] = &#123;<span class="hljs-literal">false</span>&#125;;<br><br>    queueIndX[<span class="hljs-number">0</span>] = row;<br>    queueIndY[<span class="hljs-number">0</span>] = col;<br>    <span class="hljs-type">int</span> queueSize = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> queueStartInd = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> queueEndInd = <span class="hljs-number">1</span>;<br><br>    allPushedIndX[<span class="hljs-number">0</span>] = row;<br>    allPushedIndY[<span class="hljs-number">0</span>] = col;<br>    <span class="hljs-type">int</span> allPushedIndSize = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span>(queueSize &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// Pop point</span><br>        fromIndX = queueIndX[queueStartInd];<br>        fromIndY = queueIndY[queueStartInd];<br>        --queueSize;<br>        ++queueStartInd;<br>        <span class="hljs-comment">// 标记要pop的点的label</span><br>        labelMat.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">int</span>&gt;(fromIndX, fromIndY) = labelCount;<br>        <span class="hljs-comment">// Loop through all the neighboring grids of popped grid</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = neighborIterator.<span class="hljs-built_in">begin</span>(); iter != neighborIterator.<span class="hljs-built_in">end</span>(); ++iter)&#123;<br>            <span class="hljs-comment">// new index</span><br>            thisIndX = fromIndX + (*iter).first;<br>            thisIndY = fromIndY + (*iter).second;<br>            <span class="hljs-comment">// index should be within the boundary</span><br>            <span class="hljs-keyword">if</span> (thisIndX &lt; <span class="hljs-number">0</span> || thisIndX &gt;= N_SCAN)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// at range image margin (left or right side)</span><br>            <span class="hljs-keyword">if</span> (thisIndY &lt; <span class="hljs-number">0</span>)<br>                thisIndY = Horizon_SCAN - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (thisIndY &gt;= Horizon_SCAN)<br>                thisIndY = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// prevent infinite loop (caused by put already examined point back)</span><br>            <span class="hljs-keyword">if</span> (labelMat.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">int</span>&gt;(thisIndX, thisIndY) != <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">continue</span>;<br><br>            d1 = std::<span class="hljs-built_in">max</span>(rangeMat.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">float</span>&gt;(fromIndX, fromIndY), <br>                            rangeMat.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">float</span>&gt;(thisIndX, thisIndY));<br>            d2 = std::<span class="hljs-built_in">min</span>(rangeMat.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">float</span>&gt;(fromIndX, fromIndY), <br>                            rangeMat.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">float</span>&gt;(thisIndX, thisIndY));<br><br>            <span class="hljs-keyword">if</span> ((*iter).first == <span class="hljs-number">0</span>)<br>                alpha = segmentAlphaX;<br>            <span class="hljs-keyword">else</span><br>                alpha = segmentAlphaY;<br><br>            angle = <span class="hljs-built_in">atan2</span>(d2*<span class="hljs-built_in">sin</span>(alpha), (d1 -d2*<span class="hljs-built_in">cos</span>(alpha)));<br><br>            <span class="hljs-keyword">if</span> (angle &gt; segmentTheta)&#123;<br><br>                queueIndX[queueEndInd] = thisIndX;<br>                queueIndY[queueEndInd] = thisIndY;<br>                ++queueSize;<br>                ++queueEndInd;<br><br>                labelMat.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">int</span>&gt;(thisIndX, thisIndY) = labelCount;<br>                lineCountFlag[thisIndX] = <span class="hljs-literal">true</span>;<br><br>                allPushedIndX[allPushedIndSize] = thisIndX;<br>                allPushedIndY[allPushedIndSize] = thisIndY;<br>                ++allPushedIndSize;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 点数少于30的类被认为无效</span><br>    <span class="hljs-type">bool</span> feasibleSegment = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (allPushedIndSize &gt;= <span class="hljs-number">30</span>)<br>        feasibleSegment = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (allPushedIndSize &gt;= segmentValidPointNum)&#123;<br>        <span class="hljs-type">int</span> lineCount = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N_SCAN; ++i)<br>            <span class="hljs-keyword">if</span> (lineCountFlag[i] == <span class="hljs-literal">true</span>)<br>                ++lineCount;<br>        <span class="hljs-keyword">if</span> (lineCount &gt;= segmentValidLineNum)<br>            feasibleSegment = <span class="hljs-literal">true</span>;            <br>    &#125;<br>    <span class="hljs-comment">// segment is valid, mark these points</span><br>    <span class="hljs-keyword">if</span> (feasibleSegment == <span class="hljs-literal">true</span>)&#123;<br>        ++labelCount;<br>    &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// segment is invalid, mark these points</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; allPushedIndSize; ++i)&#123;<br>            labelMat.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">int</span>&gt;(allPushedIndX[i], allPushedIndY[i]) = <span class="hljs-number">999999</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>聚类时相当于一种广度优先搜索。由于queue,vector结构会导致速度严重变慢，这里用静态数组queueIndX，queueIndY记录，然后用queueStartInd做标记</li><li>点数少于30的类被认为无效。这里是为了去除像树叶等不稳定的点，防止被提取为特征点</li><li>同一类原理：其中tang的角度越大，表明相邻的两个point越接近在一个平面上，故可认为是同一类</li></ul><center><img src="3.png" width="50%" height="50%" /></center><h4 id="特征提取">特征提取</h4><p>在特征提取阶段，LeGO-LOAM计算曲率的方式从LOAM的计算点的欧式距离改为只用深度：</p><p><span class="math display">\[c=\frac{1}{|S|\cdot \|r_i\|} \|\sum _ {j \in s, j\neq i}( r_ {j}-r_ {i}) \| \]</span></p><p>edge点只从非地面点中提取，在设置阈值c后，可以得到边缘点集<spanclass="math inline">\(\mathbb{F}_e\)</span>，这些点中c值最大的n(n=2)个点构成<spanclass="math inline">\(F_e\)</span>。平面点从地面和非地面点中提取，在设置阈值后得到点集<spanclass="math inline">\(\mathbb{F}_p\)</span>，这些点中c值最小的m（m=4）个点构成<spanclass="math inline">\(F_p\)</span></p><h4 id="特征匹配">特征匹配</h4><p>在特征匹配时，我们对这一帧的<spanclass="math inline">\(F^t_e,F^t_p\)</span>，在上一帧<spanclass="math inline">\(\mathbb{F}^{t-1}_e,\mathbb{F}^{t-1}_p\)</span>中找匹配点，而不是在所有点中找。同时平面点只在地面点类别中找，边缘点只在非地面点类别中找。计算残差的方式和LOAM类似，也是点到线的距离和点到面的距离</p><h4 id="帧间位姿估计两步lm优化">帧间位姿估计：两步LM优化</h4><center><img src="4.png" width="50%" height="50%" /></center><p>先用平面特征估计<spanclass="math inline">\([roll,pitch,z]\)</span>，再用边缘特征估计另外三个维度。因为平面主要以地面为主，而地面就约束了这三个维度。这种优化方法由于分解了问题，减少了每次优化时的变量维度，减少了迭代的次数。且在地面提取比较准确时，可以较好地估计前3个维度，提高算法的鲁棒性。</p><p>但也就导致算法非常依赖准确的地面提取，在斜坡，地面不平，lidar安装角度不水平时效果都会变差，且分布优化应该会降低准确率。</p><h4 id="建图">建图</h4><p>建图主要是把当前帧的特征<spanclass="math inline">\(F^t_e,F^t_p\)</span>和局部地图做匹配。此外，LeGO-LOAM使用每一个关键帧特征点云单独存储的方式，加入了回环检测，如果当前特征集与之前的特征集通过ICP得到匹配，就把这个约束加入位姿图优化。</p><h3 id="lego-loam的局限性">LeGo-LOAM的局限性</h3><ol type="1"><li>需要lidar水平安装或已知lidar安装的角度</li><li>需要有平坦的地面</li><li>LeGO-LOAM仅保存特征点，因此点云地图很稀疏。</li></ol>]]></content>
    
    
    <categories>
      
      <category>SLAM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LOAM论文与代码阅读（二）建图</title>
    <link href="/2023/09/23/LOAM%E8%AE%BA%E6%96%87%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB2/"/>
    <url>/2023/09/23/LOAM%E8%AE%BA%E6%96%87%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB2/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>上一篇学习了LOAM的里程计。里程计输入原始点云，得到了去畸变的点云和帧间位姿。但帧间位姿不断递推会导致误差不断积累，因此我们需要将帧（单帧或多帧）与地图进行匹配来优化位姿，同时建立全局地图。本篇就来学习LOAM中后端优化建图的过程。</p>          </div><h3 id="整体流程">整体流程</h3><p>建图的整体流程如下：</p><p>建图的算法对每个sweep运行一次。</p><p>输入：在第k+1个sweep结束时，我们得到了去畸变的点云 <spanclass="math inline">\(\overline{P}_{k+1}\)</span>,和这一帧相对于上一帧的变换 <spanclass="math inline">\(T^L_{k+1}\)</span>。同时我们有一个地图<spanclass="math inline">\(Q_k\)</span>，是由前k帧建立的全局地图点云，和上一帧建图时估计的位姿<spanclass="math inline">\(T_k^W\)</span>，即<spanclass="math inline">\(t_k\)</span>时刻lidar相对于世界坐标系的位姿。（世界坐标系即为<spanclass="math inline">\(Q_k\)</span>建立的坐标系，常使用第一帧的坐标系作为世界坐标系）</p><p>输出：<span class="math inline">\(T_{k+1}^W\)</span></p><p>方法：根据<span class="math inline">\(T_k^W\)</span>和<spanclass="math inline">\(T^L_{k+1}\)</span>，我们可以得到<spanclass="math inline">\(T_{k+1}^W\)</span>的一个估计值。用这个值我们将<spanclass="math inline">\(\overline{P}_{k+1}\)</span>投影到世界坐标系，用<spanclass="math inline">\(\overline{Q}_{k+1}\)</span>表示。把<spanclass="math inline">\(\overline{Q}_{k+1}\)</span>与地图<spanclass="math inline">\(Q_k\)</span>匹配，就可以优化位姿<spanclass="math inline">\(T_{k+1}^W\)</span>了。</p><h3 id="具体细节">具体细节</h3><ol type="1"><li>提取特征点的方式与里程计相同，但是提取更多的特征点（10倍）。</li></ol><div class="note note-success">            <p>由于地图更稠密，而且建图运行频率低，所以可以提取更多特征点？而且建图需要得到一个更准确的位姿估计。</p>          </div><ol start="2" type="1"><li><p>对于地图中大量的点云如果全部存储成kd-tree，树的深度很大，不易存储。地图首先被划分成10m的体素格，再将与当前<spanclass="math inline">\(\overline{Q}_{k+1}\)</span>有重叠区域的体素格中的点存成kd-tree.</p></li><li><p>对于<spanclass="math inline">\(\overline{Q}_{k+1}\)</span>中的一个特征点i，我们先找在<spanclass="math inline">\(Q_k\)</span>中在i附近一定区域内的点，设这些点构成集合S'。如果i是边缘点，我们只保留S'中的边缘点。如果i是平面点，我们只保留S中的平面点。</p></li><li><p>然后我们计算S'的协方差矩阵为M。计算M的特征值和特征向量得到V和E。如果i是边缘点，S'应对应一条边缘线，它的特征值应该有1个显著大于另外两个，对应的特征向量代表了这条边缘线的方向。如果i是平面点，S'应对应一个平面，它的特征值应该有2个显著大于另外1个，对应的两个特征向量代表了这个平面的方向。</p></li><li><p>然后我们取边缘线上的两个点，平面上的三个点，用和里程计里同样的方式计算距离。得到有关外参<spanclass="math inline">\(T^W_{k+1}\)</span>的损失函数。同样用鲁棒拟合（bisquareweight）和LM方法来优化。</p></li><li><p>优化完成后，我们把第k+1帧点云加入地图。为了使得地图上的点均匀分布，对地图做5cm的体素降采样。</p></li></ol><h3 id="loam的不足之处">LOAM的不足之处</h3><ol type="1"><li>LOAM整体流程比较繁琐，计算消耗大。每一帧都存入地图，在后期内存需求很大</li><li>没有后端优化，没有回环检测</li></ol>]]></content>
    
    
    <categories>
      
      <category>SLAM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LOAM论文与代码阅读（一）激光里程计</title>
    <link href="/2023/09/19/LOAM%E8%AE%BA%E6%96%87%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB1/"/>
    <url>/2023/09/19/LOAM%E8%AE%BA%E6%96%87%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB1/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>LOAM 是LiDAR SLAM早期的奠基之作，后续的LeGO-LOAM,lio-sam，ALOAM等方法都以这种高频里程计，低频建图为基础框架。我在最初接触SLAM时学习过这一系列算法，但理解的不深，后来因为没有做lidarSLAM相关，很久不接触已经生疏了。近期考虑到面试需求和未来的职业方向，计划重新学一遍，同时把重点记录下来，以便后续回顾。</p>          </div><p>LOAM的基本流程如下：</p><img src="/2023/09/19/LOAM%E8%AE%BA%E6%96%87%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB1/1.png" class="" title="fig:1"><p>每一帧lidar通过特征提取，运动补偿，特征匹配得到帧与帧之间的位姿（高频）。将几帧拼在一起与地图进行匹配，优化这几帧相对于地图的位姿（低频）。</p><h3 id="硬件">硬件</h3><p>这里发现之前忽略的一个点。LOAM中使用的激光雷达与现在的多线机械式激光雷达（如velodyne-32）不同。作者是用一个单线激光雷达加上垂直旋转的电机实现3维的扫描。</p><center><img src="2.png" width="60%" height="60%" /></center><p>论文中的介绍如上图所示，我的理解是：</p><p>单线激光雷达自身水平旋转，水平视场角为180度，分辨率为0.25度。每次旋转180得到的数据称为一个scan，需要25ms。同时电机使得激光雷达整体在垂直方向上旋转，从-90到90，水平为0（因此垂直视场角是180）。这样垂直转180度需要1s，1s内得到的数据是一个sweep。这一秒内会扫描40个scan。相当于在垂直方向上是40线,角分辨率是4.5度。</p><p>这也解释了这里scan的指代和其他论文不对应的问题。当前较多使用的多线激光雷达，可近似认为垂直方向的多条laser是同时发射的（实际上不同时，但相隔时间非常接近），因此把多线在水平方向一个周期内的扫描称为一个scan，用于特征提取。</p><h3 id="特征提取">特征提取</h3><p>如上所述，由于垂直角分辨率是4.5度，角度较大，因此提取特征是对每个scan进行单独操作。希望提取的特征点是边缘（edge）和平面（planarsurface）上的点。</p><p><font color=gray>边缘和平面特征显著，容易提取，反应了环境的结构，在帧与帧之间保持不变，更有利于匹配。</font></p><p>为了提取边缘点和平面点，我们首先要计算每个点的曲率。一个scan是单线激光按顺时针或逆时针扫描得到的点，如下图所示，为计算点i的曲率，我们取它前后N个点，组成集合S。</p><img src="/2023/09/19/LOAM%E8%AE%BA%E6%96%87%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB1/3.png" class="" title="fig:3"><p>则曲率c为：</p><p><span class="math display">\[c=  \frac{1}{|S| \cdot \|X_{(k,i)|}  \|}\|\sum_{j \in S,j \neq i} ( X_ {(k,i)}^ {L}  -  X_{(k,j)}^ {L} ) \|\]</span></p><p><spanclass="math inline">\(X_{(k,i)}^L\)</span>是第k个sweep中第i个点在LiDAR坐标系下的坐标。对集合中的每个点计算其与相邻点的距离，用来近似这个点所在位置的曲率。可以想象在平面处相邻点的距离比较接近，曲率会较小，而边缘处点的距离会较远，曲率较大。</p><p>对应ALOAM中的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 取每个点前后5个点，算x,y,z方向的差</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">5</span>; i &lt; cloudSize - <span class="hljs-number">5</span>; i++)<br>&#123; <br>    <span class="hljs-type">float</span> diffX = laserCloud-&gt;points[i - <span class="hljs-number">5</span>].x + laserCloud-&gt;points[i - <span class="hljs-number">4</span>].x + laserCloud-&gt;points[i - <span class="hljs-number">3</span>].x + laserCloud-&gt;points[i - <span class="hljs-number">2</span>].x + laserCloud-&gt;points[i - <span class="hljs-number">1</span>].x - <span class="hljs-number">10</span> * laserCloud-&gt;points[i].x + laserCloud-&gt;points[i + <span class="hljs-number">1</span>].x + laserCloud-&gt;points[i + <span class="hljs-number">2</span>].x + laserCloud-&gt;points[i + <span class="hljs-number">3</span>].x + laserCloud-&gt;points[i + <span class="hljs-number">4</span>].x + laserCloud-&gt;points[i + <span class="hljs-number">5</span>].x;<br>    <span class="hljs-type">float</span> diffY = laserCloud-&gt;points[i - <span class="hljs-number">5</span>].y + laserCloud-&gt;points[i - <span class="hljs-number">4</span>].y + laserCloud-&gt;points[i - <span class="hljs-number">3</span>].y + laserCloud-&gt;points[i - <span class="hljs-number">2</span>].y + laserCloud-&gt;points[i - <span class="hljs-number">1</span>].y - <span class="hljs-number">10</span> * laserCloud-&gt;points[i].y + laserCloud-&gt;points[i + <span class="hljs-number">1</span>].y + laserCloud-&gt;points[i + <span class="hljs-number">2</span>].y + laserCloud-&gt;points[i + <span class="hljs-number">3</span>].y + laserCloud-&gt;points[i + <span class="hljs-number">4</span>].y + laserCloud-&gt;points[i + <span class="hljs-number">5</span>].y;<br>    <span class="hljs-type">float</span> diffZ = laserCloud-&gt;points[i - <span class="hljs-number">5</span>].z + laserCloud-&gt;points[i - <span class="hljs-number">4</span>].z + laserCloud-&gt;points[i - <span class="hljs-number">3</span>].z + laserCloud-&gt;points[i - <span class="hljs-number">2</span>].z + laserCloud-&gt;points[i - <span class="hljs-number">1</span>].z - <span class="hljs-number">10</span> * laserCloud-&gt;points[i].z + laserCloud-&gt;points[i + <span class="hljs-number">1</span>].z + laserCloud-&gt;points[i + <span class="hljs-number">2</span>].z + laserCloud-&gt;points[i + <span class="hljs-number">3</span>].z + laserCloud-&gt;points[i + <span class="hljs-number">4</span>].z + laserCloud-&gt;points[i + <span class="hljs-number">5</span>].z;<br><br>    cloudCurvature[i] = diffX * diffX + diffY * diffY + diffZ * diffZ;<br>    cloudSortInd[i] = i;<br>    cloudNeighborPicked[i] = <span class="hljs-number">0</span>;<br>    cloudLabel[i] = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对一个scan的曲率按照c值排序，其中最大的n个点选择为edge点，最小的m个点为平面点。为了使得特征点分布更均匀，论文把一个scan平分为4个子区域，每个子区域最多选2个边缘点，4个平面点，边缘和平面有设定一个阈值（只有超过阈值才可能选为边缘点）。</p><p>此外，还要去掉一些不可信赖的点： (1)附近已经有点选中了（避免特征点太集中） (2)局部平面和laser光束平行，如下图（a） (3)在被遮挡的区域边缘的点，如下图（b）</p><img src="/2023/09/19/LOAM%E8%AE%BA%E6%96%87%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB1/4.png" class="" title="fig:4"><p>这些点的删除方式是：当根据曲率得到特征点后，重新去看这些点用于计算曲率的点集S，需要保证S中的点没有被选中为特征点，点集构成的平面不与激光线平行，且点集中相邻点没有在激光方向上的出现距离的不连续。</p><h3 id="特征匹配">特征匹配</h3><h4 id="符号">符号</h4><p>第k个sweep的原始点云表示为<spanclass="math inline">\(P_k\)</span>，<spanclass="math inline">\(P_k\)</span>开始的时间为<spanclass="math inline">\(t_k\)</span>。经过运动补偿（统一到这一帧结束时刻）的点云为<spanclass="math inline">\(\overline{P}_k\)</span>。</p><h4 id="整体流程">整体流程</h4><p>为了对流程有整体的认知，明白每一步的原因，我们先看大致的lidarodometry的流程，细节留到后面分析：</p><center><img src="5.png" width="70%" height="70%" /></center><ul><li><p>输入：前一帧去畸变的点云<spanclass="math inline">\(\overline{P}_k\)</span>，当前帧不断增加的点云<spanclass="math inline">\(P_k\)</span>（由于程序是实时运行的），</p></li><li><p>输出：<spanclass="math inline">\(T^L_{k+1}\)</span>,是lidar在<spanclass="math inline">\((t_{k+1}\)</span>，<spanclass="math inline">\(t_{k+2})\)</span>之间的变换，即点云 <spanclass="math inline">\(\overline{P}_{k+1}\)</span> 相对于 <spanclass="math inline">\(\overline{P}_{k}\)</span> 变换</p></li></ul><p><spanclass="math inline">\(T^L_{k+1}\)</span>是通过不断迭代获得的。在k+1帧起始时刻<spanclass="math inline">\(t_{k+1}\)</span>，<spanclass="math inline">\(T^L_{k+1}\)</span>为单位矩阵。我们现在假设上一次迭代得到的位姿为<spanclass="math inline">\(T^{L}_{k+1}\)</span>，来推导一次迭代过程：</p><ol type="1"><li>特征提取：首先从<spanclass="math inline">\(P_{k+1}\)</span>中提取edge和plane特征点，用<spanclass="math inline">\(\varepsilon_{k+1},H_{k+1}\)</span>表示。</li><li>运动补偿：为了和上一帧做匹配，我们可以用<spanclass="math inline">\(T^L_{k+1}\)</span>和匀速运动模型将<spanclass="math inline">\(\varepsilon_{k+1},H_{k+1}\)</span>投影到这一帧开始时刻，表示为<spanclass="math inline">\(\widetilde{\varepsilon}_{k+1},\widetilde{H}_{k+1}\)</span><font color=red>（细节1）</font>。</li><li>特征匹配：将<spanclass="math inline">\(\widetilde{\varepsilon}_{k+1},\widetilde{H}_{k+1}\)</span>与上一帧<spanclass="math inline">\(\overline{P}_k\)</span>匹配。对边缘点，我们找到上一帧对应的线，计算点到线的距离。对平面点，我们找到上一帧对应的平面，计算点到平面的距离。<font color=red>（细节2）</font>。</li><li>位姿优化：这些距离是<spanclass="math inline">\(T^L_{k+1}\)</span>的一个非线性函数，每个距离根据特征点会分配一个权重。构成了对T一个非线性优化问题，应用LM优化求解。将上一次的<spanclass="math inline">\(T^L_{k+1}\)</span>作为初值，当迭代一定次数或者函数收敛后，返回新的<spanclass="math inline">\(T^L_{k+1}\)</span>。<font color=red>（细节3）</font>。</li></ol><p>这个迭代在sweep内不停地进行，直到sweep结束，并把<spanclass="math inline">\(P_{k+1}\)</span>所有点用<spanclass="math inline">\(T^L_{k+1}\)</span>投影到这一帧结束（运动补偿），得到<spanclass="math inline">\(\overline{P}_{k+1}\)</span>作为下一帧的输入。</p><p>接下来我们看这里面每一步的细节：</p><h4 id="细节1运动补偿">细节1：运动补偿</h4><p>由于机械式lidar所有点获得的时间戳不同，在lidar运动时，每个点的lidar坐标系实际位置不同。我们要对一个sweep的lidar做运动补偿，把所有(x,y,z)的坐标系统一到一个时刻，作为一帧点云。原始的LOAM没有用IMU，而是假设在一个sweep内角速度和线速度是恒定的。整个过程中涉及运动补偿的流程有两个，一是为了与上一帧进行特征匹配，把所有点投影到这一帧开始时刻，二是在迭代结束之后，把所有点投影到这一帧结束时刻作为下一帧输入。</p><p><strong>把<spanclass="math inline">\(P_{k+1}\)</span>的点投影到开始时刻：</strong>为了把各个时刻的点投影到这一帧开始，我们需要知道每个点相对于这一帧初始时刻的位姿，这个位姿可以通过对<spanclass="math inline">\(T^L_{k+1}\)</span>插值得到。<spanclass="math inline">\(T^L_{k+1}\)</span>是当前时刻t下，我们估计的<spanclass="math inline">\((t_{k+1}, t)\)</span>变化的位姿。</p><p>对于i时刻的点，我们求得的位姿变换如下：</p><p><spanclass="math display">\[  T_{(k+1,i)}^{L}  =  \frac{t_{i}-t_{k+1}}{t-t_{k+1}}  T_{k+1}^{L} \]</span></p><p>从<spanclass="math inline">\(T_{(k+1,i)}^{L}\)</span>中拆解出R,t，可以得到补偿后的特征点坐标<spanclass="math inline">\(\widetilde {X}_ {(k+1,i)}^L\)</span></p><p><span class="math display">\[ X_{(k+1,i)}^L=R  \widetilde {X}_ {(k+1,i)}^L  +  t \]</span></p><p><strong>把<spanclass="math inline">\(P_{k+1}\)</span>的点投影到结束时刻：</strong></p><p>在这一帧结束后，我们得到了<spanclass="math inline">\((t_{k+1}\)</span>，<spanclass="math inline">\(t_{k+2})\)</span>之间的位姿变换<spanclass="math inline">\(T_{k+1}^{L}\)</span>。我们先把所有点按照上述方法投影到这一帧的开始时刻，然后用<spanclass="math inline">\(T_{k+1}^{L}\)</span>反变换，将所有点投影到这一帧结束时刻。</p><p><strong>对应ALOAM的代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//（TransformToStart：将当前帧Lidar坐标系下的点云变换到这一帧开始</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TransformToStart</span><span class="hljs-params">(PointType <span class="hljs-type">const</span> *<span class="hljs-type">const</span> pi, PointType *<span class="hljs-type">const</span> po)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//interpolation ratio</span><br>    <span class="hljs-type">double</span> s;            <span class="hljs-comment">//插值比，根据时间，在这一帧里占的比率</span><br>    <span class="hljs-keyword">if</span> (DISTORTION)      <span class="hljs-comment">//是否需要去畸变</span><br>    <span class="hljs-comment">// intensity 实数部分存的是scan上点的id，小数部分存的这一点相对这一帧起始点的时间差</span><br>    <span class="hljs-comment">// intensity的整体减去整数部分,就是时间差,除以周期,就是时间占比了</span><br>        s = (pi-&gt;intensity - <span class="hljs-built_in">int</span>(pi-&gt;intensity)) / SCAN_PERIOD;<br>    <span class="hljs-keyword">else</span><br>        s = <span class="hljs-number">1.0</span>;<br><br>    <span class="hljs-comment">// 所有点的操作方式都是一致的，相当于从结束时刻补偿到起始时刻，相当于是一个匀速模型的假设</span><br><br>    Eigen::Quaterniond q_point_last = Eigen::Quaterniond::<span class="hljs-built_in">Identity</span>().<span class="hljs-built_in">slerp</span>(s, q_last_curr); <span class="hljs-comment">//slerp函数(球面线性插值)</span><br>    Eigen::Vector3d t_point_last = s * t_last_curr;<br>    <span class="hljs-function">Eigen::Vector3d <span class="hljs-title">point</span><span class="hljs-params">(pi-&gt;x, pi-&gt;y, pi-&gt;z)</span></span>;         <span class="hljs-comment">//把当前点的坐标取出</span><br>    Eigen::Vector3d un_point = q_point_last * point + t_point_last; <span class="hljs-comment">//通过旋转和平移将 当前点转到帧起始时刻坐标系下的坐标</span><br><br>    <span class="hljs-comment">//将求得的转换后的坐标赋值给输出点</span><br>    po-&gt;x = un_point.<span class="hljs-built_in">x</span>();<br>    po-&gt;y = un_point.<span class="hljs-built_in">y</span>();<br>    po-&gt;z = un_point.<span class="hljs-built_in">z</span>();<br>    po-&gt;intensity = pi-&gt;intensity;<br>&#125;<br><br><br><span class="hljs-comment">// 首先把点统一到起始时刻坐标系下,再通过反变换,得到结束时刻坐标系下的点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TransformToEnd</span><span class="hljs-params">(PointType <span class="hljs-type">const</span> *<span class="hljs-type">const</span> pi, PointType *<span class="hljs-type">const</span> po)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// undistort point first</span><br>    pcl::PointXYZI un_point_tmp;<br>    <span class="hljs-built_in">TransformToStart</span>(pi, &amp;un_point_tmp);        <span class="hljs-comment">//转到帧起始时刻坐标系下的点</span><br><br>    <span class="hljs-function">Eigen::Vector3d <span class="hljs-title">un_point</span><span class="hljs-params">(un_point_tmp.x, un_point_tmp.y, un_point_tmp.z)</span></span>;       <span class="hljs-comment">//取出起始时刻坐标系下的点的x,y,z</span><br>    Eigen::Vector3d point_end = q_last_curr.<span class="hljs-built_in">inverse</span>() * (un_point - t_last_curr);   <span class="hljs-comment">//通过反变换,求得转到 结束时刻坐标系下 的点坐标</span><br><br>    <span class="hljs-comment">//将求得的转换后的坐标赋值给输出点</span><br>    po-&gt;x = point_end.<span class="hljs-built_in">x</span>();<br>    po-&gt;y = point_end.<span class="hljs-built_in">y</span>();<br>    po-&gt;z = point_end.<span class="hljs-built_in">z</span>();<br><br>    <span class="hljs-comment">//Remove distortion time info  去完畸变可以删除每个点的时间信息</span><br>    po-&gt;intensity = <span class="hljs-built_in">int</span>(pi-&gt;intensity);<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="细节2特征匹配">细节2：特征匹配</h4><p>用<span class="math inline">\(\widetilde{\varepsilon}_{k+1},\widetilde{H}_{k+1}\)</span>表示投影到开始时刻的特征点。特征匹配的方式如下：</p><center><img src="6.png" width="50%" height="50%" /></center><p><strong>边缘点（图a)：</strong></p><p>对于<spanclass="math inline">\(\widetilde{\varepsilon}_{k+1}\)</span>中的点i，我们要找到它在k帧中对应的边缘线，为了确定这条线，我们需要找到两个点。一个点j为离i距离最近的点。一个点l是在点j所在scan（橙线）的相邻两个scan（蓝线）中找到离i最近的点。为了确认j,l是边缘点，会确认它们的曲率c（根据特征提取时的公式）。</p><div class="note note-info">            <p>原因：因为一条边缘线不可能包含一个scan内的多个点。如果这条边缘线由一个scan内的两个点组成，那么这个边缘线与scan所在平面平行，此时这条边缘线在这个scan中的点是一条直线，不会计算出高的曲率，因此不可能被提取为特征点。</p>          </div><p>得到j,l后，我们计算点到直线的距离来衡量匹配的程度：</p><p><span class="math display">\[ d_\varepsilon=  \frac{|(\widetilde{X}^L_{(k+1,i)}-\overline{X}^L_{(k,j)})\times(\widetilde{X}^L_{(k+1,i)}-\overline{X}^L_{(k,l)})|}{|\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,l)}|}\]</span></p><p><strong>平面点（图b):</strong></p><p>对于<span class="math inline">\(\overline{H}_{k+1}\)</span>中的点<spanclass="math inline">\(i\)</span>，我们要找到它在k帧中对应的平面，为了确定这个平面，我们需要找到三个点。同样，一个点j为离i距离最近的点。然后我们找到另外两个距离i最近的点<spanclass="math inline">\(l,m\)</span>。其中<spanclass="math inline">\(l\)</span>需要与点<spanclass="math inline">\(j\)</span>在同一个scan（橙线），点<spanclass="math inline">\(m\)</span>在相邻两个scan（蓝线）。为了确认j,l是平面点，会确认它们的曲率c</p><div class="note note-info">            <p>原因：为了防止三点共线？</p>          </div><p>得到j,l,m后，我们计算点到平面的距离来衡量匹配的程度：</p><p><span class="math display">\[ d_H =  \frac{\left| \begin{matrix}(\widetilde{X}^L_{(k+1,i)}-\overline{X}^L_{(k,j)}) \\((\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,l)})\times(\overline{X}^L_{(k,l)}-\overline {X}^L_{(k,m)})) \end{matrix} \right|}{|(\overline{X}^L_{(k,j)}-\overline{X}^L_{(k,l)})\times(\overline{X}^L_{(k,l)}-\overline {X}^L_{(k,m)})|} \]</span></p><p><font color=gray>为了更快找最近邻，<spanclass="math inline">\(\overline{P}_k\)</span>是以3Dkd-tree存储的</font></p><h4 id="位姿优化">位姿优化</h4><p>对于边缘点，我们可以得到损失函数：</p><p><span class="math display">\[ f _\varepsilon  (  X_ {(k+1,i)}^{L}  ,  T_ {k+1}^ {L} )=d_\varepsilon ,i \in \varepsilon_ {k+1}\]</span></p><p>对于平面点，我们可以得到损失函数：</p><p><span class="math display">\[ f_H  (  X_{(k+1,i)}^ {L}  ,  T_ {k+1}^{L} )=d_H ,i \in H_ {k+1} \]</span></p><p>把这些损失放在一起，可以得到：</p><p><span class="math display">\[ \textbf{f}(T_{k+1}^L) = \textbf{d}\]</span></p><p>其中 <span class="math inline">\(\textbf{d}\)</span>的每一行都是一个特征点的损失。我们可以计算f相对于T的雅可比矩阵J，然后用LM算法来优化。在优化时每行损失分配了不同的权重，匹配距离大的点权重更小，匹配距离大于一定值的点权重为0（被认为是误匹配）。也就是Bisquareweights,根据每一项损失当前的大小分配权重，优先去降低小的损失项，减轻大的损失项的影响。这种方式更加鲁棒。</p><p>这部分在代码中是用ceres来实现的，每一个残差项通过AddResidualBlock加入损失函数，调用优化器求解。</p>]]></content>
    
    
    <categories>
      
      <category>SLAM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pyside6使用问题记录（一）</title>
    <link href="/2023/09/19/pyside6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%951/"/>
    <url>/2023/09/19/pyside6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%951/</url>
    
    <content type="html"><![CDATA[<p>近期在做的任务要把交通路网结构用PySide6可视化，并添加一些选择车道，拖拽车辆之类的交互操作。以下是在应用过程中出现的一些问题和解决方案。</p><h3id="问题1qgraphicsview画polyline">问题1：qgraphicsview画polyline</h3><p>由于希望界面上的部件都可以交互（点击，拖拽），因此我尝试在<code>QGrahicsView</code>类里画，但发现<code>QGraphicsScene</code>没有可直接调用的画polyline的函数，可行的方法是先画出QPainterPath，再用QGraphicsPath。如下面的程序，drawPolyline函数可输入2Dpoints, color, width，画出这些点的折线段。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainWidget</span>(QtWidgets.QGraphicsView)<br>&#123;<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.initUI()<br>        self.scaleFactor = <span class="hljs-number">1</span><br>        self.resize(<span class="hljs-number">800</span>, <span class="hljs-number">800</span>) <br><br>        self.scene_map = QtWidgets.QGraphicsScene()<br>        self.scene_map.setSceneRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">700</span>, <span class="hljs-number">700</span>)<br>        self.scene_map.setBackgroundBrush(Qt.white)<br>        self.setScene(self.scene_map)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">drawPolyline</span>(<span class="hljs-params">self, points:<span class="hljs-built_in">list</span>[<span class="hljs-built_in">tuple</span>], color:QtGui.QColor, width:<span class="hljs-built_in">int</span> = <span class="hljs-number">1.0</span></span>):<br>        points = [QPointF(x,y) <span class="hljs-keyword">for</span> x,y <span class="hljs-keyword">in</span> points]<br>        path = QtGui.QPainterPath()<br>        polygon = QtGui.QPolygonF(points)<br>        path.addPolygon(polygon)<br>        <br>        pen = QtGui.QPen(color)<br>        pen.setWidth(width)<br>        new_item = QtWidgets.QGraphicsPathItem(path, <span class="hljs-literal">None</span>)<br>        new_item.setPath(path)<br>        new_item.setPen(pen)<br>        self.scene_map.addItem(new_item)<br><br>&#125;<br></code></pre></td></tr></table></figure><h3id="问题2画出来的polyline不够平滑有锯齿">问题2：画出来的polyline不够平滑，有锯齿</h3><p>用上述方式画出的图如下图左图所示：斜线会有锯齿，只有完全水平或竖直或45度的线才是粗细均匀的。</p><img src="/2023/09/19/pyside6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%951/1.png" class="" title="fig:1"><p>为了平滑线段，可以给<code>QGraphicsview</code>设置渲染的参数<code>setRenderHint</code>为antialiasing（抗锯齿）。在<code>__init__</code>函数里加入下面一行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.setRenderHint(QtGui.QPainter.Antialiasing, <span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>得到的结果如上面右图所示，可以看到没有锯齿了。</p><h3id="问题3拖拽时view无法超过scene的大小">问题3：拖拽时view无法超过scene的大小</h3><p>设置滚轮放大缩小功能需要重写wheelEvent函数，如下： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">wheelEvent</span>(<span class="hljs-params">self, event: QtGui.QWheelEvent</span>) -&amp;gt; <span class="hljs-literal">None</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.scene().items()) == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span><br><br>    curPoint = event.position()<br>    scenePos = self.mapToScene(QPoint(curPoint.x(), curPoint.y()))<br><br>    viewWidth = self.viewport().width()<br>    viewHeight = self.viewport().height()<br><br>    hScale = curPoint.x() / viewWidth<br>    vScale = curPoint.y() / viewHeight<br><br>    wheelDeltaValue = event.angleDelta().y()<br>    self.scaleFactor = self.transform().m11()<br>    <span class="hljs-keyword">if</span> (self.scaleFactor &amp;lt; <span class="hljs-number">0.05</span> <span class="hljs-keyword">and</span> wheelDeltaValue&amp;lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">or</span> (self.scaleFactor&amp;gt;<span class="hljs-number">50</span> <span class="hljs-keyword">and</span> wheelDeltaValue&amp;gt;<span class="hljs-number">0</span>):<br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">if</span> wheelDeltaValue &amp;gt; <span class="hljs-number">0</span>:<br>        self.scale(<span class="hljs-number">1.1</span>, <span class="hljs-number">1.1</span>)<br>    <span class="hljs-keyword">else</span>:<br>        self.scale(<span class="hljs-number">1.0</span>/<span class="hljs-number">1.1</span>, <span class="hljs-number">1.0</span>/<span class="hljs-number">1.1</span>)<br>    <br>    viewPoint = self.transform().<span class="hljs-built_in">map</span>(scenePos)<br>    self.horizontalScrollBar().setValue(<span class="hljs-built_in">int</span>(viewPoint.x() - viewWidth * hScale ))<br>    self.verticalScrollBar().setValue(<span class="hljs-built_in">int</span>(viewPoint.y() - viewHeight * vScale ))<br><br>    self.update()<br></code></pre></td></tr></table></figure></p><p>设置鼠标拖拽功能只需要给QGraphicsView设置setDragMode，在window类初始化时加入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)<br></code></pre></td></tr></table></figure><p>但在显示底图时由于图比较大，我并不想一开始显示全部，而只是显示一部分，如下图（1）。此时我的拖拽功能只在相比原始scene放大时才有用（在图（2）时可以拖拽）。当地图缩小后尽管还未显示地图全貌，但无法拖动（图（3）无法拖动）。</p><img src="/2023/09/19/pyside6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%951/2.png" class="" title="fig:2"><p>参考这个回答：https://stackoverflow.com/questions/55007339/allow-qgraphicsview-to-move-outside-scene</p><p>一个简单粗暴的解决方法是给scene设置足够大的初始大小。在我的例子中我将大小改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.scene_map.setSceneRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">2000</span>)<br></code></pre></td></tr></table></figure><p>这样就可以在上图（3）仍然可以拖动。不过修改scene_map的大小后要注意原本点的位置的按照scene_map的大小改变。由于<code>QGraphicsScene</code>默认是中心和<code>QGraphicsView</code>对齐的，如scene_map大小设为(2000,2000)，那么此时scene中心点的坐标(1000,1000)会显示在view的中心。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++多线程学习笔记-3</title>
    <link href="/2023/09/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3/"/>
    <url>/2023/09/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3/</url>
    
    <content type="html"><![CDATA[<h3 id="获取线程返回值">获取线程返回值</h3><p>我们希望执行线程后获得线程执行结果的返回值。</p><p>解决方法：</p><ol type="1"><li>直接在线程函数参数中加入作为返回值的引用或指针参数</li><li>使用std::future和std::promise</li></ol><p>std::future，它表示存储着一个未来会被初始化的变量。这个变量可以通过std::future提供的成员函数std::future::get()来得到。如果在这个变量被赋值之前就有别的线程试图通过std::future::get()获取这个变量，那么这个线程将会被阻塞到这个变量可以获取为止。</p><p>std::promise同样也是一个类模板，这个对象承诺在未来一定会初始化一个变量(这个变量也就是std::future中的变量)。</p><p>每一个std::promise对象都有一个与之关联的std::future对象。当std::promise设置值的时候，这个值就会赋给std::future中的对象了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br> <br><span class="hljs-comment">// 函数计算vector的和，并需要返回sum</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">accumulate</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator first,</span></span><br><span class="hljs-params"><span class="hljs-function">                std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator last,</span></span><br><span class="hljs-params"><span class="hljs-function">                std::promise&lt;<span class="hljs-type">int</span>&gt; accumulate_promise)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> sum = std::<span class="hljs-built_in">accumulate</span>(first, last, <span class="hljs-number">0</span>);<br>    accumulate_promise.<span class="hljs-built_in">set_value</span>(sum);  <span class="hljs-comment">// Notify future</span><br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 用promise&lt;int&gt;来在线程之间传递数据</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; numbers = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> &#125;;<br>    std::promise&lt;<span class="hljs-type">int</span>&gt; accumulate_promise;<br>    std::future&lt;<span class="hljs-type">int</span>&gt; accumulate_future = accumulate_promise.<span class="hljs-built_in">get_future</span>();<br>    <span class="hljs-function">std::thread <span class="hljs-title">work_thread</span><span class="hljs-params">(accumulate, numbers.begin(), numbers.end(),</span></span><br><span class="hljs-params"><span class="hljs-function">                            std::move(accumulate_promise))</span></span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;result=&quot;</span> &lt;&lt; accumulate_future.<span class="hljs-built_in">get</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-comment">// get()函数会一直阻塞直到accumulate_promise被赋予了有效值</span><br>    work_thread.<span class="hljs-built_in">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>用这种方式相比指针或引用的好处在于不需要等待此线程运行完了才返回值，一旦有了需要的值，另一个线程就可以得到信号并获取值。这种功能本来需要设置信号条件变量来实现。</p><h3 id="cout输出乱码">cout输出乱码</h3><p>当多个线程都有cout输出时，控制台上输出内容可能会交错混乱，这是因为cout不是线程安全的.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">cout &lt;&lt; <span class="hljs-string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>它把传入的数据依次存入缓冲区。这中间是有可能有其他线程插入的。</p><p>解决方法：</p><ol type="1"><li>使用printf代替cout <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%d\n&quot;</span>,a);<br></code></pre></td></tr></table></figure></li><li>加锁</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h3 id="多个线程存入vector">多个线程存入vector</h3><p>希望程序根据输入决定调用线程的数量，此时用一个vector存储线程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::vector&lt;std::thread&gt; threads;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_thread; i++)<br>    &#123;<br>        threads.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">thread</span>(&amp;Calibrator::RandomSearch, <span class="hljs-keyword">this</span>, <span class="hljs-built_in">int</span>(search_count / num_thread), xyz_range, rpy_range, i));<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_thread; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(threads[i].<span class="hljs-built_in">joinable</span>())&#123;<br>            threads[i].<span class="hljs-built_in">join</span>();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>此时不能先声明thread，再把它push_back，否则就会报错 <figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">error: </span>use of deleted function &#x27;std::thread::thread(const std::thread&amp;)&#x27;<br></code></pre></td></tr></table></figure></p><p>这是因为vector::push_back会先拷贝再推入，而thread是禁止拷贝构造的。可以如上面的直接构造一个临时变量，推入vector.或者用std::move把左值引用转为右值引用。</p><div class="note note-success">            <p>左值是表达式结束后依然存在的持久对象(代表一个在内存中占有确定位置的对象)，能够取到地址</p><p>右值是表达式结束时不再存在的临时对象(不在内存中占有确定位置的表达式）</p>          </div><h3 id="多线程随机数生成重复">多线程随机数生成重复</h3><p>如果只在主线程里用srand，那么其他子线程随机数一定是相同的。生成随机数的每个线程都需要重新设置时间种子。</p><p>但如果用时间做随机种子 <figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">srand</span>((<span class="hljs-variable">unsigned</span> <span class="hljs-variable">int</span>)<span class="hljs-title"><span class="hljs-built_in">time</span></span>(<span class="hljs-variable"><span class="hljs-literal">NULL</span></span>));</span><br></code></pre></td></tr></table></figure>由于时间以秒为单位，如果多个线程调用时间接近，还是可能随机种子相同导致随机数重复。</p><p>解决方法：</p><p>把线程编号传入，使用（时间+编号）生成随机种子。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PCL对大规模点云进行体素降采样</title>
    <link href="/2023/09/14/pcl%E5%A4%A7%E8%A7%84%E6%A8%A1%E7%82%B9%E4%BA%91%E9%99%8D%E9%87%87%E6%A0%B7/"/>
    <url>/2023/09/14/pcl%E5%A4%A7%E8%A7%84%E6%A8%A1%E7%82%B9%E4%BA%91%E9%99%8D%E9%87%87%E6%A0%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="普通体素降采样"><a href="#普通体素降采样" class="headerlink" title="普通体素降采样"></a>普通体素降采样</h3><p>直接调用voxel_grid库，参考<a href="https://pcl.readthedocs.io/projects/tutorials/en/latest/voxel_grid.html">官方教程</a>，只需要设置体素的大小<code>setLeafSize(x, y, z)</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pcl/io/pcd_io.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pcl/point_types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pcl/filters/voxel_grid.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    pcl::<span class="hljs-function">PCLPointCloud2::Ptr <span class="hljs-title">cloud</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> pcl::PCLPointCloud2 ())</span></span>;<br>    pcl::<span class="hljs-function">PCLPointCloud2::Ptr <span class="hljs-title">cloud_filtered</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> pcl::PCLPointCloud2 ())</span></span>;<br><br>    <span class="hljs-comment">// 读入点云</span><br>    pcl::PCDReader reader;<br>    reader.<span class="hljs-built_in">read</span> (<span class="hljs-string">&quot;table_scene_lms400.pcd&quot;</span>, *cloud); <br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;PointCloud before filtering: &quot;</span> &lt;&lt; cloud-&gt;width * cloud-&gt;height  &lt;&lt; <span class="hljs-string">&quot; data points (&quot;</span> &lt;&lt; pcl::<span class="hljs-built_in">getFieldsList</span> (*cloud) &lt;&lt; <span class="hljs-string">&quot;).&quot;</span> &lt;&lt; std::endl;<br>    <br>    <span class="hljs-comment">// 过滤</span><br>    pcl::VoxelGrid&lt;pcl::PCLPointCloud2&gt; sor;<br>    sor.<span class="hljs-built_in">setInputCloud</span> (cloud); <span class="hljs-comment">// 输入点云</span><br>    sor.<span class="hljs-built_in">setLeafSize</span> (<span class="hljs-number">0.01f</span>, <span class="hljs-number">0.01f</span>, <span class="hljs-number">0.01f</span>); <span class="hljs-comment">// 设置体素大小</span><br>    sor.<span class="hljs-built_in">filter</span> (*cloud_filtered);<br><br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;PointCloud after filtering: &quot;</span> &lt;&lt; cloud_filtered-&gt;width * cloud_filtered-&gt;height &lt;&lt; <span class="hljs-string">&quot; data points (&quot;</span> &lt;&lt; pcl::<span class="hljs-built_in">getFieldsList</span> (*cloud_filtered) &lt;&lt; <span class="hljs-string">&quot;).&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>然而，对于大规模的点云（如点个数超过100000），就会导致格点数超过整型最大值，报错：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Leaf size <span class="hljs-keyword">is</span> too small <span class="hljs-keyword">for</span> the <span class="hljs-keyword">input</span> dataset. <span class="hljs-type">Integer</span> indices would overflow.<br></code></pre></td></tr></table></figure><p>此时可以采用八叉树结构，将整个点云分成有大小限制的若干个叶节点，对每个叶节点分别做体素过滤，再合起来</p><h3 id="octree体素过滤"><a href="#octree体素过滤" class="headerlink" title="octree体素过滤"></a>octree体素过滤</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 原大规模点云</span><br>pcl::PointCloud&lt;pcl::PointXYZI&gt;::<span class="hljs-function">Ptr <span class="hljs-title">cloud_in</span><span class="hljs-params">(<span class="hljs-keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZI&gt;())</span></span>;<br><br><span class="hljs-comment">// 输出的降采样点云</span><br>pcl::PointCloud&lt;pcl::PointXYZI&gt;::<span class="hljs-function">Ptr <span class="hljs-title">cloud_out</span><span class="hljs-params">(<span class="hljs-keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZI&gt;())</span></span>;<br><br>pcl::PointCloud&lt;pcl::PointXYZI&gt;::<span class="hljs-function">Ptr <span class="hljs-title">cloud_tmp</span><span class="hljs-params">(<span class="hljs-keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZI&gt;())</span></span>;<br>pcl::PointCloud&lt;pcl::PointXYZI&gt;::<span class="hljs-function">Ptr <span class="hljs-title">cloud_tmp_ds</span><span class="hljs-params">(<span class="hljs-keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZI&gt;())</span></span>;<br><br><span class="hljs-comment">// 同样的体素过滤器VoxelGrid</span><br><span class="hljs-type">static</span> <span class="hljs-type">float</span> kLeafSize = <span class="hljs-number">0.2</span>;<br>pcl::VoxelGrid&lt;pcl::PointXYZI&gt; filter_map;<br>filter_map.<span class="hljs-built_in">setLeafSize</span>(kLeafSize, kLeafSize, kLeafSize);<br><br><span class="hljs-comment">// 将点云存入octree,设置子区域大小为1250*leaf_size（1250^3&lt;2^31，这样点数不会超过整型范围）</span><br><br>cloud_out-&gt;<span class="hljs-built_in">clear</span>();<br>pcl::octree::OctreePointCloud&lt;pcl::PointXYZI&gt; octree&#123;<span class="hljs-number">1250</span> * kLeafSize&#125;;<br>octree.<span class="hljs-built_in">setInputCloud</span>(cloud_map);<br>octree.<span class="hljs-built_in">addPointsFromInputCloud</span>();<br><br><span class="hljs-comment">// 遍历每个区域降采样</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = octree.<span class="hljs-built_in">leaf_depth_begin</span>(); it != octree.<span class="hljs-built_in">leaf_depth_end</span>(); ++it) &#123;<br>  <span class="hljs-keyword">auto</span> ids = it.<span class="hljs-built_in">getLeafContainer</span>().<span class="hljs-built_in">getPointIndicesVector</span>();<br>  cloud_tmp-&gt;<span class="hljs-built_in">clear</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> id : ids) &#123;<br>    cloud_tmp-&gt;<span class="hljs-built_in">push_back</span>(octree.<span class="hljs-built_in">getInputCloud</span>()-&gt;points[id]);<br>  &#125;<br>  filter_map.<span class="hljs-built_in">setInputCloud</span>(cloud_tmp);<br>  filter_map.<span class="hljs-built_in">filter</span>(*cloud_tmp_ds);<br>  *cloud_out += *cloud_tmp_ds;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SLAM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2024秋招华为机试题目记录(2023.8.30)</title>
    <link href="/2023/08/31/2024%E7%A7%8B%E6%8B%9B%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/08/31/2024%E7%A7%8B%E6%8B%9B%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="第一题（100分）"><a href="#第一题（100分）" class="headerlink" title="第一题（100分）"></a>第一题（100分）</h3><p>设计一个自动计算打卡时间的程序。输入：员工一天多次进出公司的时间点。输出：总有效工作时间。</p><ul><li>如果离开公司在15分钟以内，不从总时长中扣除</li><li>12:00-14:00,18:00-19:30是午休和晚餐时间，不算工作时间</li></ul><p><strong>输入描述：</strong></p><p>第一行:员工当天进门禁的次数n。</p><p>第二行:员工当天进门禁的所有时间，以空格分隔。（24小时制，格式为xx:xx）</p><p>第三行:员工当天出门禁的次数m。</p><p>第四行:员工当天出门禁的所有时间，以空格分隔。</p><p>注: 0 &lt; n,m &lt; 100，不存在相同的出入门禁时间，也不存在连续的出门禁或入门禁的情况。</p><p><strong>输出描述：</strong><br>当日的工作时长。</p><p><strong>样例输入</strong>：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">5</span><br><span class="hljs-attribute">07</span>:<span class="hljs-number">50</span> <span class="hljs-number">08</span>:<span class="hljs-number">50</span> <span class="hljs-number">12</span>:<span class="hljs-number">30</span> <span class="hljs-number">13</span>:<span class="hljs-number">40</span> <span class="hljs-number">19</span>:<span class="hljs-number">50</span><br><span class="hljs-attribute">5</span><br><span class="hljs-attribute">08</span>:<span class="hljs-number">45</span> <span class="hljs-number">12</span>:<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">20</span> <span class="hljs-number">18</span>:<span class="hljs-number">30</span> <span class="hljs-number">20</span>:<span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">530<br></code></pre></td></tr></table></figure><p><strong>My answer:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> in,out;<br>    cin &gt;&gt; in;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">in_time</span><span class="hljs-params">(in)</span></span>;<br>    string str;<br>    <span class="hljs-type">int</span> time;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; in; i++)<br>    &#123;<br>        cin &gt;&gt; str;<br>        time = <span class="hljs-built_in">stoi</span>(str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)) * <span class="hljs-number">60</span> + <span class="hljs-built_in">stoi</span>(str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">3</span>));<br>        <span class="hljs-keyword">if</span>(time&gt;<span class="hljs-number">12</span>*<span class="hljs-number">60</span> &amp;&amp; time&lt;=<span class="hljs-number">14</span>*<span class="hljs-number">60</span>)time=<span class="hljs-number">14</span>*<span class="hljs-number">60</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(time&gt;<span class="hljs-number">18</span>*<span class="hljs-number">60</span> &amp;&amp; time&lt;=<span class="hljs-number">195</span>*<span class="hljs-number">6</span>)time=<span class="hljs-number">195</span>*<span class="hljs-number">6</span>;<br>        in_time[i] = time;<br>    &#125;<br>    cin &gt;&gt; out;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">out_time</span><span class="hljs-params">(out)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; out; i++)<br>    &#123;<br>        cin &gt;&gt; str;<br>        time = <span class="hljs-built_in">stoi</span>(str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)) * <span class="hljs-number">60</span> + <span class="hljs-built_in">stoi</span>(str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">3</span>));<br>        <span class="hljs-keyword">if</span>(time&gt;=<span class="hljs-number">12</span>*<span class="hljs-number">60</span> &amp;&amp; time&lt;<span class="hljs-number">14</span>*<span class="hljs-number">60</span>)time=<span class="hljs-number">12</span>*<span class="hljs-number">60</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(time&gt;=<span class="hljs-number">18</span>*<span class="hljs-number">60</span> &amp;&amp; time&lt;<span class="hljs-number">195</span>*<span class="hljs-number">6</span>)time=<span class="hljs-number">18</span>*<span class="hljs-number">60</span>;<br>        out_time[i] = time;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> time_sum = out_time[out<span class="hljs-number">-1</span>] - in_time[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span>(out_time[out<span class="hljs-number">-1</span>]&gt;=<span class="hljs-number">195</span>*<span class="hljs-number">6</span> &amp;&amp; in_time[<span class="hljs-number">0</span>]&lt;=<span class="hljs-number">18</span>*<span class="hljs-number">60</span>)time_sum -= <span class="hljs-number">90</span>;<br>    <span class="hljs-keyword">if</span>(out_time[out<span class="hljs-number">-1</span>]&gt;=<span class="hljs-number">14</span>*<span class="hljs-number">60</span> &amp;&amp; in_time[<span class="hljs-number">0</span>]&lt;=<span class="hljs-number">12</span>*<span class="hljs-number">60</span>)time_sum -= <span class="hljs-number">120</span>;<br>        <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; in; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> back = in_time[i];<br>        <span class="hljs-type">int</span> leave = out_time[i<span class="hljs-number">-1</span>];<br>        <span class="hljs-type">int</span> leave_time = back - leave;<br>        <span class="hljs-keyword">if</span>(leave_time &lt;= <span class="hljs-number">15</span>)<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(back&gt;=<span class="hljs-number">195</span>*<span class="hljs-number">6</span> &amp;&amp; leave&lt;=<span class="hljs-number">18</span>*<span class="hljs-number">60</span>)leave_time -= <span class="hljs-number">90</span>;<br>        <span class="hljs-keyword">if</span>(back&gt;=<span class="hljs-number">14</span>*<span class="hljs-number">60</span> &amp;&amp; leave&lt;=<span class="hljs-number">12</span>*<span class="hljs-number">60</span>)leave_time -= <span class="hljs-number">120</span>;<br>        <span class="hljs-keyword">if</span>(leave_time &gt; <span class="hljs-number">0</span>)<br>            time_sum -= leave_time;      <br>    &#125;<br>    <span class="hljs-keyword">if</span>(time_sum &lt;<span class="hljs-number">0</span>)<br>        time_sum = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; time_sum &lt;&lt;endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p><strong>思路：</strong><br>(1) 读入时间的时候，进入的时间如果在休息时间内，就设成休息时间的结束。如果离开时间在休息时间内，就设成休息时间的开始。<br>(2) 总时间首先是最后离开的时间减去一开始进入的时间。再根据起止时间的范围，判断是否减去午休和晚餐的时间。<br>(3) 再考虑中间每次离开，如果大于15分钟，就从总时长中减去</p><h3 id="第二题（200分）"><a href="#第二题（200分）" class="headerlink" title="第二题（200分）"></a>第二题（200分）</h3><p>已知一棵完全二叉树，满足每个结点的值是它的叶结点频率的最大值加最小值除以2减去它的父节点的值之和。给定叶节点的个数和频率，求这个完全二叉树。</p><p>如：</p><img src="/2023/08/31/2024%E7%A7%8B%E6%8B%9B%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/1.png" class="" title="fig:1"><p>输入节点数4，输入四个节点的频率。根节点的叶节点为4个节点，四个节点的最大值加最小值除以2，再减去其根节点（没有根节点），得到13。其他节点同理，可以看到计算完成后，每一个根节点到叶节点的值之和是该叶节点的频率。</p><p><strong>输入描述：</strong></p><p>第一行：叶节点个数。一定是2的n次。</p><p>第二行：每个叶节点的频率，0 &lt; x &lt; 1000000</p><p><strong>输出描述：</strong></p><p>二叉树的层序遍历，注意最后不能有空格</p><p><strong>样例输入：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">18 </span><span class="hljs-number">24</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">13 </span><span class="hljs-number">8</span> -<span class="hljs-number">10</span> -<span class="hljs-number">3</span> <span class="hljs-number">3</span> -<span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>My answer:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_max_min</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; leaf, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> num, <span class="hljs-type">int</span>&amp; max, <span class="hljs-type">int</span> &amp;min)</span></span><br><span class="hljs-function"></span>&#123;<br>    min = leaf[left];<br>    max = leaf[left];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = left+<span class="hljs-number">1</span>; i &lt; left+num; i++)<br>    &#123;<br>        min = min &lt; leaf[i] ? min : leaf[i];<br>        max = max &gt; leaf[i] ? max : leaf[i];<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leaf</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>, min = <span class="hljs-number">1000000</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin &gt;&gt; leaf[i];<br>    &#125;<br>    <span class="hljs-type">int</span> layers = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">log</span>(n)/<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>)) + <span class="hljs-number">1</span>;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; fathers, fathers_tmp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; layers; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> num = n / <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,i);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,i);j++)<br>        &#123;<br>            <span class="hljs-type">int</span> value;<br>            <span class="hljs-keyword">if</span>(i != layers - <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-type">int</span> min,max;<br>                <span class="hljs-built_in">get_max_min</span>(leaf, num*(j), num, max, min);<br>                value  = (max+min)/<span class="hljs-number">2</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                value = leaf[j];<br>            fathers_tmp.<span class="hljs-built_in">push_back</span>(value);<br>            <span class="hljs-keyword">if</span>(fathers.<span class="hljs-built_in">size</span>()!=<span class="hljs-number">0</span>) value -= fathers[j/<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span>(j==n<span class="hljs-number">-1</span>)cout &lt;&lt; value &lt;&lt; endl;<br>            <span class="hljs-keyword">else</span><br>                cout &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        fathers.<span class="hljs-built_in">assign</span>(fathers_tmp.<span class="hljs-built_in">begin</span>(),fathers_tmp.<span class="hljs-built_in">end</span>());<br>        fathers_tmp.<span class="hljs-built_in">clear</span>();<br>    &#125;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路：</strong><br>从根节点开始按层计算。对每个节点，确定节点对应的叶节点，找到最大值最小值。同时保存上一层所有节点的父节点值加上本节点的值之和。</p><h3 id="第三题（300分）"><a href="#第三题（300分）" class="headerlink" title="第三题（300分）"></a>第三题（300分）</h3><p>有n个任务，任务之间有依赖关系（只有做完任务A，才能做任务B），每个任务需要不同内存，在尽快完成所有任务的情况下需要的最小内存是多少</p><p><strong>输入描述：</strong></p><p>第一行：任务个数</p><p>第二行：每个任务占用内存量</p><p>第3~3+n行：任务之间的依赖关系</p><p><strong>输出描述：</strong></p><p>需要的最小内存</p><p><em>这题没做完，案例也没有记录下来。拓扑排序相关之前做的比较少，如果有时间需要刷一刷这类题。</em></p>]]></content>
    
    
    <categories>
      
      <category>2024秋招记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>c++多线程学习笔记-2</title>
    <link href="/2023/08/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/"/>
    <url>/2023/08/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/</url>
    
    <content type="html"><![CDATA[<p>单纯的mutex需要手动进行加锁和解锁，如果加锁解锁不匹配，程序就会出现bug无法运行。此外，因为抛出异常或return等操作可能导致没有解锁就退出的问题。更好的办法是采用”资源分配时初始化”(RAII)方法来加锁、解锁。此时主要会用到lock_guard和unique_lock两个类。</p><h3 id="std-lock-guard"><a href="#std-lock-guard" class="headerlink" title="std::lock_guard"></a>std::lock_guard</h3><ul><li>当构造函数被调用时，该互斥量会被自动锁定</li><li>当析构函数被调用时，该互斥量会自动解锁</li><li>lock_guard对象不能复制或移动，因此只能在局部作用域中使用</li></ul><p>例子如下，两个线程都对一个全局变量进行累加，如果不加锁线程就可能同时对a进行操作，产生矛盾。使用lock_guard，我们不需要手动解锁，在lock_guard被析构时自动解锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>std::mutex mtx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br>    &#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(mtx)</span></span>;<br>        a++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; a &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">20000</span><br></code></pre></td></tr></table></figure><p>从lock_guard的源码分析（除了构造函数和析构函数以外，没有其他函数）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Mutex</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">lock_guard</span><br>&#123;<span class="hljs-comment">// class with destructor that unlocks a mutex</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">using</span> mutex_type = _Mutex;<br><br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">lock_guard</span><span class="hljs-params">(_Mutex&amp; _Mtx)</span></span><br><span class="hljs-function">: _MyMutex(_Mtx)</span><br><span class="hljs-function">&#123;</span><span class="hljs-comment">// 构造函数中对mtx加锁</span><br>_MyMutex.<span class="hljs-built_in">lock</span>();<br>&#125;<br><br><span class="hljs-built_in">lock_guard</span>(_Mutex&amp; _Mtx, <span class="hljs-type">adopt_lock_t</span>)<br>: _MyMutex(_Mtx)<br>&#123;<span class="hljs-comment">// 当前mtx已获得变量所有权时，调用lock_guard需要加一个常数，此时不用再次加锁</span><br>&#125;<br><br>~<span class="hljs-built_in">lock_guard</span>() <span class="hljs-keyword">noexcept</span><br>&#123;<span class="hljs-comment">// 在析构函数中对mtx解锁</span><br>_MyMutex.<span class="hljs-built_in">unlock</span>();<br>&#125;<br><br>    <span class="hljs-comment">// 禁用拷贝构造和等于（不能复制和移动）</span><br><span class="hljs-built_in">lock_guard</span>(<span class="hljs-type">const</span> lock_guard&amp;) = <span class="hljs-keyword">delete</span>;<br>lock_guard&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> lock_guard&amp;) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-keyword">private</span>:<br>_Mutex&amp; _MyMutex;<br>&#125;;<br><br></code></pre></td></tr></table></figure><div class="note note-success">            <p>explicit: 构造类时不支持隐式转换。也就是必须是一个已被定义为_Mutex类的变量才能用于构造lock_guard</p>          </div><h3 id="std-unique-lock"><a href="#std-unique-lock" class="headerlink" title="std::unique_lock"></a>std::unique_lock</h3><p>相比lock_guard，unique_lock可以对互斥量做更丰富的操作，因此使用更加广泛，但同时占用的资源也会更多。</p><h4 id="操作一：自动加锁解锁"><a href="#操作一：自动加锁解锁" class="headerlink" title="操作一：自动加锁解锁"></a>操作一：自动加锁解锁</h4><p>用上述例子，将lock_guard换成unique_lock可以实现同样功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>std::mutex mtx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br>    &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(mtx)</span></span>;<br>        a++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; a &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="操作二：延迟锁定"><a href="#操作二：延迟锁定" class="headerlink" title="操作二：延迟锁定"></a>操作二：延迟锁定</h4><p>当调用函数时传入std::defer_lock，构造函数不会自动加锁，而由程序员在后续代码中决定什么时候加锁，加什么样的锁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(mtx,std::defer_lock)</span></span>;<br></code></pre></td></tr></table></figure><p>查看源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">unique_lock</span>&#123;<br>    <span class="hljs-function">xxx</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">unique_lock</span><span class="hljs-params">(_Mutex&amp; _Mtx, <span class="hljs-type">defer_lock_t</span>)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">: _Pmtx(_STD addressof(_Mtx)), _Owns(false)</span><br><span class="hljs-function">&#123;</span><span class="hljs-comment">// 构造函数什么都不做，没有加锁</span><br>&#125;<br><br>    xxx<br>&#125;<br></code></pre></td></tr></table></figure><p>之后可以进行手动加锁：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">lg.lock()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>查看源码：是调用mutex的lock函数</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sqf">  void <span class="hljs-built_in">lock</span>()<br>&#123;<span class="hljs-comment">// lock the mutex</span><br><span class="hljs-variable">_Validate</span>();<br><span class="hljs-variable">_Pmtx</span>-&gt;<span class="hljs-built_in">lock</span>();<br><span class="hljs-variable">_Owns</span> = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="操作三：尝试加锁并返回是否加锁成功-try-lock"><a href="#操作三：尝试加锁并返回是否加锁成功-try-lock" class="headerlink" title="操作三：尝试加锁并返回是否加锁成功-try_lock"></a>操作三：尝试加锁并返回是否加锁成功-try_lock</h4><p>try_lock尝试获得mutex所有权，如果可以就加锁返回true，否则返回false，程序继续往下运行。</p><p>如下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>std::mutex mtx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(mtx, std::defer_lock)</span></span>;<br>    <span class="hljs-keyword">if</span>(lg.<span class="hljs-built_in">try_lock</span>())&#123;<br>        a++;<br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">3</span>));<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        b++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>t1获得mtx所有权后，会对a加1，等待2s，此时t2尝试获取mtx所有权，但无法获取，返回false，执行b加1.</p><p>也可以写成这样：在构造函数中加入try_to_lock的参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(mtx, std::try_to_lock)</span></span>;<br>    <span class="hljs-keyword">if</span>(lock.<span class="hljs-built_in">owns_lock</span>())&#123;<br>        a++;<br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">3</span>));<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        b++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="操作四：在一段时间内尝试加锁-try-lock-for"><a href="#操作四：在一段时间内尝试加锁-try-lock-for" class="headerlink" title="操作四：在一段时间内尝试加锁-try_lock_for"></a>操作四：在一段时间内尝试加锁-try_lock_for</h4><p>try_lock_for尝试在一定时间内获得mutex所有权，如果可以就加锁返回true，否则返回false，程序继续往下运行。</p><p>如下面的例子：(此时mutex要选用timed_mutex)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>std::timed_mutex mtx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-function">std::unique_lock&lt;timed_mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(mtx, std::defer_lock)</span></span>;<br>    <span class="hljs-keyword">if</span>(lg.<span class="hljs-built_in">try_lock_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>)))&#123;<br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">2</span>));<br>        a++;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        b++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>t1获得mtx所有权后，会对a加1，等待2s，此时t2尝试在5s内获取mtx所有权。在等待过程中t1休眠完毕，释放mtx所有权，t2就可以加锁，再对a加1。最终a&#x3D;2,b&#x3D;0</p><h4 id="特性：所有权可以移动但是不能复制"><a href="#特性：所有权可以移动但是不能复制" class="headerlink" title="特性：所有权可以移动但是不能复制"></a>特性：所有权可以移动但是不能复制</h4><p>查看源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++">    <span class="hljs-built_in">unique_lock</span>(unique_lock&amp;&amp; _Other) <span class="hljs-keyword">noexcept</span><br>: _Pmtx(_Other._Pmtx), _Owns(_Other._Owns)<br>&#123;<span class="hljs-comment">// 可以移动另一个mutex的所有权</span><br>_Other._Pmtx = <span class="hljs-literal">nullptr</span>;<br>_Other._Owns = <span class="hljs-literal">false</span>;<br>&#125;<br><br>unique_lock&amp; <span class="hljs-keyword">operator</span>=(unique_lock&amp;&amp; _Other)<br>&#123;<span class="hljs-comment">// 等号可以用于移动另一个mutex的所有权</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != _STD <span class="hljs-built_in">addressof</span>(_Other))<br>&#123;<br><span class="hljs-keyword">if</span> (_Owns)<br>_Pmtx-&gt;<span class="hljs-built_in">unlock</span>();<br>_Pmtx = _Other._Pmtx;<br>_Owns = _Other._Owns;<br>_Other._Pmtx = <span class="hljs-literal">nullptr</span>;<br>_Other._Owns = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> (*<span class="hljs-keyword">this</span>);<br>&#125;<br><br>    <span class="hljs-built_in">unique_lock</span>(<span class="hljs-type">const</span> unique_lock&amp;) = <span class="hljs-keyword">delete</span>;<br>    unique_lock&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> unique_lock&amp;) = <span class="hljs-keyword">delete</span>;<br>```  <br><br>### <span class="hljs-built_in">call_once</span>()<br><br>使用场景：某些类是单例模式，在整个程序中只能创建一个实例，此时多线程调用可能有问题。<br><br>如下面的例子，该类使用了一个静态成员函数 <span class="hljs-built_in">getInstance</span>() 来获取单例实例，用了一个静态局部变量 instance 来存储单例实例。由于静态局部变量只会被初始化一次，因此该实现可以确保单例实例只会被创建一次。<br><br>```C++<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>         <span class="hljs-type">static</span> Singleton instance;<br>         <span class="hljs-keyword">return</span> instance;<br>    &#125;    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setData</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>         m_data = data;<br>    &#125;    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>         <span class="hljs-keyword">return</span> m_data;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125; <span class="hljs-comment">//构造函数为private</span><br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;    <span class="hljs-comment">// 禁用拷贝构造和等号</span><br>    <span class="hljs-type">int</span> m_data = <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>但如果多个线程同时调用 getInstance() 函数，可能会导致多个对象被创建，从而违反了单例模式的要求。并且可能会出现多个线程同时调用 setData() 函数来修改m_data，可能会导致数据不一致或不正确的结果。</p><p>此时可以用call_once函数，call_once函数将输入一个std::once_flag类型的变量，用于标记该函数是否已经被调用过。将该类改写为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>            std::<span class="hljs-built_in">call_once</span>(m_onceFlag, &amp;Singleton::init);<br>            <span class="hljs-keyword">return</span> *m_instance;<br>    &#125;    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setData</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>        m_data = data;<br>    &#125;    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;        <br>    <span class="hljs-keyword">return</span> m_data;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;    <br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        m_instance.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> Singleton);<br>    &#125;    <br>    <span class="hljs-type">static</span> std::unique_ptr&lt;Singleton&gt; m_instance;    <br>    <span class="hljs-type">static</span> std::once_flag m_onceFlag;    <br>    <span class="hljs-type">int</span> m_data = <span class="hljs-number">0</span>;<br>&#125;;<br><br>std::unique_ptr&lt;Singleton&gt; Singleton::m_instance;<br>std::once_flag Singleton::m_onceFlag;<br></code></pre></td></tr></table></figure><p>此时，我们创建了一个静态成员变量 m_onceFlag 来标记初始化是否已经完成。在 getInstance() 函数中，我们使用 std::call_once 来调用 init() 函数，仅当第一次调用时m_onceFlag有效，可以调用init()。后续再有线程运行到此处无法调用init()，直接返回该实例。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="http://www.seestudy.cn/?list_9/">陈子青C++公开课:C++11 跨平台多线程编程与线程池</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++多线程学习笔记-1</title>
    <link href="/2023/08/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
    <url>/2023/08/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>进程与线程：</p><p>进程是运行中的程序。</p><p>线程是进程中可并行的一个子程序，主要目的是提高程序运行效率。最大线程个数是CPU核数。</p>          </div><h3 id="Thread线程库的基本使用"><a href="#Thread线程库的基本使用" class="headerlink" title="Thread线程库的基本使用"></a>Thread线程库的基本使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printMessage</span><span class="hljs-params">(std::string msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; msg &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(printMessage, <span class="hljs-string">&quot;Hello thread!&quot;</span>)</span></span>;<br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li><p>定义一个线程：</p> <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-title">std::</span><span class="hljs-keyword">thread</span>(function_name, args)<br></code></pre></td></tr></table></figure></li><li><p>等待线程完成</p> <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">t.<span class="hljs-keyword">join</span>()<br></code></pre></td></tr></table></figure><p> 等待线程完成后主程序才往下运行。如果没有这一句，上面的线程在没有打印完msg时主程序已结束，就会报错。</p></li><li><p>分离线程</p> <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">t.detach<span class="hljs-comment">()</span><br></code></pre></td></tr></table></figure><p> 分离线程，让它在后台运行。往往用于多进程的情况。</p></li><li><p>joinable</p> <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">bool isJoin <span class="hljs-operator">=</span> t.joinable()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p> joinable()方法返回一个布尔值，如果线程可以被join()或detach()，则返回true，否则返回false。防止直接使用join报错。</p></li></ol><h4 id="变量未定义问题"><a href="#变量未定义问题" class="headerlink" title="变量未定义问题"></a>变量未定义问题</h4><p>传递的函数需要引用，指针类型变量时容易出现的线程没运行完，变量已被释放的问题。</p><ol><li><p>函数参数是引用</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span></span>&#123;<br>    x += <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(foo, std::ref(a))</span></span>;<br>    t.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; a &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> std::ref用于取某个变量的引用，但要保证在线程函数执行期间，变量 <code>a</code> 的生命周期是有效的。</p></li><li><p>函数参数是指针</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>* x)</span></span>&#123;<br>    std::cout &lt;&lt; *x &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> *ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(foo, ptr)</span></span>;<br>    <span class="hljs-comment">// delete ptr;</span><br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 如果在注释处释放指针，线程还没执行完，foo函数根据地址取到的就是一个未知的数。</p></li><li><p>解决方法：用智能指针</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>&#123;<br>        std::cout&lt;&lt; <span class="hljs-string">&quot;Hello!&quot;</span> &lt;&lt; std::endl; <br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::shared_ptr&lt;A&gt; a = std::make_shared&lt;A&gt;;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(&amp;A::foo, a)</span></span>;<br><br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 用智能指针来定义需要传递的指针参数，这样该参数就能在不需要的时候自动析构。</p></li><li><p>入口函数为类的私有函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// friend void thread_foo();</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>&#123;<br>        std::cout&lt;&lt; <span class="hljs-string">&quot;Hello!&quot;</span> &lt;&lt; std::endl; <br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::shared_ptr&lt;A&gt; a = std::make_shared&lt;A&gt;;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(&amp;A::foo, a)</span></span>;<br><br>    t.<span class="hljs-built_in">join</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">thread_foo</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果直接运行，会报错，因为函数thread_foo无法访问类的私由函数。但用注释那行，将该函数设为友元，则可以访问。</p></li></ol><h3 id="互斥量mutex"><a href="#互斥量mutex" class="headerlink" title="互斥量mutex"></a>互斥量mutex</h3><p>多个线程访问一个变量，且对变量进行修改，此时会出现函数竞争问题，导致函数运行结果不确定。因此需要用到互斥锁，使得每次只能有一个程序访问变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>std::mutex mtx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br>    &#123;<br>        mtx.<span class="hljs-built_in">lock</span>();<br>        a += <span class="hljs-number">1</span>;<br>        mtx.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; a &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>倘若不加互斥锁，可能导致多个线程对a操作，此时操作重叠就可能出现问题。加了互斥锁，每次只能有一个线程访问a，使得最终<code>a=20000</code></p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>如下面程序中的情况，线程<code>t1</code>运行<code>func1</code>，获取了<code>mtx1</code>的所有权，如果此时正好线程<code>t2</code>运行<code>func2</code>获得了<code>mtx2</code>的所有权。那就会出现<code>t1</code>,<code>t2</code>都在等对方，都无法运行的死锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br>std::mutex mtx1, mtx2;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123;  <br>    mtx1.<span class="hljs-built_in">lock</span>();  <br>    mtx2.<span class="hljs-built_in">lock</span>();                  <br>    mtx2.<span class="hljs-built_in">unlock</span>();<br>    mtx1.<span class="hljs-built_in">unlock</span>();    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123;    <br>    mtx2.<span class="hljs-built_in">lock</span>();<br>    mtx1.<span class="hljs-built_in">lock</span>();        <br>    mtx1.<span class="hljs-built_in">unlock</span>();    <br>    mtx2.<span class="hljs-built_in">unlock</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func1)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func2)</span></span>;    <br>    t1.<span class="hljs-built_in">join</span>();    <br>    t2.<span class="hljs-built_in">join</span>();    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.seestudy.cn/?list_9/">http://www.seestudy.cn/?list_9/</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pyside6安装后报错及解决方法</title>
    <link href="/2023/08/24/pyside6%E5%AE%89%E8%A3%85%E5%90%8E%E4%BD%BF%E7%94%A8%E6%8A%A5%E9%94%99/"/>
    <url>/2023/08/24/pyside6%E5%AE%89%E8%A3%85%E5%90%8E%E4%BD%BF%E7%94%A8%E6%8A%A5%E9%94%99/</url>
    
    <content type="html"><![CDATA[<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>ubuntu 20.04</p><h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><p>通过pip安装完后pyside6，使用时报错</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">qt.qpa.plugin: Could <span class="hljs-keyword">not</span> <span class="hljs-built_in">load</span> <span class="hljs-keyword">the</span> Qt <span class="hljs-built_in">platform</span> plugin <span class="hljs-string">&quot;xcb&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;&quot;</span> even though <span class="hljs-keyword">it</span> was found.<br>This application failed <span class="hljs-built_in">to</span> <span class="hljs-built_in">start</span> because no Qt <span class="hljs-built_in">platform</span> plugin could be initialized. Reinstalling <span class="hljs-keyword">the</span> application may fix this problem.<br><br>Available <span class="hljs-built_in">platform</span> plugins are: offscreen, wayland-egl, linuxfb, vkkhrdisplay, minimalegl, minimal, wayland, xcb, eglfs, vnc.<br><br>Aborted (core dumped)<br></code></pre></td></tr></table></figure><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>参考<a href="https://blog.csdn.net/LOVEmy134611/article/details/107212845">https://blog.csdn.net/LOVEmy134611/article/details/107212845</a></p><ol><li><p>修改脚本文件<code>~/.bashrc</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">vim ~/.bashrc</span><br></code></pre></td></tr></table></figure></li><li><p>在最后加入</p> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">QT_DEBUG_PLUGINS</span>=1<br></code></pre></td></tr></table></figure></li><li><p>保存退出，使配置文件生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">source</span> ~/.bashrc</span><br></code></pre></td></tr></table></figure></li><li><p>再次调用pyside6函数，查看详细报错输出，在最下方找到</p> <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">xxx<br>libxcb-cursor.<span class="hljs-keyword">so</span>.0: cannot <span class="hljs-keyword">open</span> shared object <span class="hljs-keyword">file</span>: <span class="hljs-keyword">No</span> such <span class="hljs-keyword">file</span> or directory<br>xxx<br></code></pre></td></tr></table></figure></li><li><p>安装库libxcb-cursor0后，能够正常运行</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> libxcb-cursor0<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2024秋招美团笔试题目记录(2023.8.12, 2023.8.19)</title>
    <link href="/2023/08/12/2024%E7%A7%8B%E6%8B%9B%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95(2023.8.12,2023.8.19)/"/>
    <url>/2023/08/12/2024%E7%A7%8B%E6%8B%9B%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95(2023.8.12,2023.8.19)/</url>
    
    <content type="html"><![CDATA[<h2 id="8-12"><a href="#8-12" class="headerlink" title="8.12"></a>8.12</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p><strong>题目描述：</strong></p><p>给定一个排列$A &#x3D; [a_1, a_2, …, a_n]$，数字不重复。给定两个数x, y, 判断x, y 在A中是否相邻，输出yes or no.</p><p><strong>例子：</strong><br>输入第一行是A的长度，第二行A，第三行x y</p><p>Input: </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">No</span><br></code></pre></td></tr></table></figure><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p><a href="https://leetcode.cn/problems/distance-between-bus-stops/">Leetcode 1184. 公交站间的距离</a></p><h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><p><strong>题目描述：</strong></p><p>给一个矩阵$A_{mxn}$，代表一块蛋糕，每个位置的值$A_{i,j}$代表这部分蛋糕的美味度，横着或竖着切一刀，使得两部分蛋糕美味度之差尽可能小。输出最小的差。</p><p><strong>例子：</strong><br>输入第一行是m，n，第二行开始是A</p><p>Input: </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span> <br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">0<br></code></pre></td></tr></table></figure><h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><p><strong>题目描述：</strong><br>给定一棵树，开始时所有节点为白色。如果两个相连的节点的值相乘是完全平方数，且它们都是白色，可以将这两个节点染成红色。输出最多能染色几个节点。</p><p><strong>例子：</strong><br>输入第一行是节点数n，第二行是各个节点的值，接下来n-1行是节点的边</p><p>Input: </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">3</span> <span class="hljs-number">12</span> <br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure><p>My answer:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">issquare</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">sqrt</span>(n));<br>    <span class="hljs-keyword">if</span>(x * x == n)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Solution</span>(<span class="hljs-type">int</span> n)<br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>            edge.<span class="hljs-built_in">resize</span>(n, tmp);<br>            match.<span class="hljs-built_in">resize</span>(n, <span class="hljs-number">-1</span>);<br>            num = n;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">        </span>&#123;<br>            edge[i].<span class="hljs-built_in">push_back</span>(j);<br>            edge[j].<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search_max</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (match[i] != <span class="hljs-number">-1</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j:edge[i])<br>            &#123;<br>                <span class="hljs-keyword">if</span> (match[j] == <span class="hljs-number">-1</span> || <span class="hljs-built_in">search</span>(match[j]))<br>                &#123;<br>                    match[i] = j;<br>                    match[j] = i;<br>                    sum++;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : edge[i])<br>        &#123;<br>            <span class="hljs-keyword">if</span>(j == match[i])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(match[j] == <span class="hljs-number">-1</span> || <span class="hljs-built_in">search</span>(match[j]))<br>            &#123;<br>                match[i] = j;<br>                match[j] = i;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> num;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; edge;<br>        vector&lt;<span class="hljs-type">int</span>&gt; match;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n) &#123; <span class="hljs-comment">// 注意 while 处理多个 case</span><br>        <span class="hljs-function">Solution <span class="hljs-title">s</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">value</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            cin &gt;&gt; value[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> x, y;<br>            cin &gt;&gt; x &gt;&gt; y;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">issquare</span>(value[x<span class="hljs-number">-1</span>] * value[y<span class="hljs-number">-1</span>]))&#123;<br>                s.<span class="hljs-built_in">add_edge</span>(x - <span class="hljs-number">1</span>, y - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;        <br>        cout &lt;&lt; s.<span class="hljs-built_in">search_max</span>() * <span class="hljs-number">2</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-19"><a href="#8-19" class="headerlink" title="8.19"></a>8.19</h2><h3 id="第一题-1"><a href="#第一题-1" class="headerlink" title="第一题"></a>第一题</h3><p><strong>题目描述：</strong></p><p>给定一个整数x，一个上限m，当x超过上限m时从1开始重新计数（就是取余）</p><p><strong>例子：</strong></p><p>输入第一个数x，第二个m</p><p>Input: </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>2<br>4<br>2<br></code></pre></td></tr></table></figure><h3 id="第二题-1"><a href="#第二题-1" class="headerlink" title="第二题"></a>第二题</h3><p>输入一个整数数组${a_i}$，总和$sum&#x3D;a_1 + a_2 + … + a_n$，可以将其中一个加号换成乘号，也可以不换。求可能的sum的最大值</p><p><strong>例子：</strong></p><p>第一行是数组个数</p><p>第二行是数组元素</p><p>Input: </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">24<br></code></pre></td></tr></table></figure><p>1 + 2 + 4 * 5 + 1 &#x3D; 24</p><p>可以枚举乘号的位置，只需要注意$a_i$变量类型设为long long int</p><h3 id="第三题-1"><a href="#第三题-1" class="headerlink" title="第三题"></a>第三题</h3><p><strong>题目描述：</strong></p><p>对于一个只含0，1的字符串，对其某一位取反定义为操作一次，对一个字符串操作最少次数使其相邻两位不同，这个最少次数为字符串的权值。现给定一个字符串，求其所有字符串的权值之和。</p><p><strong>例子：</strong></p><p>Input: </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">10001<br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">8<br></code></pre></td></tr></table></figure><p>长度为2的子串：两个00，每个权重为1<br>长度为3的子串：3个子串，每个权重为1<br>长度为4的子串：2个子串，每个权重为1<br>长度为5的子串：1个，权重为1<br>总共 2 + 3 + 2 + 1 &#x3D; 8</p><p>My answer:<br>假设对长度为len,结束位置为i的子字符串，使其变为相邻两位不同且最后一位为0的最小变换次数为$a_0[len][i]$,最后一位为1的最小变换次数为$a_1[len][i]$。则递推公式为</p><p>若s[i] &#x3D; 0：</p><p>$$a_0[len][i] &#x3D; min(a_1[len - 1][i-1], len - 1)$$<br>$$a_1[len][i] &#x3D; min(a_0[len - 1][i-1], len)$$</p><p>s[i] &#x3D; 1同理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; s) &#123; <span class="hljs-comment">// 注意 while 处理多个 case</span><br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a0</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">a0_tmp</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a1</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">a1_tmp</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;0&#x27;</span>)<br>                a1[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                a0[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">2</span>; l &lt;= n; l++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>; i &lt; n; i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;0&#x27;</span>)<br>                &#123;<br>                    a0_tmp[i] = <span class="hljs-built_in">min</span>(a1[i<span class="hljs-number">-1</span>], l - <span class="hljs-number">1</span>);<br>                    a1_tmp[i] = <span class="hljs-built_in">min</span>(a0[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>, l);<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    a1_tmp[i] = <span class="hljs-built_in">min</span>(a0[i<span class="hljs-number">-1</span>], l - <span class="hljs-number">1</span>);<br>                    a0_tmp[i] = <span class="hljs-built_in">min</span>(a1[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>, l);<br>                &#125;<br>                sum += <span class="hljs-built_in">min</span>(a0_tmp[i],a1_tmp[i]);<br>            &#125;<br>            a0.<span class="hljs-built_in">swap</span>(a0_tmp);<br>            a1.<span class="hljs-built_in">swap</span>(a1_tmp);<br>        &#125;<br>        cout &lt;&lt; sum &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第四题-1"><a href="#第四题-1" class="headerlink" title="第四题"></a>第四题</h3><p><strong>题目描述：</strong><br>给定n个正数，一次操作可以对一个数加1，一个数减1. 问使其众数出现次数最多的最少操作数。</p><p><strong>例子：</strong></p><p>第一行是n</p><p>第二行是n个数</p><p>Input: </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span> <br><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>0<br></code></pre></td></tr></table></figure><p>这题没做出来，只想到</p><ul><li><p>如果$a_i$的总和sum能整除n，那最小次数就是 $\frac{1}{2}\sum |a_i - \frac{sum}{n}|$</p></li><li><p>如果不整除，众数个数已等于n-1，答案就是0</p></li><li><p>其他情况：<br>n个数，将其中n-1个变为值v，要次数最少那剩余的一个一定是最大值或最小值。应该要枚举v的可能取值？</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>2024秋招记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/08/10/hello-world/"/>
    <url>/2023/08/10/hello-world/</url>
    
    <content type="html"><![CDATA[<h2 id="写博客的初衷"><a href="#写博客的初衷" class="headerlink" title="写博客的初衷"></a>写博客的初衷</h2><p>有一个毛病困扰了我很久，也是近几年阻碍我向前走的主要原因———我消极的完美主义。</p><p>追溯它的源头，大概是我从小在与世界交互时，收到一些负反馈（比如难以建立良好的人际关系，感觉到他人的疏远，排斥，不喜），我没有勇敢地去面对问题，而是更封闭自己，开始在虚假的幻想中获得安慰。看那些虚无缥缈的小说，假设自己是一个完美的被所有人爱的主角，每晚在这样幻想中沉沉睡去。我变得逃避现实，不敢面对问题；我追求一个完美的虚假的形象；我极度渴望得到他人的认可与爱。</p><p>这些病态的心理导致了我严重的拖延症，行动力差，自我封闭。我在工作时经常陷入无关紧要的细节，在多人场合中保持沉默，甚至连朋友圈都不敢发。我得想办法解决或者改善这个毛病。</p><p>我尝试通过看书找到药方，或者用道理说服自己。从心理上来说，我要改变的底层认知是：接受不完美的自己；意识到微小的进步有巨大的意义。但从小扎根在心底的认知似乎很难改变。我想应该直接从行动出发，或许写博客是一个很好的治愈方法。</p><p>在博客中尽量把我真实的所思所想，我的学习过程写出来，一段粗糙的读书笔记也好，一个简单的技术问题总结也好，尽管不完美也可以直接发出来，被素不相识的人们看到。浅薄无知，笨拙粗糙都没有关系，在一点点的进步中，或许我也会得到肯定和鼓励，而这将带给我莫大的欢喜。</p><h2 id="关于西西弗斯的石头"><a href="#关于西西弗斯的石头" class="headerlink" title="关于西西弗斯的石头"></a>关于西西弗斯的石头</h2><p>西西弗斯的神话里，他绑架了死神，让世间没有死亡，因此受到惩罚，要将一块巨石推上山顶，石头快到山顶就滚落，西西弗斯因此永无止境地重复这样毫无意义的事。</p><p>在加缪对这个故事的解释里，人生就和推石块一样，一样的荒谬，一样的无意义。但当西西弗斯去在意脚下的泥土，去观察巨石的颗粒，当他勇敢无畏地，坚定地选择一次一次推上石块，与虚无进行抗争时，他就为自己创造了意义。我读到这个故事时深为触动，后来看了一些对存在主义哲学的介绍，这些观念塑造了我基础的人生观：</p><p><strong>人生没有既定的意义，需要自己去赋予。但存在本身是有意义的，只有存在才能观察，才能感受。</strong> 因此这个博客也以此为名，这是我的石头，是我认为或许没意义但是要做的事，而我将在这个过程去体验，去观察，去感受。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
